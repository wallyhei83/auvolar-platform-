
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ProductDocAsset
 * 
 */
export type ProductDocAsset = $Result.DefaultSelection<Prisma.$ProductDocAssetPayload>
/**
 * Model Case
 * 
 */
export type Case = $Result.DefaultSelection<Prisma.$CasePayload>
/**
 * Model CaseAttachment
 * 
 */
export type CaseAttachment = $Result.DefaultSelection<Prisma.$CaseAttachmentPayload>
/**
 * Model CaseMessage
 * 
 */
export type CaseMessage = $Result.DefaultSelection<Prisma.$CaseMessagePayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model SpecPackage
 * 
 */
export type SpecPackage = $Result.DefaultSelection<Prisma.$SpecPackagePayload>
/**
 * Model TaxExemptDocument
 * 
 */
export type TaxExemptDocument = $Result.DefaultSelection<Prisma.$TaxExemptDocumentPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model PartnerAttribution
 * 
 */
export type PartnerAttribution = $Result.DefaultSelection<Prisma.$PartnerAttributionPayload>
/**
 * Model QboSyncLog
 * 
 */
export type QboSyncLog = $Result.DefaultSelection<Prisma.$QboSyncLogPayload>
/**
 * Model ShippingSyncLog
 * 
 */
export type ShippingSyncLog = $Result.DefaultSelection<Prisma.$ShippingSyncLogPayload>
/**
 * Model KnowledgeBaseEntry
 * 
 */
export type KnowledgeBaseEntry = $Result.DefaultSelection<Prisma.$KnowledgeBaseEntryPayload>
/**
 * Model AIChatLog
 * 
 */
export type AIChatLog = $Result.DefaultSelection<Prisma.$AIChatLogPayload>
/**
 * Model CaseStudy
 * 
 */
export type CaseStudy = $Result.DefaultSelection<Prisma.$CaseStudyPayload>
/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model AIClientProfile
 * 
 */
export type AIClientProfile = $Result.DefaultSelection<Prisma.$AIClientProfilePayload>
/**
 * Model AIConversation
 * 
 */
export type AIConversation = $Result.DefaultSelection<Prisma.$AIConversationPayload>
/**
 * Model AILeadData
 * 
 */
export type AILeadData = $Result.DefaultSelection<Prisma.$AILeadDataPayload>
/**
 * Model AICompanyIntelligence
 * 
 */
export type AICompanyIntelligence = $Result.DefaultSelection<Prisma.$AICompanyIntelligencePayload>
/**
 * Model AIStrategyPerformance
 * 
 */
export type AIStrategyPerformance = $Result.DefaultSelection<Prisma.$AIStrategyPerformancePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  CUSTOMER: 'CUSTOMER',
  PARTNER: 'PARTNER',
  STAFF: 'STAFF',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const DocType: {
  CUT_SHEET: 'CUT_SHEET',
  IES: 'IES',
  INSTALL_GUIDE: 'INSTALL_GUIDE',
  DIMENSIONS: 'DIMENSIONS',
  DLC_CERT: 'DLC_CERT',
  WARRANTY: 'WARRANTY',
  OTHER: 'OTHER'
};

export type DocType = (typeof DocType)[keyof typeof DocType]


export const CaseType: {
  RFQ: 'RFQ',
  BOM: 'BOM',
  RMA: 'RMA',
  SHIPPING_DAMAGE: 'SHIPPING_DAMAGE',
  PHOTOMETRIC: 'PHOTOMETRIC',
  REBATE: 'REBATE',
  NET_TERMS: 'NET_TERMS',
  SUPPORT: 'SUPPORT'
};

export type CaseType = (typeof CaseType)[keyof typeof CaseType]


export const CaseStatus: {
  RECEIVED: 'RECEIVED',
  IN_REVIEW: 'IN_REVIEW',
  NEED_INFO: 'NEED_INFO',
  COMPLETED: 'COMPLETED',
  CLOSED: 'CLOSED'
};

export type CaseStatus = (typeof CaseStatus)[keyof typeof CaseStatus]


export const CasePriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type CasePriority = (typeof CasePriority)[keyof typeof CasePriority]


export const QuoteStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type QuoteStatus = (typeof QuoteStatus)[keyof typeof QuoteStatus]


export const TaxExemptStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type TaxExemptStatus = (typeof TaxExemptStatus)[keyof typeof TaxExemptStatus]


export const PartnerType: {
  REP: 'REP',
  INSTALLER: 'INSTALLER',
  DISTRIBUTOR: 'DISTRIBUTOR'
};

export type PartnerType = (typeof PartnerType)[keyof typeof PartnerType]


export const PartnerStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  SUSPENDED: 'SUSPENDED'
};

export type PartnerStatus = (typeof PartnerStatus)[keyof typeof PartnerStatus]


export const SyncStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  SKIPPED: 'SKIPPED'
};

export type SyncStatus = (typeof SyncStatus)[keyof typeof SyncStatus]


export const CompanySize: {
  STARTUP: 'STARTUP',
  SMB: 'SMB',
  ENTERPRISE: 'ENTERPRISE',
  FORTUNE500: 'FORTUNE500'
};

export type CompanySize = (typeof CompanySize)[keyof typeof CompanySize]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  PROPOSAL: 'PROPOSAL',
  NEGOTIATION: 'NEGOTIATION',
  WON: 'WON',
  LOST: 'LOST',
  ARCHIVED: 'ARCHIVED'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const SalesStage: {
  DISCOVERY: 'DISCOVERY',
  NEEDS_ANALYSIS: 'NEEDS_ANALYSIS',
  PROPOSAL: 'PROPOSAL',
  NEGOTIATION: 'NEGOTIATION',
  CLOSING: 'CLOSING',
  FOLLOW_UP: 'FOLLOW_UP'
};

export type SalesStage = (typeof SalesStage)[keyof typeof SalesStage]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type DocType = $Enums.DocType

export const DocType: typeof $Enums.DocType

export type CaseType = $Enums.CaseType

export const CaseType: typeof $Enums.CaseType

export type CaseStatus = $Enums.CaseStatus

export const CaseStatus: typeof $Enums.CaseStatus

export type CasePriority = $Enums.CasePriority

export const CasePriority: typeof $Enums.CasePriority

export type QuoteStatus = $Enums.QuoteStatus

export const QuoteStatus: typeof $Enums.QuoteStatus

export type TaxExemptStatus = $Enums.TaxExemptStatus

export const TaxExemptStatus: typeof $Enums.TaxExemptStatus

export type PartnerType = $Enums.PartnerType

export const PartnerType: typeof $Enums.PartnerType

export type PartnerStatus = $Enums.PartnerStatus

export const PartnerStatus: typeof $Enums.PartnerStatus

export type SyncStatus = $Enums.SyncStatus

export const SyncStatus: typeof $Enums.SyncStatus

export type CompanySize = $Enums.CompanySize

export const CompanySize: typeof $Enums.CompanySize

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type SalesStage = $Enums.SalesStage

export const SalesStage: typeof $Enums.SalesStage

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productDocAsset`: Exposes CRUD operations for the **ProductDocAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductDocAssets
    * const productDocAssets = await prisma.productDocAsset.findMany()
    * ```
    */
  get productDocAsset(): Prisma.ProductDocAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.case`: Exposes CRUD operations for the **Case** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cases
    * const cases = await prisma.case.findMany()
    * ```
    */
  get case(): Prisma.CaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseAttachment`: Exposes CRUD operations for the **CaseAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseAttachments
    * const caseAttachments = await prisma.caseAttachment.findMany()
    * ```
    */
  get caseAttachment(): Prisma.CaseAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseMessage`: Exposes CRUD operations for the **CaseMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseMessages
    * const caseMessages = await prisma.caseMessage.findMany()
    * ```
    */
  get caseMessage(): Prisma.CaseMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specPackage`: Exposes CRUD operations for the **SpecPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecPackages
    * const specPackages = await prisma.specPackage.findMany()
    * ```
    */
  get specPackage(): Prisma.SpecPackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxExemptDocument`: Exposes CRUD operations for the **TaxExemptDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxExemptDocuments
    * const taxExemptDocuments = await prisma.taxExemptDocument.findMany()
    * ```
    */
  get taxExemptDocument(): Prisma.TaxExemptDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partnerAttribution`: Exposes CRUD operations for the **PartnerAttribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerAttributions
    * const partnerAttributions = await prisma.partnerAttribution.findMany()
    * ```
    */
  get partnerAttribution(): Prisma.PartnerAttributionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qboSyncLog`: Exposes CRUD operations for the **QboSyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QboSyncLogs
    * const qboSyncLogs = await prisma.qboSyncLog.findMany()
    * ```
    */
  get qboSyncLog(): Prisma.QboSyncLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shippingSyncLog`: Exposes CRUD operations for the **ShippingSyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingSyncLogs
    * const shippingSyncLogs = await prisma.shippingSyncLog.findMany()
    * ```
    */
  get shippingSyncLog(): Prisma.ShippingSyncLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeBaseEntry`: Exposes CRUD operations for the **KnowledgeBaseEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBaseEntries
    * const knowledgeBaseEntries = await prisma.knowledgeBaseEntry.findMany()
    * ```
    */
  get knowledgeBaseEntry(): Prisma.KnowledgeBaseEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIChatLog`: Exposes CRUD operations for the **AIChatLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIChatLogs
    * const aIChatLogs = await prisma.aIChatLog.findMany()
    * ```
    */
  get aIChatLog(): Prisma.AIChatLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseStudy`: Exposes CRUD operations for the **CaseStudy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseStudies
    * const caseStudies = await prisma.caseStudy.findMany()
    * ```
    */
  get caseStudy(): Prisma.CaseStudyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIClientProfile`: Exposes CRUD operations for the **AIClientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIClientProfiles
    * const aIClientProfiles = await prisma.aIClientProfile.findMany()
    * ```
    */
  get aIClientProfile(): Prisma.AIClientProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIConversation`: Exposes CRUD operations for the **AIConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIConversations
    * const aIConversations = await prisma.aIConversation.findMany()
    * ```
    */
  get aIConversation(): Prisma.AIConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aILeadData`: Exposes CRUD operations for the **AILeadData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AILeadData
    * const aILeadData = await prisma.aILeadData.findMany()
    * ```
    */
  get aILeadData(): Prisma.AILeadDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aICompanyIntelligence`: Exposes CRUD operations for the **AICompanyIntelligence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AICompanyIntelligences
    * const aICompanyIntelligences = await prisma.aICompanyIntelligence.findMany()
    * ```
    */
  get aICompanyIntelligence(): Prisma.AICompanyIntelligenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIStrategyPerformance`: Exposes CRUD operations for the **AIStrategyPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIStrategyPerformances
    * const aIStrategyPerformances = await prisma.aIStrategyPerformance.findMany()
    * ```
    */
  get aIStrategyPerformance(): Prisma.AIStrategyPerformanceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ProductDocAsset: 'ProductDocAsset',
    Case: 'Case',
    CaseAttachment: 'CaseAttachment',
    CaseMessage: 'CaseMessage',
    Quote: 'Quote',
    Project: 'Project',
    SpecPackage: 'SpecPackage',
    TaxExemptDocument: 'TaxExemptDocument',
    Partner: 'Partner',
    PartnerAttribution: 'PartnerAttribution',
    QboSyncLog: 'QboSyncLog',
    ShippingSyncLog: 'ShippingSyncLog',
    KnowledgeBaseEntry: 'KnowledgeBaseEntry',
    AIChatLog: 'AIChatLog',
    CaseStudy: 'CaseStudy',
    AnalyticsEvent: 'AnalyticsEvent',
    AIClientProfile: 'AIClientProfile',
    AIConversation: 'AIConversation',
    AILeadData: 'AILeadData',
    AICompanyIntelligence: 'AICompanyIntelligence',
    AIStrategyPerformance: 'AIStrategyPerformance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "productDocAsset" | "case" | "caseAttachment" | "caseMessage" | "quote" | "project" | "specPackage" | "taxExemptDocument" | "partner" | "partnerAttribution" | "qboSyncLog" | "shippingSyncLog" | "knowledgeBaseEntry" | "aIChatLog" | "caseStudy" | "analyticsEvent" | "aIClientProfile" | "aIConversation" | "aILeadData" | "aICompanyIntelligence" | "aIStrategyPerformance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ProductDocAsset: {
        payload: Prisma.$ProductDocAssetPayload<ExtArgs>
        fields: Prisma.ProductDocAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductDocAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductDocAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>
          }
          findFirst: {
            args: Prisma.ProductDocAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductDocAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>
          }
          findMany: {
            args: Prisma.ProductDocAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>[]
          }
          create: {
            args: Prisma.ProductDocAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>
          }
          createMany: {
            args: Prisma.ProductDocAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductDocAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>[]
          }
          delete: {
            args: Prisma.ProductDocAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>
          }
          update: {
            args: Prisma.ProductDocAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>
          }
          deleteMany: {
            args: Prisma.ProductDocAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductDocAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductDocAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDocAssetPayload>
          }
          aggregate: {
            args: Prisma.ProductDocAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductDocAsset>
          }
          groupBy: {
            args: Prisma.ProductDocAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductDocAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductDocAssetCountArgs<ExtArgs>
            result: $Utils.Optional<ProductDocAssetCountAggregateOutputType> | number
          }
        }
      }
      Case: {
        payload: Prisma.$CasePayload<ExtArgs>
        fields: Prisma.CaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          findFirst: {
            args: Prisma.CaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          findMany: {
            args: Prisma.CaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          create: {
            args: Prisma.CaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          createMany: {
            args: Prisma.CaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          delete: {
            args: Prisma.CaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          update: {
            args: Prisma.CaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          deleteMany: {
            args: Prisma.CaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          aggregate: {
            args: Prisma.CaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCase>
          }
          groupBy: {
            args: Prisma.CaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseCountArgs<ExtArgs>
            result: $Utils.Optional<CaseCountAggregateOutputType> | number
          }
        }
      }
      CaseAttachment: {
        payload: Prisma.$CaseAttachmentPayload<ExtArgs>
        fields: Prisma.CaseAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>
          }
          findFirst: {
            args: Prisma.CaseAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>
          }
          findMany: {
            args: Prisma.CaseAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>[]
          }
          create: {
            args: Prisma.CaseAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>
          }
          createMany: {
            args: Prisma.CaseAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>[]
          }
          delete: {
            args: Prisma.CaseAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>
          }
          update: {
            args: Prisma.CaseAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.CaseAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CaseAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseAttachmentPayload>
          }
          aggregate: {
            args: Prisma.CaseAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseAttachment>
          }
          groupBy: {
            args: Prisma.CaseAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<CaseAttachmentCountAggregateOutputType> | number
          }
        }
      }
      CaseMessage: {
        payload: Prisma.$CaseMessagePayload<ExtArgs>
        fields: Prisma.CaseMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>
          }
          findFirst: {
            args: Prisma.CaseMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>
          }
          findMany: {
            args: Prisma.CaseMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>[]
          }
          create: {
            args: Prisma.CaseMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>
          }
          createMany: {
            args: Prisma.CaseMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>[]
          }
          delete: {
            args: Prisma.CaseMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>
          }
          update: {
            args: Prisma.CaseMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>
          }
          deleteMany: {
            args: Prisma.CaseMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CaseMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseMessagePayload>
          }
          aggregate: {
            args: Prisma.CaseMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseMessage>
          }
          groupBy: {
            args: Prisma.CaseMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CaseMessageCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      SpecPackage: {
        payload: Prisma.$SpecPackagePayload<ExtArgs>
        fields: Prisma.SpecPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>
          }
          findFirst: {
            args: Prisma.SpecPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>
          }
          findMany: {
            args: Prisma.SpecPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>[]
          }
          create: {
            args: Prisma.SpecPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>
          }
          createMany: {
            args: Prisma.SpecPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>[]
          }
          delete: {
            args: Prisma.SpecPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>
          }
          update: {
            args: Prisma.SpecPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>
          }
          deleteMany: {
            args: Prisma.SpecPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpecPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecPackagePayload>
          }
          aggregate: {
            args: Prisma.SpecPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecPackage>
          }
          groupBy: {
            args: Prisma.SpecPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecPackageCountArgs<ExtArgs>
            result: $Utils.Optional<SpecPackageCountAggregateOutputType> | number
          }
        }
      }
      TaxExemptDocument: {
        payload: Prisma.$TaxExemptDocumentPayload<ExtArgs>
        fields: Prisma.TaxExemptDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxExemptDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxExemptDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>
          }
          findFirst: {
            args: Prisma.TaxExemptDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxExemptDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>
          }
          findMany: {
            args: Prisma.TaxExemptDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>[]
          }
          create: {
            args: Prisma.TaxExemptDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>
          }
          createMany: {
            args: Prisma.TaxExemptDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxExemptDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>[]
          }
          delete: {
            args: Prisma.TaxExemptDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>
          }
          update: {
            args: Prisma.TaxExemptDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>
          }
          deleteMany: {
            args: Prisma.TaxExemptDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxExemptDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaxExemptDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxExemptDocumentPayload>
          }
          aggregate: {
            args: Prisma.TaxExemptDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxExemptDocument>
          }
          groupBy: {
            args: Prisma.TaxExemptDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxExemptDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxExemptDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<TaxExemptDocumentCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      PartnerAttribution: {
        payload: Prisma.$PartnerAttributionPayload<ExtArgs>
        fields: Prisma.PartnerAttributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerAttributionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerAttributionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>
          }
          findFirst: {
            args: Prisma.PartnerAttributionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerAttributionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>
          }
          findMany: {
            args: Prisma.PartnerAttributionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>[]
          }
          create: {
            args: Prisma.PartnerAttributionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>
          }
          createMany: {
            args: Prisma.PartnerAttributionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerAttributionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>[]
          }
          delete: {
            args: Prisma.PartnerAttributionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>
          }
          update: {
            args: Prisma.PartnerAttributionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>
          }
          deleteMany: {
            args: Prisma.PartnerAttributionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerAttributionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerAttributionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerAttributionPayload>
          }
          aggregate: {
            args: Prisma.PartnerAttributionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerAttribution>
          }
          groupBy: {
            args: Prisma.PartnerAttributionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerAttributionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerAttributionCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerAttributionCountAggregateOutputType> | number
          }
        }
      }
      QboSyncLog: {
        payload: Prisma.$QboSyncLogPayload<ExtArgs>
        fields: Prisma.QboSyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QboSyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QboSyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>
          }
          findFirst: {
            args: Prisma.QboSyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QboSyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>
          }
          findMany: {
            args: Prisma.QboSyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>[]
          }
          create: {
            args: Prisma.QboSyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>
          }
          createMany: {
            args: Prisma.QboSyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QboSyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>[]
          }
          delete: {
            args: Prisma.QboSyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>
          }
          update: {
            args: Prisma.QboSyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>
          }
          deleteMany: {
            args: Prisma.QboSyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QboSyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QboSyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QboSyncLogPayload>
          }
          aggregate: {
            args: Prisma.QboSyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQboSyncLog>
          }
          groupBy: {
            args: Prisma.QboSyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<QboSyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.QboSyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<QboSyncLogCountAggregateOutputType> | number
          }
        }
      }
      ShippingSyncLog: {
        payload: Prisma.$ShippingSyncLogPayload<ExtArgs>
        fields: Prisma.ShippingSyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingSyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingSyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>
          }
          findFirst: {
            args: Prisma.ShippingSyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingSyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>
          }
          findMany: {
            args: Prisma.ShippingSyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>[]
          }
          create: {
            args: Prisma.ShippingSyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>
          }
          createMany: {
            args: Prisma.ShippingSyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingSyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>[]
          }
          delete: {
            args: Prisma.ShippingSyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>
          }
          update: {
            args: Prisma.ShippingSyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>
          }
          deleteMany: {
            args: Prisma.ShippingSyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingSyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShippingSyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingSyncLogPayload>
          }
          aggregate: {
            args: Prisma.ShippingSyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShippingSyncLog>
          }
          groupBy: {
            args: Prisma.ShippingSyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShippingSyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingSyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<ShippingSyncLogCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBaseEntry: {
        payload: Prisma.$KnowledgeBaseEntryPayload<ExtArgs>
        fields: Prisma.KnowledgeBaseEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeBaseEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeBaseEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          update: {
            args: Prisma.KnowledgeBaseEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeBaseEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBaseEntry>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseEntryCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseEntryCountAggregateOutputType> | number
          }
        }
      }
      AIChatLog: {
        payload: Prisma.$AIChatLogPayload<ExtArgs>
        fields: Prisma.AIChatLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIChatLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIChatLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>
          }
          findFirst: {
            args: Prisma.AIChatLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIChatLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>
          }
          findMany: {
            args: Prisma.AIChatLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>[]
          }
          create: {
            args: Prisma.AIChatLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>
          }
          createMany: {
            args: Prisma.AIChatLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIChatLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>[]
          }
          delete: {
            args: Prisma.AIChatLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>
          }
          update: {
            args: Prisma.AIChatLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>
          }
          deleteMany: {
            args: Prisma.AIChatLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIChatLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIChatLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatLogPayload>
          }
          aggregate: {
            args: Prisma.AIChatLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIChatLog>
          }
          groupBy: {
            args: Prisma.AIChatLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIChatLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIChatLogCountArgs<ExtArgs>
            result: $Utils.Optional<AIChatLogCountAggregateOutputType> | number
          }
        }
      }
      CaseStudy: {
        payload: Prisma.$CaseStudyPayload<ExtArgs>
        fields: Prisma.CaseStudyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseStudyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseStudyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          findFirst: {
            args: Prisma.CaseStudyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseStudyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          findMany: {
            args: Prisma.CaseStudyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>[]
          }
          create: {
            args: Prisma.CaseStudyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          createMany: {
            args: Prisma.CaseStudyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseStudyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>[]
          }
          delete: {
            args: Prisma.CaseStudyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          update: {
            args: Prisma.CaseStudyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          deleteMany: {
            args: Prisma.CaseStudyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseStudyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CaseStudyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          aggregate: {
            args: Prisma.CaseStudyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseStudy>
          }
          groupBy: {
            args: Prisma.CaseStudyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseStudyCountArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      AIClientProfile: {
        payload: Prisma.$AIClientProfilePayload<ExtArgs>
        fields: Prisma.AIClientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIClientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIClientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>
          }
          findFirst: {
            args: Prisma.AIClientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIClientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>
          }
          findMany: {
            args: Prisma.AIClientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>[]
          }
          create: {
            args: Prisma.AIClientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>
          }
          createMany: {
            args: Prisma.AIClientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIClientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>[]
          }
          delete: {
            args: Prisma.AIClientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>
          }
          update: {
            args: Prisma.AIClientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>
          }
          deleteMany: {
            args: Prisma.AIClientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIClientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIClientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIClientProfilePayload>
          }
          aggregate: {
            args: Prisma.AIClientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIClientProfile>
          }
          groupBy: {
            args: Prisma.AIClientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIClientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIClientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AIClientProfileCountAggregateOutputType> | number
          }
        }
      }
      AIConversation: {
        payload: Prisma.$AIConversationPayload<ExtArgs>
        fields: Prisma.AIConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findFirst: {
            args: Prisma.AIConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findMany: {
            args: Prisma.AIConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          create: {
            args: Prisma.AIConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          createMany: {
            args: Prisma.AIConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          delete: {
            args: Prisma.AIConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          update: {
            args: Prisma.AIConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          deleteMany: {
            args: Prisma.AIConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          aggregate: {
            args: Prisma.AIConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIConversation>
          }
          groupBy: {
            args: Prisma.AIConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIConversationCountArgs<ExtArgs>
            result: $Utils.Optional<AIConversationCountAggregateOutputType> | number
          }
        }
      }
      AILeadData: {
        payload: Prisma.$AILeadDataPayload<ExtArgs>
        fields: Prisma.AILeadDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AILeadDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AILeadDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>
          }
          findFirst: {
            args: Prisma.AILeadDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AILeadDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>
          }
          findMany: {
            args: Prisma.AILeadDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>[]
          }
          create: {
            args: Prisma.AILeadDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>
          }
          createMany: {
            args: Prisma.AILeadDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AILeadDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>[]
          }
          delete: {
            args: Prisma.AILeadDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>
          }
          update: {
            args: Prisma.AILeadDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>
          }
          deleteMany: {
            args: Prisma.AILeadDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AILeadDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AILeadDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILeadDataPayload>
          }
          aggregate: {
            args: Prisma.AILeadDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAILeadData>
          }
          groupBy: {
            args: Prisma.AILeadDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AILeadDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.AILeadDataCountArgs<ExtArgs>
            result: $Utils.Optional<AILeadDataCountAggregateOutputType> | number
          }
        }
      }
      AICompanyIntelligence: {
        payload: Prisma.$AICompanyIntelligencePayload<ExtArgs>
        fields: Prisma.AICompanyIntelligenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AICompanyIntelligenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AICompanyIntelligenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>
          }
          findFirst: {
            args: Prisma.AICompanyIntelligenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AICompanyIntelligenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>
          }
          findMany: {
            args: Prisma.AICompanyIntelligenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>[]
          }
          create: {
            args: Prisma.AICompanyIntelligenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>
          }
          createMany: {
            args: Prisma.AICompanyIntelligenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AICompanyIntelligenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>[]
          }
          delete: {
            args: Prisma.AICompanyIntelligenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>
          }
          update: {
            args: Prisma.AICompanyIntelligenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>
          }
          deleteMany: {
            args: Prisma.AICompanyIntelligenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AICompanyIntelligenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AICompanyIntelligenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICompanyIntelligencePayload>
          }
          aggregate: {
            args: Prisma.AICompanyIntelligenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAICompanyIntelligence>
          }
          groupBy: {
            args: Prisma.AICompanyIntelligenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AICompanyIntelligenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AICompanyIntelligenceCountArgs<ExtArgs>
            result: $Utils.Optional<AICompanyIntelligenceCountAggregateOutputType> | number
          }
        }
      }
      AIStrategyPerformance: {
        payload: Prisma.$AIStrategyPerformancePayload<ExtArgs>
        fields: Prisma.AIStrategyPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIStrategyPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIStrategyPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>
          }
          findFirst: {
            args: Prisma.AIStrategyPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIStrategyPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>
          }
          findMany: {
            args: Prisma.AIStrategyPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>[]
          }
          create: {
            args: Prisma.AIStrategyPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>
          }
          createMany: {
            args: Prisma.AIStrategyPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIStrategyPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>[]
          }
          delete: {
            args: Prisma.AIStrategyPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>
          }
          update: {
            args: Prisma.AIStrategyPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>
          }
          deleteMany: {
            args: Prisma.AIStrategyPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIStrategyPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIStrategyPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIStrategyPerformancePayload>
          }
          aggregate: {
            args: Prisma.AIStrategyPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIStrategyPerformance>
          }
          groupBy: {
            args: Prisma.AIStrategyPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIStrategyPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIStrategyPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<AIStrategyPerformanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    productDocAsset?: ProductDocAssetOmit
    case?: CaseOmit
    caseAttachment?: CaseAttachmentOmit
    caseMessage?: CaseMessageOmit
    quote?: QuoteOmit
    project?: ProjectOmit
    specPackage?: SpecPackageOmit
    taxExemptDocument?: TaxExemptDocumentOmit
    partner?: PartnerOmit
    partnerAttribution?: PartnerAttributionOmit
    qboSyncLog?: QboSyncLogOmit
    shippingSyncLog?: ShippingSyncLogOmit
    knowledgeBaseEntry?: KnowledgeBaseEntryOmit
    aIChatLog?: AIChatLogOmit
    caseStudy?: CaseStudyOmit
    analyticsEvent?: AnalyticsEventOmit
    aIClientProfile?: AIClientProfileOmit
    aIConversation?: AIConversationOmit
    aILeadData?: AILeadDataOmit
    aICompanyIntelligence?: AICompanyIntelligenceOmit
    aIStrategyPerformance?: AIStrategyPerformanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    cases: number
    quotes: number
    projects: number
    taxExemptDocuments: number
    assignedCases: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cases?: boolean | UserCountOutputTypeCountCasesArgs
    quotes?: boolean | UserCountOutputTypeCountQuotesArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    taxExemptDocuments?: boolean | UserCountOutputTypeCountTaxExemptDocumentsArgs
    assignedCases?: boolean | UserCountOutputTypeCountAssignedCasesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaxExemptDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxExemptDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseWhereInput
  }


  /**
   * Count Type CaseCountOutputType
   */

  export type CaseCountOutputType = {
    attachments: number
    messages: number
    quotes: number
  }

  export type CaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | CaseCountOutputTypeCountAttachmentsArgs
    messages?: boolean | CaseCountOutputTypeCountMessagesArgs
    quotes?: boolean | CaseCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseCountOutputType
     */
    select?: CaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseAttachmentWhereInput
  }

  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseMessageWhereInput
  }

  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    quotes: number
    specPackages: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotes?: boolean | ProjectCountOutputTypeCountQuotesArgs
    specPackages?: boolean | ProjectCountOutputTypeCountSpecPackagesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSpecPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecPackageWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    attributions: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributions?: boolean | PartnerCountOutputTypeCountAttributionsArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountAttributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerAttributionWhereInput
  }


  /**
   * Count Type AIClientProfileCountOutputType
   */

  export type AIClientProfileCountOutputType = {
    conversations: number
  }

  export type AIClientProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | AIClientProfileCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * AIClientProfileCountOutputType without action
   */
  export type AIClientProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfileCountOutputType
     */
    select?: AIClientProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIClientProfileCountOutputType without action
   */
  export type AIClientProfileCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    companyName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    bcCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    companyName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    bcCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    companyName: number
    phone: number
    role: number
    bcCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    companyName?: true
    phone?: true
    role?: true
    bcCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    companyName?: true
    phone?: true
    role?: true
    bcCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    companyName?: true
    phone?: true
    role?: true
    bcCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    name: string | null
    companyName: string | null
    phone: string | null
    role: $Enums.UserRole
    bcCustomerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    companyName?: boolean
    phone?: boolean
    role?: boolean
    bcCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cases?: boolean | User$casesArgs<ExtArgs>
    quotes?: boolean | User$quotesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    taxExemptDocuments?: boolean | User$taxExemptDocumentsArgs<ExtArgs>
    assignedCases?: boolean | User$assignedCasesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    companyName?: boolean
    phone?: boolean
    role?: boolean
    bcCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    companyName?: boolean
    phone?: boolean
    role?: boolean
    bcCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "name" | "companyName" | "phone" | "role" | "bcCustomerId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cases?: boolean | User$casesArgs<ExtArgs>
    quotes?: boolean | User$quotesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    taxExemptDocuments?: boolean | User$taxExemptDocumentsArgs<ExtArgs>
    assignedCases?: boolean | User$assignedCasesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      cases: Prisma.$CasePayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      taxExemptDocuments: Prisma.$TaxExemptDocumentPayload<ExtArgs>[]
      assignedCases: Prisma.$CasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      name: string | null
      companyName: string | null
      phone: string | null
      role: $Enums.UserRole
      bcCustomerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cases<T extends User$casesArgs<ExtArgs> = {}>(args?: Subset<T, User$casesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends User$quotesArgs<ExtArgs> = {}>(args?: Subset<T, User$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxExemptDocuments<T extends User$taxExemptDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taxExemptDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedCases<T extends User$assignedCasesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly companyName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly bcCustomerId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.cases
   */
  export type User$casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    where?: CaseWhereInput
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    cursor?: CaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * User.quotes
   */
  export type User$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.taxExemptDocuments
   */
  export type User$taxExemptDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    where?: TaxExemptDocumentWhereInput
    orderBy?: TaxExemptDocumentOrderByWithRelationInput | TaxExemptDocumentOrderByWithRelationInput[]
    cursor?: TaxExemptDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxExemptDocumentScalarFieldEnum | TaxExemptDocumentScalarFieldEnum[]
  }

  /**
   * User.assignedCases
   */
  export type User$assignedCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    where?: CaseWhereInput
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    cursor?: CaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ProductDocAsset
   */

  export type AggregateProductDocAsset = {
    _count: ProductDocAssetCountAggregateOutputType | null
    _avg: ProductDocAssetAvgAggregateOutputType | null
    _sum: ProductDocAssetSumAggregateOutputType | null
    _min: ProductDocAssetMinAggregateOutputType | null
    _max: ProductDocAssetMaxAggregateOutputType | null
  }

  export type ProductDocAssetAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ProductDocAssetSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ProductDocAssetMinAggregateOutputType = {
    id: string | null
    bcProductId: string | null
    sku: string | null
    docType: $Enums.DocType | null
    title: string | null
    url: string | null
    version: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductDocAssetMaxAggregateOutputType = {
    id: string | null
    bcProductId: string | null
    sku: string | null
    docType: $Enums.DocType | null
    title: string | null
    url: string | null
    version: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductDocAssetCountAggregateOutputType = {
    id: number
    bcProductId: number
    sku: number
    docType: number
    title: number
    url: number
    version: number
    fileSize: number
    mimeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductDocAssetAvgAggregateInputType = {
    fileSize?: true
  }

  export type ProductDocAssetSumAggregateInputType = {
    fileSize?: true
  }

  export type ProductDocAssetMinAggregateInputType = {
    id?: true
    bcProductId?: true
    sku?: true
    docType?: true
    title?: true
    url?: true
    version?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductDocAssetMaxAggregateInputType = {
    id?: true
    bcProductId?: true
    sku?: true
    docType?: true
    title?: true
    url?: true
    version?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductDocAssetCountAggregateInputType = {
    id?: true
    bcProductId?: true
    sku?: true
    docType?: true
    title?: true
    url?: true
    version?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductDocAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDocAsset to aggregate.
     */
    where?: ProductDocAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDocAssets to fetch.
     */
    orderBy?: ProductDocAssetOrderByWithRelationInput | ProductDocAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductDocAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDocAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDocAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductDocAssets
    **/
    _count?: true | ProductDocAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductDocAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductDocAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductDocAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductDocAssetMaxAggregateInputType
  }

  export type GetProductDocAssetAggregateType<T extends ProductDocAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateProductDocAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductDocAsset[P]>
      : GetScalarType<T[P], AggregateProductDocAsset[P]>
  }




  export type ProductDocAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDocAssetWhereInput
    orderBy?: ProductDocAssetOrderByWithAggregationInput | ProductDocAssetOrderByWithAggregationInput[]
    by: ProductDocAssetScalarFieldEnum[] | ProductDocAssetScalarFieldEnum
    having?: ProductDocAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductDocAssetCountAggregateInputType | true
    _avg?: ProductDocAssetAvgAggregateInputType
    _sum?: ProductDocAssetSumAggregateInputType
    _min?: ProductDocAssetMinAggregateInputType
    _max?: ProductDocAssetMaxAggregateInputType
  }

  export type ProductDocAssetGroupByOutputType = {
    id: string
    bcProductId: string
    sku: string
    docType: $Enums.DocType
    title: string
    url: string
    version: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductDocAssetCountAggregateOutputType | null
    _avg: ProductDocAssetAvgAggregateOutputType | null
    _sum: ProductDocAssetSumAggregateOutputType | null
    _min: ProductDocAssetMinAggregateOutputType | null
    _max: ProductDocAssetMaxAggregateOutputType | null
  }

  type GetProductDocAssetGroupByPayload<T extends ProductDocAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductDocAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductDocAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductDocAssetGroupByOutputType[P]>
            : GetScalarType<T[P], ProductDocAssetGroupByOutputType[P]>
        }
      >
    >


  export type ProductDocAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bcProductId?: boolean
    sku?: boolean
    docType?: boolean
    title?: boolean
    url?: boolean
    version?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productDocAsset"]>

  export type ProductDocAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bcProductId?: boolean
    sku?: boolean
    docType?: boolean
    title?: boolean
    url?: boolean
    version?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productDocAsset"]>


  export type ProductDocAssetSelectScalar = {
    id?: boolean
    bcProductId?: boolean
    sku?: boolean
    docType?: boolean
    title?: boolean
    url?: boolean
    version?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductDocAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bcProductId" | "sku" | "docType" | "title" | "url" | "version" | "fileSize" | "mimeType" | "createdAt" | "updatedAt", ExtArgs["result"]["productDocAsset"]>

  export type $ProductDocAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductDocAsset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bcProductId: string
      sku: string
      docType: $Enums.DocType
      title: string
      url: string
      version: string | null
      fileSize: number | null
      mimeType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productDocAsset"]>
    composites: {}
  }

  type ProductDocAssetGetPayload<S extends boolean | null | undefined | ProductDocAssetDefaultArgs> = $Result.GetResult<Prisma.$ProductDocAssetPayload, S>

  type ProductDocAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductDocAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductDocAssetCountAggregateInputType | true
    }

  export interface ProductDocAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductDocAsset'], meta: { name: 'ProductDocAsset' } }
    /**
     * Find zero or one ProductDocAsset that matches the filter.
     * @param {ProductDocAssetFindUniqueArgs} args - Arguments to find a ProductDocAsset
     * @example
     * // Get one ProductDocAsset
     * const productDocAsset = await prisma.productDocAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductDocAssetFindUniqueArgs>(args: SelectSubset<T, ProductDocAssetFindUniqueArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductDocAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductDocAssetFindUniqueOrThrowArgs} args - Arguments to find a ProductDocAsset
     * @example
     * // Get one ProductDocAsset
     * const productDocAsset = await prisma.productDocAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductDocAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductDocAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductDocAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDocAssetFindFirstArgs} args - Arguments to find a ProductDocAsset
     * @example
     * // Get one ProductDocAsset
     * const productDocAsset = await prisma.productDocAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductDocAssetFindFirstArgs>(args?: SelectSubset<T, ProductDocAssetFindFirstArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductDocAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDocAssetFindFirstOrThrowArgs} args - Arguments to find a ProductDocAsset
     * @example
     * // Get one ProductDocAsset
     * const productDocAsset = await prisma.productDocAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductDocAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductDocAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductDocAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDocAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductDocAssets
     * const productDocAssets = await prisma.productDocAsset.findMany()
     * 
     * // Get first 10 ProductDocAssets
     * const productDocAssets = await prisma.productDocAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productDocAssetWithIdOnly = await prisma.productDocAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductDocAssetFindManyArgs>(args?: SelectSubset<T, ProductDocAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductDocAsset.
     * @param {ProductDocAssetCreateArgs} args - Arguments to create a ProductDocAsset.
     * @example
     * // Create one ProductDocAsset
     * const ProductDocAsset = await prisma.productDocAsset.create({
     *   data: {
     *     // ... data to create a ProductDocAsset
     *   }
     * })
     * 
     */
    create<T extends ProductDocAssetCreateArgs>(args: SelectSubset<T, ProductDocAssetCreateArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductDocAssets.
     * @param {ProductDocAssetCreateManyArgs} args - Arguments to create many ProductDocAssets.
     * @example
     * // Create many ProductDocAssets
     * const productDocAsset = await prisma.productDocAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductDocAssetCreateManyArgs>(args?: SelectSubset<T, ProductDocAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductDocAssets and returns the data saved in the database.
     * @param {ProductDocAssetCreateManyAndReturnArgs} args - Arguments to create many ProductDocAssets.
     * @example
     * // Create many ProductDocAssets
     * const productDocAsset = await prisma.productDocAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductDocAssets and only return the `id`
     * const productDocAssetWithIdOnly = await prisma.productDocAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductDocAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductDocAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductDocAsset.
     * @param {ProductDocAssetDeleteArgs} args - Arguments to delete one ProductDocAsset.
     * @example
     * // Delete one ProductDocAsset
     * const ProductDocAsset = await prisma.productDocAsset.delete({
     *   where: {
     *     // ... filter to delete one ProductDocAsset
     *   }
     * })
     * 
     */
    delete<T extends ProductDocAssetDeleteArgs>(args: SelectSubset<T, ProductDocAssetDeleteArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductDocAsset.
     * @param {ProductDocAssetUpdateArgs} args - Arguments to update one ProductDocAsset.
     * @example
     * // Update one ProductDocAsset
     * const productDocAsset = await prisma.productDocAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductDocAssetUpdateArgs>(args: SelectSubset<T, ProductDocAssetUpdateArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductDocAssets.
     * @param {ProductDocAssetDeleteManyArgs} args - Arguments to filter ProductDocAssets to delete.
     * @example
     * // Delete a few ProductDocAssets
     * const { count } = await prisma.productDocAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDocAssetDeleteManyArgs>(args?: SelectSubset<T, ProductDocAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductDocAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDocAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductDocAssets
     * const productDocAsset = await prisma.productDocAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductDocAssetUpdateManyArgs>(args: SelectSubset<T, ProductDocAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductDocAsset.
     * @param {ProductDocAssetUpsertArgs} args - Arguments to update or create a ProductDocAsset.
     * @example
     * // Update or create a ProductDocAsset
     * const productDocAsset = await prisma.productDocAsset.upsert({
     *   create: {
     *     // ... data to create a ProductDocAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductDocAsset we want to update
     *   }
     * })
     */
    upsert<T extends ProductDocAssetUpsertArgs>(args: SelectSubset<T, ProductDocAssetUpsertArgs<ExtArgs>>): Prisma__ProductDocAssetClient<$Result.GetResult<Prisma.$ProductDocAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductDocAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDocAssetCountArgs} args - Arguments to filter ProductDocAssets to count.
     * @example
     * // Count the number of ProductDocAssets
     * const count = await prisma.productDocAsset.count({
     *   where: {
     *     // ... the filter for the ProductDocAssets we want to count
     *   }
     * })
    **/
    count<T extends ProductDocAssetCountArgs>(
      args?: Subset<T, ProductDocAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductDocAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductDocAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDocAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductDocAssetAggregateArgs>(args: Subset<T, ProductDocAssetAggregateArgs>): Prisma.PrismaPromise<GetProductDocAssetAggregateType<T>>

    /**
     * Group by ProductDocAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDocAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductDocAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductDocAssetGroupByArgs['orderBy'] }
        : { orderBy?: ProductDocAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductDocAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductDocAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductDocAsset model
   */
  readonly fields: ProductDocAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductDocAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductDocAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductDocAsset model
   */
  interface ProductDocAssetFieldRefs {
    readonly id: FieldRef<"ProductDocAsset", 'String'>
    readonly bcProductId: FieldRef<"ProductDocAsset", 'String'>
    readonly sku: FieldRef<"ProductDocAsset", 'String'>
    readonly docType: FieldRef<"ProductDocAsset", 'DocType'>
    readonly title: FieldRef<"ProductDocAsset", 'String'>
    readonly url: FieldRef<"ProductDocAsset", 'String'>
    readonly version: FieldRef<"ProductDocAsset", 'String'>
    readonly fileSize: FieldRef<"ProductDocAsset", 'Int'>
    readonly mimeType: FieldRef<"ProductDocAsset", 'String'>
    readonly createdAt: FieldRef<"ProductDocAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductDocAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductDocAsset findUnique
   */
  export type ProductDocAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * Filter, which ProductDocAsset to fetch.
     */
    where: ProductDocAssetWhereUniqueInput
  }

  /**
   * ProductDocAsset findUniqueOrThrow
   */
  export type ProductDocAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * Filter, which ProductDocAsset to fetch.
     */
    where: ProductDocAssetWhereUniqueInput
  }

  /**
   * ProductDocAsset findFirst
   */
  export type ProductDocAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * Filter, which ProductDocAsset to fetch.
     */
    where?: ProductDocAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDocAssets to fetch.
     */
    orderBy?: ProductDocAssetOrderByWithRelationInput | ProductDocAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDocAssets.
     */
    cursor?: ProductDocAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDocAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDocAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDocAssets.
     */
    distinct?: ProductDocAssetScalarFieldEnum | ProductDocAssetScalarFieldEnum[]
  }

  /**
   * ProductDocAsset findFirstOrThrow
   */
  export type ProductDocAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * Filter, which ProductDocAsset to fetch.
     */
    where?: ProductDocAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDocAssets to fetch.
     */
    orderBy?: ProductDocAssetOrderByWithRelationInput | ProductDocAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDocAssets.
     */
    cursor?: ProductDocAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDocAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDocAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDocAssets.
     */
    distinct?: ProductDocAssetScalarFieldEnum | ProductDocAssetScalarFieldEnum[]
  }

  /**
   * ProductDocAsset findMany
   */
  export type ProductDocAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * Filter, which ProductDocAssets to fetch.
     */
    where?: ProductDocAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDocAssets to fetch.
     */
    orderBy?: ProductDocAssetOrderByWithRelationInput | ProductDocAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductDocAssets.
     */
    cursor?: ProductDocAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDocAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDocAssets.
     */
    skip?: number
    distinct?: ProductDocAssetScalarFieldEnum | ProductDocAssetScalarFieldEnum[]
  }

  /**
   * ProductDocAsset create
   */
  export type ProductDocAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * The data needed to create a ProductDocAsset.
     */
    data: XOR<ProductDocAssetCreateInput, ProductDocAssetUncheckedCreateInput>
  }

  /**
   * ProductDocAsset createMany
   */
  export type ProductDocAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductDocAssets.
     */
    data: ProductDocAssetCreateManyInput | ProductDocAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductDocAsset createManyAndReturn
   */
  export type ProductDocAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * The data used to create many ProductDocAssets.
     */
    data: ProductDocAssetCreateManyInput | ProductDocAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductDocAsset update
   */
  export type ProductDocAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * The data needed to update a ProductDocAsset.
     */
    data: XOR<ProductDocAssetUpdateInput, ProductDocAssetUncheckedUpdateInput>
    /**
     * Choose, which ProductDocAsset to update.
     */
    where: ProductDocAssetWhereUniqueInput
  }

  /**
   * ProductDocAsset updateMany
   */
  export type ProductDocAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductDocAssets.
     */
    data: XOR<ProductDocAssetUpdateManyMutationInput, ProductDocAssetUncheckedUpdateManyInput>
    /**
     * Filter which ProductDocAssets to update
     */
    where?: ProductDocAssetWhereInput
  }

  /**
   * ProductDocAsset upsert
   */
  export type ProductDocAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * The filter to search for the ProductDocAsset to update in case it exists.
     */
    where: ProductDocAssetWhereUniqueInput
    /**
     * In case the ProductDocAsset found by the `where` argument doesn't exist, create a new ProductDocAsset with this data.
     */
    create: XOR<ProductDocAssetCreateInput, ProductDocAssetUncheckedCreateInput>
    /**
     * In case the ProductDocAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductDocAssetUpdateInput, ProductDocAssetUncheckedUpdateInput>
  }

  /**
   * ProductDocAsset delete
   */
  export type ProductDocAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
    /**
     * Filter which ProductDocAsset to delete.
     */
    where: ProductDocAssetWhereUniqueInput
  }

  /**
   * ProductDocAsset deleteMany
   */
  export type ProductDocAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDocAssets to delete
     */
    where?: ProductDocAssetWhereInput
  }

  /**
   * ProductDocAsset without action
   */
  export type ProductDocAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDocAsset
     */
    select?: ProductDocAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDocAsset
     */
    omit?: ProductDocAssetOmit<ExtArgs> | null
  }


  /**
   * Model Case
   */

  export type AggregateCase = {
    _count: CaseCountAggregateOutputType | null
    _min: CaseMinAggregateOutputType | null
    _max: CaseMaxAggregateOutputType | null
  }

  export type CaseMinAggregateOutputType = {
    id: string | null
    caseNumber: string | null
    type: $Enums.CaseType | null
    status: $Enums.CaseStatus | null
    priority: $Enums.CasePriority | null
    slaDueAt: Date | null
    slaBreached: boolean | null
    customerId: string | null
    contactEmail: string | null
    companyName: string | null
    subject: string | null
    customerMessage: string | null
    internalNotes: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type CaseMaxAggregateOutputType = {
    id: string | null
    caseNumber: string | null
    type: $Enums.CaseType | null
    status: $Enums.CaseStatus | null
    priority: $Enums.CasePriority | null
    slaDueAt: Date | null
    slaBreached: boolean | null
    customerId: string | null
    contactEmail: string | null
    companyName: string | null
    subject: string | null
    customerMessage: string | null
    internalNotes: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type CaseCountAggregateOutputType = {
    id: number
    caseNumber: number
    type: number
    status: number
    priority: number
    slaDueAt: number
    slaBreached: number
    customerId: number
    contactEmail: number
    companyName: number
    subject: number
    customerMessage: number
    internalNotes: number
    relatedSkus: number
    relatedOrderIds: number
    assignedToId: number
    createdAt: number
    updatedAt: number
    closedAt: number
    _all: number
  }


  export type CaseMinAggregateInputType = {
    id?: true
    caseNumber?: true
    type?: true
    status?: true
    priority?: true
    slaDueAt?: true
    slaBreached?: true
    customerId?: true
    contactEmail?: true
    companyName?: true
    subject?: true
    customerMessage?: true
    internalNotes?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type CaseMaxAggregateInputType = {
    id?: true
    caseNumber?: true
    type?: true
    status?: true
    priority?: true
    slaDueAt?: true
    slaBreached?: true
    customerId?: true
    contactEmail?: true
    companyName?: true
    subject?: true
    customerMessage?: true
    internalNotes?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type CaseCountAggregateInputType = {
    id?: true
    caseNumber?: true
    type?: true
    status?: true
    priority?: true
    slaDueAt?: true
    slaBreached?: true
    customerId?: true
    contactEmail?: true
    companyName?: true
    subject?: true
    customerMessage?: true
    internalNotes?: true
    relatedSkus?: true
    relatedOrderIds?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    _all?: true
  }

  export type CaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Case to aggregate.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cases
    **/
    _count?: true | CaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseMaxAggregateInputType
  }

  export type GetCaseAggregateType<T extends CaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCase[P]>
      : GetScalarType<T[P], AggregateCase[P]>
  }




  export type CaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseWhereInput
    orderBy?: CaseOrderByWithAggregationInput | CaseOrderByWithAggregationInput[]
    by: CaseScalarFieldEnum[] | CaseScalarFieldEnum
    having?: CaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseCountAggregateInputType | true
    _min?: CaseMinAggregateInputType
    _max?: CaseMaxAggregateInputType
  }

  export type CaseGroupByOutputType = {
    id: string
    caseNumber: string
    type: $Enums.CaseType
    status: $Enums.CaseStatus
    priority: $Enums.CasePriority
    slaDueAt: Date
    slaBreached: boolean
    customerId: string
    contactEmail: string
    companyName: string | null
    subject: string
    customerMessage: string
    internalNotes: string | null
    relatedSkus: string[]
    relatedOrderIds: string[]
    assignedToId: string | null
    createdAt: Date
    updatedAt: Date
    closedAt: Date | null
    _count: CaseCountAggregateOutputType | null
    _min: CaseMinAggregateOutputType | null
    _max: CaseMaxAggregateOutputType | null
  }

  type GetCaseGroupByPayload<T extends CaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseGroupByOutputType[P]>
            : GetScalarType<T[P], CaseGroupByOutputType[P]>
        }
      >
    >


  export type CaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseNumber?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    slaDueAt?: boolean
    slaBreached?: boolean
    customerId?: boolean
    contactEmail?: boolean
    companyName?: boolean
    subject?: boolean
    customerMessage?: boolean
    internalNotes?: boolean
    relatedSkus?: boolean
    relatedOrderIds?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Case$assignedToArgs<ExtArgs>
    attachments?: boolean | Case$attachmentsArgs<ExtArgs>
    messages?: boolean | Case$messagesArgs<ExtArgs>
    quotes?: boolean | Case$quotesArgs<ExtArgs>
    _count?: boolean | CaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["case"]>

  export type CaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseNumber?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    slaDueAt?: boolean
    slaBreached?: boolean
    customerId?: boolean
    contactEmail?: boolean
    companyName?: boolean
    subject?: boolean
    customerMessage?: boolean
    internalNotes?: boolean
    relatedSkus?: boolean
    relatedOrderIds?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Case$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["case"]>


  export type CaseSelectScalar = {
    id?: boolean
    caseNumber?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    slaDueAt?: boolean
    slaBreached?: boolean
    customerId?: boolean
    contactEmail?: boolean
    companyName?: boolean
    subject?: boolean
    customerMessage?: boolean
    internalNotes?: boolean
    relatedSkus?: boolean
    relatedOrderIds?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
  }

  export type CaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseNumber" | "type" | "status" | "priority" | "slaDueAt" | "slaBreached" | "customerId" | "contactEmail" | "companyName" | "subject" | "customerMessage" | "internalNotes" | "relatedSkus" | "relatedOrderIds" | "assignedToId" | "createdAt" | "updatedAt" | "closedAt", ExtArgs["result"]["case"]>
  export type CaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Case$assignedToArgs<ExtArgs>
    attachments?: boolean | Case$attachmentsArgs<ExtArgs>
    messages?: boolean | Case$messagesArgs<ExtArgs>
    quotes?: boolean | Case$quotesArgs<ExtArgs>
    _count?: boolean | CaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Case$assignedToArgs<ExtArgs>
  }

  export type $CasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Case"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      attachments: Prisma.$CaseAttachmentPayload<ExtArgs>[]
      messages: Prisma.$CaseMessagePayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseNumber: string
      type: $Enums.CaseType
      status: $Enums.CaseStatus
      priority: $Enums.CasePriority
      slaDueAt: Date
      slaBreached: boolean
      customerId: string
      contactEmail: string
      companyName: string | null
      subject: string
      customerMessage: string
      internalNotes: string | null
      relatedSkus: string[]
      relatedOrderIds: string[]
      assignedToId: string | null
      createdAt: Date
      updatedAt: Date
      closedAt: Date | null
    }, ExtArgs["result"]["case"]>
    composites: {}
  }

  type CaseGetPayload<S extends boolean | null | undefined | CaseDefaultArgs> = $Result.GetResult<Prisma.$CasePayload, S>

  type CaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseCountAggregateInputType | true
    }

  export interface CaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Case'], meta: { name: 'Case' } }
    /**
     * Find zero or one Case that matches the filter.
     * @param {CaseFindUniqueArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseFindUniqueArgs>(args: SelectSubset<T, CaseFindUniqueArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Case that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseFindUniqueOrThrowArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindFirstArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseFindFirstArgs>(args?: SelectSubset<T, CaseFindFirstArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindFirstOrThrowArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cases
     * const cases = await prisma.case.findMany()
     * 
     * // Get first 10 Cases
     * const cases = await prisma.case.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseWithIdOnly = await prisma.case.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseFindManyArgs>(args?: SelectSubset<T, CaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Case.
     * @param {CaseCreateArgs} args - Arguments to create a Case.
     * @example
     * // Create one Case
     * const Case = await prisma.case.create({
     *   data: {
     *     // ... data to create a Case
     *   }
     * })
     * 
     */
    create<T extends CaseCreateArgs>(args: SelectSubset<T, CaseCreateArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cases.
     * @param {CaseCreateManyArgs} args - Arguments to create many Cases.
     * @example
     * // Create many Cases
     * const case = await prisma.case.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseCreateManyArgs>(args?: SelectSubset<T, CaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cases and returns the data saved in the database.
     * @param {CaseCreateManyAndReturnArgs} args - Arguments to create many Cases.
     * @example
     * // Create many Cases
     * const case = await prisma.case.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cases and only return the `id`
     * const caseWithIdOnly = await prisma.case.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Case.
     * @param {CaseDeleteArgs} args - Arguments to delete one Case.
     * @example
     * // Delete one Case
     * const Case = await prisma.case.delete({
     *   where: {
     *     // ... filter to delete one Case
     *   }
     * })
     * 
     */
    delete<T extends CaseDeleteArgs>(args: SelectSubset<T, CaseDeleteArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Case.
     * @param {CaseUpdateArgs} args - Arguments to update one Case.
     * @example
     * // Update one Case
     * const case = await prisma.case.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseUpdateArgs>(args: SelectSubset<T, CaseUpdateArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cases.
     * @param {CaseDeleteManyArgs} args - Arguments to filter Cases to delete.
     * @example
     * // Delete a few Cases
     * const { count } = await prisma.case.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseDeleteManyArgs>(args?: SelectSubset<T, CaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cases
     * const case = await prisma.case.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseUpdateManyArgs>(args: SelectSubset<T, CaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Case.
     * @param {CaseUpsertArgs} args - Arguments to update or create a Case.
     * @example
     * // Update or create a Case
     * const case = await prisma.case.upsert({
     *   create: {
     *     // ... data to create a Case
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Case we want to update
     *   }
     * })
     */
    upsert<T extends CaseUpsertArgs>(args: SelectSubset<T, CaseUpsertArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseCountArgs} args - Arguments to filter Cases to count.
     * @example
     * // Count the number of Cases
     * const count = await prisma.case.count({
     *   where: {
     *     // ... the filter for the Cases we want to count
     *   }
     * })
    **/
    count<T extends CaseCountArgs>(
      args?: Subset<T, CaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseAggregateArgs>(args: Subset<T, CaseAggregateArgs>): Prisma.PrismaPromise<GetCaseAggregateType<T>>

    /**
     * Group by Case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseGroupByArgs['orderBy'] }
        : { orderBy?: CaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Case model
   */
  readonly fields: CaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Case.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Case$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Case$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Case$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Case$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Case$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Case$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Case$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Case$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Case model
   */
  interface CaseFieldRefs {
    readonly id: FieldRef<"Case", 'String'>
    readonly caseNumber: FieldRef<"Case", 'String'>
    readonly type: FieldRef<"Case", 'CaseType'>
    readonly status: FieldRef<"Case", 'CaseStatus'>
    readonly priority: FieldRef<"Case", 'CasePriority'>
    readonly slaDueAt: FieldRef<"Case", 'DateTime'>
    readonly slaBreached: FieldRef<"Case", 'Boolean'>
    readonly customerId: FieldRef<"Case", 'String'>
    readonly contactEmail: FieldRef<"Case", 'String'>
    readonly companyName: FieldRef<"Case", 'String'>
    readonly subject: FieldRef<"Case", 'String'>
    readonly customerMessage: FieldRef<"Case", 'String'>
    readonly internalNotes: FieldRef<"Case", 'String'>
    readonly relatedSkus: FieldRef<"Case", 'String[]'>
    readonly relatedOrderIds: FieldRef<"Case", 'String[]'>
    readonly assignedToId: FieldRef<"Case", 'String'>
    readonly createdAt: FieldRef<"Case", 'DateTime'>
    readonly updatedAt: FieldRef<"Case", 'DateTime'>
    readonly closedAt: FieldRef<"Case", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Case findUnique
   */
  export type CaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case findUniqueOrThrow
   */
  export type CaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case findFirst
   */
  export type CaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cases.
     */
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case findFirstOrThrow
   */
  export type CaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cases.
     */
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case findMany
   */
  export type CaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Cases to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case create
   */
  export type CaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Case.
     */
    data: XOR<CaseCreateInput, CaseUncheckedCreateInput>
  }

  /**
   * Case createMany
   */
  export type CaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cases.
     */
    data: CaseCreateManyInput | CaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Case createManyAndReturn
   */
  export type CaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * The data used to create many Cases.
     */
    data: CaseCreateManyInput | CaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Case update
   */
  export type CaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Case.
     */
    data: XOR<CaseUpdateInput, CaseUncheckedUpdateInput>
    /**
     * Choose, which Case to update.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case updateMany
   */
  export type CaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cases.
     */
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyInput>
    /**
     * Filter which Cases to update
     */
    where?: CaseWhereInput
  }

  /**
   * Case upsert
   */
  export type CaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Case to update in case it exists.
     */
    where: CaseWhereUniqueInput
    /**
     * In case the Case found by the `where` argument doesn't exist, create a new Case with this data.
     */
    create: XOR<CaseCreateInput, CaseUncheckedCreateInput>
    /**
     * In case the Case was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseUpdateInput, CaseUncheckedUpdateInput>
  }

  /**
   * Case delete
   */
  export type CaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter which Case to delete.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case deleteMany
   */
  export type CaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cases to delete
     */
    where?: CaseWhereInput
  }

  /**
   * Case.assignedTo
   */
  export type Case$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Case.attachments
   */
  export type Case$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    where?: CaseAttachmentWhereInput
    orderBy?: CaseAttachmentOrderByWithRelationInput | CaseAttachmentOrderByWithRelationInput[]
    cursor?: CaseAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseAttachmentScalarFieldEnum | CaseAttachmentScalarFieldEnum[]
  }

  /**
   * Case.messages
   */
  export type Case$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    where?: CaseMessageWhereInput
    orderBy?: CaseMessageOrderByWithRelationInput | CaseMessageOrderByWithRelationInput[]
    cursor?: CaseMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseMessageScalarFieldEnum | CaseMessageScalarFieldEnum[]
  }

  /**
   * Case.quotes
   */
  export type Case$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Case without action
   */
  export type CaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
  }


  /**
   * Model CaseAttachment
   */

  export type AggregateCaseAttachment = {
    _count: CaseAttachmentCountAggregateOutputType | null
    _avg: CaseAttachmentAvgAggregateOutputType | null
    _sum: CaseAttachmentSumAggregateOutputType | null
    _min: CaseAttachmentMinAggregateOutputType | null
    _max: CaseAttachmentMaxAggregateOutputType | null
  }

  export type CaseAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type CaseAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type CaseAttachmentMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    filename: string | null
    url: string | null
    mimeType: string | null
    fileSize: number | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type CaseAttachmentMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    filename: string | null
    url: string | null
    mimeType: string | null
    fileSize: number | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type CaseAttachmentCountAggregateOutputType = {
    id: number
    caseId: number
    filename: number
    url: number
    mimeType: number
    fileSize: number
    uploadedBy: number
    createdAt: number
    _all: number
  }


  export type CaseAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type CaseAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type CaseAttachmentMinAggregateInputType = {
    id?: true
    caseId?: true
    filename?: true
    url?: true
    mimeType?: true
    fileSize?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type CaseAttachmentMaxAggregateInputType = {
    id?: true
    caseId?: true
    filename?: true
    url?: true
    mimeType?: true
    fileSize?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type CaseAttachmentCountAggregateInputType = {
    id?: true
    caseId?: true
    filename?: true
    url?: true
    mimeType?: true
    fileSize?: true
    uploadedBy?: true
    createdAt?: true
    _all?: true
  }

  export type CaseAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseAttachment to aggregate.
     */
    where?: CaseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseAttachments to fetch.
     */
    orderBy?: CaseAttachmentOrderByWithRelationInput | CaseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaseAttachments
    **/
    _count?: true | CaseAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaseAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaseAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseAttachmentMaxAggregateInputType
  }

  export type GetCaseAttachmentAggregateType<T extends CaseAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseAttachment[P]>
      : GetScalarType<T[P], AggregateCaseAttachment[P]>
  }




  export type CaseAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseAttachmentWhereInput
    orderBy?: CaseAttachmentOrderByWithAggregationInput | CaseAttachmentOrderByWithAggregationInput[]
    by: CaseAttachmentScalarFieldEnum[] | CaseAttachmentScalarFieldEnum
    having?: CaseAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseAttachmentCountAggregateInputType | true
    _avg?: CaseAttachmentAvgAggregateInputType
    _sum?: CaseAttachmentSumAggregateInputType
    _min?: CaseAttachmentMinAggregateInputType
    _max?: CaseAttachmentMaxAggregateInputType
  }

  export type CaseAttachmentGroupByOutputType = {
    id: string
    caseId: string
    filename: string
    url: string
    mimeType: string | null
    fileSize: number | null
    uploadedBy: string
    createdAt: Date
    _count: CaseAttachmentCountAggregateOutputType | null
    _avg: CaseAttachmentAvgAggregateOutputType | null
    _sum: CaseAttachmentSumAggregateOutputType | null
    _min: CaseAttachmentMinAggregateOutputType | null
    _max: CaseAttachmentMaxAggregateOutputType | null
  }

  type GetCaseAttachmentGroupByPayload<T extends CaseAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], CaseAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type CaseAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    fileSize?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseAttachment"]>

  export type CaseAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    fileSize?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseAttachment"]>


  export type CaseAttachmentSelectScalar = {
    id?: boolean
    caseId?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    fileSize?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }

  export type CaseAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "filename" | "url" | "mimeType" | "fileSize" | "uploadedBy" | "createdAt", ExtArgs["result"]["caseAttachment"]>
  export type CaseAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }
  export type CaseAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }

  export type $CaseAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseAttachment"
    objects: {
      case: Prisma.$CasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      filename: string
      url: string
      mimeType: string | null
      fileSize: number | null
      uploadedBy: string
      createdAt: Date
    }, ExtArgs["result"]["caseAttachment"]>
    composites: {}
  }

  type CaseAttachmentGetPayload<S extends boolean | null | undefined | CaseAttachmentDefaultArgs> = $Result.GetResult<Prisma.$CaseAttachmentPayload, S>

  type CaseAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseAttachmentCountAggregateInputType | true
    }

  export interface CaseAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseAttachment'], meta: { name: 'CaseAttachment' } }
    /**
     * Find zero or one CaseAttachment that matches the filter.
     * @param {CaseAttachmentFindUniqueArgs} args - Arguments to find a CaseAttachment
     * @example
     * // Get one CaseAttachment
     * const caseAttachment = await prisma.caseAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseAttachmentFindUniqueArgs>(args: SelectSubset<T, CaseAttachmentFindUniqueArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseAttachmentFindUniqueOrThrowArgs} args - Arguments to find a CaseAttachment
     * @example
     * // Get one CaseAttachment
     * const caseAttachment = await prisma.caseAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAttachmentFindFirstArgs} args - Arguments to find a CaseAttachment
     * @example
     * // Get one CaseAttachment
     * const caseAttachment = await prisma.caseAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseAttachmentFindFirstArgs>(args?: SelectSubset<T, CaseAttachmentFindFirstArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAttachmentFindFirstOrThrowArgs} args - Arguments to find a CaseAttachment
     * @example
     * // Get one CaseAttachment
     * const caseAttachment = await prisma.caseAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseAttachments
     * const caseAttachments = await prisma.caseAttachment.findMany()
     * 
     * // Get first 10 CaseAttachments
     * const caseAttachments = await prisma.caseAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseAttachmentWithIdOnly = await prisma.caseAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseAttachmentFindManyArgs>(args?: SelectSubset<T, CaseAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseAttachment.
     * @param {CaseAttachmentCreateArgs} args - Arguments to create a CaseAttachment.
     * @example
     * // Create one CaseAttachment
     * const CaseAttachment = await prisma.caseAttachment.create({
     *   data: {
     *     // ... data to create a CaseAttachment
     *   }
     * })
     * 
     */
    create<T extends CaseAttachmentCreateArgs>(args: SelectSubset<T, CaseAttachmentCreateArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseAttachments.
     * @param {CaseAttachmentCreateManyArgs} args - Arguments to create many CaseAttachments.
     * @example
     * // Create many CaseAttachments
     * const caseAttachment = await prisma.caseAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseAttachmentCreateManyArgs>(args?: SelectSubset<T, CaseAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseAttachments and returns the data saved in the database.
     * @param {CaseAttachmentCreateManyAndReturnArgs} args - Arguments to create many CaseAttachments.
     * @example
     * // Create many CaseAttachments
     * const caseAttachment = await prisma.caseAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CaseAttachments and only return the `id`
     * const caseAttachmentWithIdOnly = await prisma.caseAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseAttachment.
     * @param {CaseAttachmentDeleteArgs} args - Arguments to delete one CaseAttachment.
     * @example
     * // Delete one CaseAttachment
     * const CaseAttachment = await prisma.caseAttachment.delete({
     *   where: {
     *     // ... filter to delete one CaseAttachment
     *   }
     * })
     * 
     */
    delete<T extends CaseAttachmentDeleteArgs>(args: SelectSubset<T, CaseAttachmentDeleteArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseAttachment.
     * @param {CaseAttachmentUpdateArgs} args - Arguments to update one CaseAttachment.
     * @example
     * // Update one CaseAttachment
     * const caseAttachment = await prisma.caseAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseAttachmentUpdateArgs>(args: SelectSubset<T, CaseAttachmentUpdateArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseAttachments.
     * @param {CaseAttachmentDeleteManyArgs} args - Arguments to filter CaseAttachments to delete.
     * @example
     * // Delete a few CaseAttachments
     * const { count } = await prisma.caseAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseAttachmentDeleteManyArgs>(args?: SelectSubset<T, CaseAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseAttachments
     * const caseAttachment = await prisma.caseAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseAttachmentUpdateManyArgs>(args: SelectSubset<T, CaseAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CaseAttachment.
     * @param {CaseAttachmentUpsertArgs} args - Arguments to update or create a CaseAttachment.
     * @example
     * // Update or create a CaseAttachment
     * const caseAttachment = await prisma.caseAttachment.upsert({
     *   create: {
     *     // ... data to create a CaseAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseAttachment we want to update
     *   }
     * })
     */
    upsert<T extends CaseAttachmentUpsertArgs>(args: SelectSubset<T, CaseAttachmentUpsertArgs<ExtArgs>>): Prisma__CaseAttachmentClient<$Result.GetResult<Prisma.$CaseAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAttachmentCountArgs} args - Arguments to filter CaseAttachments to count.
     * @example
     * // Count the number of CaseAttachments
     * const count = await prisma.caseAttachment.count({
     *   where: {
     *     // ... the filter for the CaseAttachments we want to count
     *   }
     * })
    **/
    count<T extends CaseAttachmentCountArgs>(
      args?: Subset<T, CaseAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseAttachmentAggregateArgs>(args: Subset<T, CaseAttachmentAggregateArgs>): Prisma.PrismaPromise<GetCaseAttachmentAggregateType<T>>

    /**
     * Group by CaseAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: CaseAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseAttachment model
   */
  readonly fields: CaseAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends CaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaseDefaultArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseAttachment model
   */
  interface CaseAttachmentFieldRefs {
    readonly id: FieldRef<"CaseAttachment", 'String'>
    readonly caseId: FieldRef<"CaseAttachment", 'String'>
    readonly filename: FieldRef<"CaseAttachment", 'String'>
    readonly url: FieldRef<"CaseAttachment", 'String'>
    readonly mimeType: FieldRef<"CaseAttachment", 'String'>
    readonly fileSize: FieldRef<"CaseAttachment", 'Int'>
    readonly uploadedBy: FieldRef<"CaseAttachment", 'String'>
    readonly createdAt: FieldRef<"CaseAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CaseAttachment findUnique
   */
  export type CaseAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseAttachment to fetch.
     */
    where: CaseAttachmentWhereUniqueInput
  }

  /**
   * CaseAttachment findUniqueOrThrow
   */
  export type CaseAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseAttachment to fetch.
     */
    where: CaseAttachmentWhereUniqueInput
  }

  /**
   * CaseAttachment findFirst
   */
  export type CaseAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseAttachment to fetch.
     */
    where?: CaseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseAttachments to fetch.
     */
    orderBy?: CaseAttachmentOrderByWithRelationInput | CaseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseAttachments.
     */
    cursor?: CaseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseAttachments.
     */
    distinct?: CaseAttachmentScalarFieldEnum | CaseAttachmentScalarFieldEnum[]
  }

  /**
   * CaseAttachment findFirstOrThrow
   */
  export type CaseAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseAttachment to fetch.
     */
    where?: CaseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseAttachments to fetch.
     */
    orderBy?: CaseAttachmentOrderByWithRelationInput | CaseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseAttachments.
     */
    cursor?: CaseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseAttachments.
     */
    distinct?: CaseAttachmentScalarFieldEnum | CaseAttachmentScalarFieldEnum[]
  }

  /**
   * CaseAttachment findMany
   */
  export type CaseAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseAttachments to fetch.
     */
    where?: CaseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseAttachments to fetch.
     */
    orderBy?: CaseAttachmentOrderByWithRelationInput | CaseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaseAttachments.
     */
    cursor?: CaseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseAttachments.
     */
    skip?: number
    distinct?: CaseAttachmentScalarFieldEnum | CaseAttachmentScalarFieldEnum[]
  }

  /**
   * CaseAttachment create
   */
  export type CaseAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseAttachment.
     */
    data: XOR<CaseAttachmentCreateInput, CaseAttachmentUncheckedCreateInput>
  }

  /**
   * CaseAttachment createMany
   */
  export type CaseAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseAttachments.
     */
    data: CaseAttachmentCreateManyInput | CaseAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseAttachment createManyAndReturn
   */
  export type CaseAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many CaseAttachments.
     */
    data: CaseAttachmentCreateManyInput | CaseAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseAttachment update
   */
  export type CaseAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseAttachment.
     */
    data: XOR<CaseAttachmentUpdateInput, CaseAttachmentUncheckedUpdateInput>
    /**
     * Choose, which CaseAttachment to update.
     */
    where: CaseAttachmentWhereUniqueInput
  }

  /**
   * CaseAttachment updateMany
   */
  export type CaseAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseAttachments.
     */
    data: XOR<CaseAttachmentUpdateManyMutationInput, CaseAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which CaseAttachments to update
     */
    where?: CaseAttachmentWhereInput
  }

  /**
   * CaseAttachment upsert
   */
  export type CaseAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseAttachment to update in case it exists.
     */
    where: CaseAttachmentWhereUniqueInput
    /**
     * In case the CaseAttachment found by the `where` argument doesn't exist, create a new CaseAttachment with this data.
     */
    create: XOR<CaseAttachmentCreateInput, CaseAttachmentUncheckedCreateInput>
    /**
     * In case the CaseAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseAttachmentUpdateInput, CaseAttachmentUncheckedUpdateInput>
  }

  /**
   * CaseAttachment delete
   */
  export type CaseAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
    /**
     * Filter which CaseAttachment to delete.
     */
    where: CaseAttachmentWhereUniqueInput
  }

  /**
   * CaseAttachment deleteMany
   */
  export type CaseAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseAttachments to delete
     */
    where?: CaseAttachmentWhereInput
  }

  /**
   * CaseAttachment without action
   */
  export type CaseAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseAttachment
     */
    select?: CaseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseAttachment
     */
    omit?: CaseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model CaseMessage
   */

  export type AggregateCaseMessage = {
    _count: CaseMessageCountAggregateOutputType | null
    _min: CaseMessageMinAggregateOutputType | null
    _max: CaseMessageMaxAggregateOutputType | null
  }

  export type CaseMessageMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    senderId: string | null
    senderName: string | null
    senderRole: $Enums.UserRole | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type CaseMessageMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    senderId: string | null
    senderName: string | null
    senderRole: $Enums.UserRole | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type CaseMessageCountAggregateOutputType = {
    id: number
    caseId: number
    senderId: number
    senderName: number
    senderRole: number
    message: number
    isInternal: number
    createdAt: number
    _all: number
  }


  export type CaseMessageMinAggregateInputType = {
    id?: true
    caseId?: true
    senderId?: true
    senderName?: true
    senderRole?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type CaseMessageMaxAggregateInputType = {
    id?: true
    caseId?: true
    senderId?: true
    senderName?: true
    senderRole?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type CaseMessageCountAggregateInputType = {
    id?: true
    caseId?: true
    senderId?: true
    senderName?: true
    senderRole?: true
    message?: true
    isInternal?: true
    createdAt?: true
    _all?: true
  }

  export type CaseMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseMessage to aggregate.
     */
    where?: CaseMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseMessages to fetch.
     */
    orderBy?: CaseMessageOrderByWithRelationInput | CaseMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaseMessages
    **/
    _count?: true | CaseMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseMessageMaxAggregateInputType
  }

  export type GetCaseMessageAggregateType<T extends CaseMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseMessage[P]>
      : GetScalarType<T[P], AggregateCaseMessage[P]>
  }




  export type CaseMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseMessageWhereInput
    orderBy?: CaseMessageOrderByWithAggregationInput | CaseMessageOrderByWithAggregationInput[]
    by: CaseMessageScalarFieldEnum[] | CaseMessageScalarFieldEnum
    having?: CaseMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseMessageCountAggregateInputType | true
    _min?: CaseMessageMinAggregateInputType
    _max?: CaseMessageMaxAggregateInputType
  }

  export type CaseMessageGroupByOutputType = {
    id: string
    caseId: string
    senderId: string
    senderName: string
    senderRole: $Enums.UserRole
    message: string
    isInternal: boolean
    createdAt: Date
    _count: CaseMessageCountAggregateOutputType | null
    _min: CaseMessageMinAggregateOutputType | null
    _max: CaseMessageMaxAggregateOutputType | null
  }

  type GetCaseMessageGroupByPayload<T extends CaseMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CaseMessageGroupByOutputType[P]>
        }
      >
    >


  export type CaseMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    senderId?: boolean
    senderName?: boolean
    senderRole?: boolean
    message?: boolean
    isInternal?: boolean
    createdAt?: boolean
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseMessage"]>

  export type CaseMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    senderId?: boolean
    senderName?: boolean
    senderRole?: boolean
    message?: boolean
    isInternal?: boolean
    createdAt?: boolean
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseMessage"]>


  export type CaseMessageSelectScalar = {
    id?: boolean
    caseId?: boolean
    senderId?: boolean
    senderName?: boolean
    senderRole?: boolean
    message?: boolean
    isInternal?: boolean
    createdAt?: boolean
  }

  export type CaseMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "senderId" | "senderName" | "senderRole" | "message" | "isInternal" | "createdAt", ExtArgs["result"]["caseMessage"]>
  export type CaseMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }
  export type CaseMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }

  export type $CaseMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseMessage"
    objects: {
      case: Prisma.$CasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      senderId: string
      senderName: string
      senderRole: $Enums.UserRole
      message: string
      isInternal: boolean
      createdAt: Date
    }, ExtArgs["result"]["caseMessage"]>
    composites: {}
  }

  type CaseMessageGetPayload<S extends boolean | null | undefined | CaseMessageDefaultArgs> = $Result.GetResult<Prisma.$CaseMessagePayload, S>

  type CaseMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseMessageCountAggregateInputType | true
    }

  export interface CaseMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseMessage'], meta: { name: 'CaseMessage' } }
    /**
     * Find zero or one CaseMessage that matches the filter.
     * @param {CaseMessageFindUniqueArgs} args - Arguments to find a CaseMessage
     * @example
     * // Get one CaseMessage
     * const caseMessage = await prisma.caseMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseMessageFindUniqueArgs>(args: SelectSubset<T, CaseMessageFindUniqueArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseMessageFindUniqueOrThrowArgs} args - Arguments to find a CaseMessage
     * @example
     * // Get one CaseMessage
     * const caseMessage = await prisma.caseMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseMessageFindFirstArgs} args - Arguments to find a CaseMessage
     * @example
     * // Get one CaseMessage
     * const caseMessage = await prisma.caseMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseMessageFindFirstArgs>(args?: SelectSubset<T, CaseMessageFindFirstArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseMessageFindFirstOrThrowArgs} args - Arguments to find a CaseMessage
     * @example
     * // Get one CaseMessage
     * const caseMessage = await prisma.caseMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseMessages
     * const caseMessages = await prisma.caseMessage.findMany()
     * 
     * // Get first 10 CaseMessages
     * const caseMessages = await prisma.caseMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseMessageWithIdOnly = await prisma.caseMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseMessageFindManyArgs>(args?: SelectSubset<T, CaseMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseMessage.
     * @param {CaseMessageCreateArgs} args - Arguments to create a CaseMessage.
     * @example
     * // Create one CaseMessage
     * const CaseMessage = await prisma.caseMessage.create({
     *   data: {
     *     // ... data to create a CaseMessage
     *   }
     * })
     * 
     */
    create<T extends CaseMessageCreateArgs>(args: SelectSubset<T, CaseMessageCreateArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseMessages.
     * @param {CaseMessageCreateManyArgs} args - Arguments to create many CaseMessages.
     * @example
     * // Create many CaseMessages
     * const caseMessage = await prisma.caseMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseMessageCreateManyArgs>(args?: SelectSubset<T, CaseMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseMessages and returns the data saved in the database.
     * @param {CaseMessageCreateManyAndReturnArgs} args - Arguments to create many CaseMessages.
     * @example
     * // Create many CaseMessages
     * const caseMessage = await prisma.caseMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CaseMessages and only return the `id`
     * const caseMessageWithIdOnly = await prisma.caseMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseMessage.
     * @param {CaseMessageDeleteArgs} args - Arguments to delete one CaseMessage.
     * @example
     * // Delete one CaseMessage
     * const CaseMessage = await prisma.caseMessage.delete({
     *   where: {
     *     // ... filter to delete one CaseMessage
     *   }
     * })
     * 
     */
    delete<T extends CaseMessageDeleteArgs>(args: SelectSubset<T, CaseMessageDeleteArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseMessage.
     * @param {CaseMessageUpdateArgs} args - Arguments to update one CaseMessage.
     * @example
     * // Update one CaseMessage
     * const caseMessage = await prisma.caseMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseMessageUpdateArgs>(args: SelectSubset<T, CaseMessageUpdateArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseMessages.
     * @param {CaseMessageDeleteManyArgs} args - Arguments to filter CaseMessages to delete.
     * @example
     * // Delete a few CaseMessages
     * const { count } = await prisma.caseMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseMessageDeleteManyArgs>(args?: SelectSubset<T, CaseMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseMessages
     * const caseMessage = await prisma.caseMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseMessageUpdateManyArgs>(args: SelectSubset<T, CaseMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CaseMessage.
     * @param {CaseMessageUpsertArgs} args - Arguments to update or create a CaseMessage.
     * @example
     * // Update or create a CaseMessage
     * const caseMessage = await prisma.caseMessage.upsert({
     *   create: {
     *     // ... data to create a CaseMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseMessage we want to update
     *   }
     * })
     */
    upsert<T extends CaseMessageUpsertArgs>(args: SelectSubset<T, CaseMessageUpsertArgs<ExtArgs>>): Prisma__CaseMessageClient<$Result.GetResult<Prisma.$CaseMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseMessageCountArgs} args - Arguments to filter CaseMessages to count.
     * @example
     * // Count the number of CaseMessages
     * const count = await prisma.caseMessage.count({
     *   where: {
     *     // ... the filter for the CaseMessages we want to count
     *   }
     * })
    **/
    count<T extends CaseMessageCountArgs>(
      args?: Subset<T, CaseMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseMessageAggregateArgs>(args: Subset<T, CaseMessageAggregateArgs>): Prisma.PrismaPromise<GetCaseMessageAggregateType<T>>

    /**
     * Group by CaseMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseMessageGroupByArgs['orderBy'] }
        : { orderBy?: CaseMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseMessage model
   */
  readonly fields: CaseMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends CaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaseDefaultArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseMessage model
   */
  interface CaseMessageFieldRefs {
    readonly id: FieldRef<"CaseMessage", 'String'>
    readonly caseId: FieldRef<"CaseMessage", 'String'>
    readonly senderId: FieldRef<"CaseMessage", 'String'>
    readonly senderName: FieldRef<"CaseMessage", 'String'>
    readonly senderRole: FieldRef<"CaseMessage", 'UserRole'>
    readonly message: FieldRef<"CaseMessage", 'String'>
    readonly isInternal: FieldRef<"CaseMessage", 'Boolean'>
    readonly createdAt: FieldRef<"CaseMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CaseMessage findUnique
   */
  export type CaseMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * Filter, which CaseMessage to fetch.
     */
    where: CaseMessageWhereUniqueInput
  }

  /**
   * CaseMessage findUniqueOrThrow
   */
  export type CaseMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * Filter, which CaseMessage to fetch.
     */
    where: CaseMessageWhereUniqueInput
  }

  /**
   * CaseMessage findFirst
   */
  export type CaseMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * Filter, which CaseMessage to fetch.
     */
    where?: CaseMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseMessages to fetch.
     */
    orderBy?: CaseMessageOrderByWithRelationInput | CaseMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseMessages.
     */
    cursor?: CaseMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseMessages.
     */
    distinct?: CaseMessageScalarFieldEnum | CaseMessageScalarFieldEnum[]
  }

  /**
   * CaseMessage findFirstOrThrow
   */
  export type CaseMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * Filter, which CaseMessage to fetch.
     */
    where?: CaseMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseMessages to fetch.
     */
    orderBy?: CaseMessageOrderByWithRelationInput | CaseMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseMessages.
     */
    cursor?: CaseMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseMessages.
     */
    distinct?: CaseMessageScalarFieldEnum | CaseMessageScalarFieldEnum[]
  }

  /**
   * CaseMessage findMany
   */
  export type CaseMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * Filter, which CaseMessages to fetch.
     */
    where?: CaseMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseMessages to fetch.
     */
    orderBy?: CaseMessageOrderByWithRelationInput | CaseMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaseMessages.
     */
    cursor?: CaseMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseMessages.
     */
    skip?: number
    distinct?: CaseMessageScalarFieldEnum | CaseMessageScalarFieldEnum[]
  }

  /**
   * CaseMessage create
   */
  export type CaseMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseMessage.
     */
    data: XOR<CaseMessageCreateInput, CaseMessageUncheckedCreateInput>
  }

  /**
   * CaseMessage createMany
   */
  export type CaseMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseMessages.
     */
    data: CaseMessageCreateManyInput | CaseMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseMessage createManyAndReturn
   */
  export type CaseMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * The data used to create many CaseMessages.
     */
    data: CaseMessageCreateManyInput | CaseMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseMessage update
   */
  export type CaseMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseMessage.
     */
    data: XOR<CaseMessageUpdateInput, CaseMessageUncheckedUpdateInput>
    /**
     * Choose, which CaseMessage to update.
     */
    where: CaseMessageWhereUniqueInput
  }

  /**
   * CaseMessage updateMany
   */
  export type CaseMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseMessages.
     */
    data: XOR<CaseMessageUpdateManyMutationInput, CaseMessageUncheckedUpdateManyInput>
    /**
     * Filter which CaseMessages to update
     */
    where?: CaseMessageWhereInput
  }

  /**
   * CaseMessage upsert
   */
  export type CaseMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseMessage to update in case it exists.
     */
    where: CaseMessageWhereUniqueInput
    /**
     * In case the CaseMessage found by the `where` argument doesn't exist, create a new CaseMessage with this data.
     */
    create: XOR<CaseMessageCreateInput, CaseMessageUncheckedCreateInput>
    /**
     * In case the CaseMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseMessageUpdateInput, CaseMessageUncheckedUpdateInput>
  }

  /**
   * CaseMessage delete
   */
  export type CaseMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
    /**
     * Filter which CaseMessage to delete.
     */
    where: CaseMessageWhereUniqueInput
  }

  /**
   * CaseMessage deleteMany
   */
  export type CaseMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseMessages to delete
     */
    where?: CaseMessageWhereInput
  }

  /**
   * CaseMessage without action
   */
  export type CaseMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseMessage
     */
    select?: CaseMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseMessage
     */
    omit?: CaseMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseMessageInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    version: number | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountPercent: Decimal | null
    shippingAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type QuoteSumAggregateOutputType = {
    version: number | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountPercent: Decimal | null
    shippingAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    quoteNumber: string | null
    version: number | null
    customerId: string | null
    caseId: string | null
    projectId: string | null
    status: $Enums.QuoteStatus | null
    validUntil: Date | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountPercent: Decimal | null
    shippingAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
    shippingTerms: string | null
    leadTimeTerms: string | null
    paymentTerms: string | null
    exceptions: string | null
    acceptedAt: Date | null
    acceptedBy: string | null
    bcOrderId: string | null
    createdById: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    quoteNumber: string | null
    version: number | null
    customerId: string | null
    caseId: string | null
    projectId: string | null
    status: $Enums.QuoteStatus | null
    validUntil: Date | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountPercent: Decimal | null
    shippingAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
    shippingTerms: string | null
    leadTimeTerms: string | null
    paymentTerms: string | null
    exceptions: string | null
    acceptedAt: Date | null
    acceptedBy: string | null
    bcOrderId: string | null
    createdById: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    quoteNumber: number
    version: number
    customerId: number
    caseId: number
    projectId: number
    status: number
    validUntil: number
    items: number
    subtotal: number
    discountAmount: number
    discountPercent: number
    shippingAmount: number
    taxAmount: number
    totalAmount: number
    shippingTerms: number
    leadTimeTerms: number
    paymentTerms: number
    exceptions: number
    acceptedAt: number
    acceptedBy: number
    bcOrderId: number
    createdById: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    version?: true
    subtotal?: true
    discountAmount?: true
    discountPercent?: true
    shippingAmount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type QuoteSumAggregateInputType = {
    version?: true
    subtotal?: true
    discountAmount?: true
    discountPercent?: true
    shippingAmount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    quoteNumber?: true
    version?: true
    customerId?: true
    caseId?: true
    projectId?: true
    status?: true
    validUntil?: true
    subtotal?: true
    discountAmount?: true
    discountPercent?: true
    shippingAmount?: true
    taxAmount?: true
    totalAmount?: true
    shippingTerms?: true
    leadTimeTerms?: true
    paymentTerms?: true
    exceptions?: true
    acceptedAt?: true
    acceptedBy?: true
    bcOrderId?: true
    createdById?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    quoteNumber?: true
    version?: true
    customerId?: true
    caseId?: true
    projectId?: true
    status?: true
    validUntil?: true
    subtotal?: true
    discountAmount?: true
    discountPercent?: true
    shippingAmount?: true
    taxAmount?: true
    totalAmount?: true
    shippingTerms?: true
    leadTimeTerms?: true
    paymentTerms?: true
    exceptions?: true
    acceptedAt?: true
    acceptedBy?: true
    bcOrderId?: true
    createdById?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    quoteNumber?: true
    version?: true
    customerId?: true
    caseId?: true
    projectId?: true
    status?: true
    validUntil?: true
    items?: true
    subtotal?: true
    discountAmount?: true
    discountPercent?: true
    shippingAmount?: true
    taxAmount?: true
    totalAmount?: true
    shippingTerms?: true
    leadTimeTerms?: true
    paymentTerms?: true
    exceptions?: true
    acceptedAt?: true
    acceptedBy?: true
    bcOrderId?: true
    createdById?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    quoteNumber: string
    version: number
    customerId: string
    caseId: string | null
    projectId: string | null
    status: $Enums.QuoteStatus
    validUntil: Date
    items: JsonValue
    subtotal: Decimal
    discountAmount: Decimal
    discountPercent: Decimal | null
    shippingAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal
    shippingTerms: string | null
    leadTimeTerms: string | null
    paymentTerms: string | null
    exceptions: string | null
    acceptedAt: Date | null
    acceptedBy: string | null
    bcOrderId: string | null
    createdById: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteNumber?: boolean
    version?: boolean
    customerId?: boolean
    caseId?: boolean
    projectId?: boolean
    status?: boolean
    validUntil?: boolean
    items?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    discountPercent?: boolean
    shippingAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    shippingTerms?: boolean
    leadTimeTerms?: boolean
    paymentTerms?: boolean
    exceptions?: boolean
    acceptedAt?: boolean
    acceptedBy?: boolean
    bcOrderId?: boolean
    createdById?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    case?: boolean | Quote$caseArgs<ExtArgs>
    project?: boolean | Quote$projectArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteNumber?: boolean
    version?: boolean
    customerId?: boolean
    caseId?: boolean
    projectId?: boolean
    status?: boolean
    validUntil?: boolean
    items?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    discountPercent?: boolean
    shippingAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    shippingTerms?: boolean
    leadTimeTerms?: boolean
    paymentTerms?: boolean
    exceptions?: boolean
    acceptedAt?: boolean
    acceptedBy?: boolean
    bcOrderId?: boolean
    createdById?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    case?: boolean | Quote$caseArgs<ExtArgs>
    project?: boolean | Quote$projectArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>


  export type QuoteSelectScalar = {
    id?: boolean
    quoteNumber?: boolean
    version?: boolean
    customerId?: boolean
    caseId?: boolean
    projectId?: boolean
    status?: boolean
    validUntil?: boolean
    items?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    discountPercent?: boolean
    shippingAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    shippingTerms?: boolean
    leadTimeTerms?: boolean
    paymentTerms?: boolean
    exceptions?: boolean
    acceptedAt?: boolean
    acceptedBy?: boolean
    bcOrderId?: boolean
    createdById?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quoteNumber" | "version" | "customerId" | "caseId" | "projectId" | "status" | "validUntil" | "items" | "subtotal" | "discountAmount" | "discountPercent" | "shippingAmount" | "taxAmount" | "totalAmount" | "shippingTerms" | "leadTimeTerms" | "paymentTerms" | "exceptions" | "acceptedAt" | "acceptedBy" | "bcOrderId" | "createdById" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["quote"]>
  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    case?: boolean | Quote$caseArgs<ExtArgs>
    project?: boolean | Quote$projectArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    case?: boolean | Quote$caseArgs<ExtArgs>
    project?: boolean | Quote$projectArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      case: Prisma.$CasePayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quoteNumber: string
      version: number
      customerId: string
      caseId: string | null
      projectId: string | null
      status: $Enums.QuoteStatus
      validUntil: Date
      items: Prisma.JsonValue
      subtotal: Prisma.Decimal
      discountAmount: Prisma.Decimal
      discountPercent: Prisma.Decimal | null
      shippingAmount: Prisma.Decimal | null
      taxAmount: Prisma.Decimal | null
      totalAmount: Prisma.Decimal
      shippingTerms: string | null
      leadTimeTerms: string | null
      paymentTerms: string | null
      exceptions: string | null
      acceptedAt: Date | null
      acceptedBy: string | null
      bcOrderId: string | null
      createdById: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    case<T extends Quote$caseArgs<ExtArgs> = {}>(args?: Subset<T, Quote$caseArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends Quote$projectArgs<ExtArgs> = {}>(args?: Subset<T, Quote$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly quoteNumber: FieldRef<"Quote", 'String'>
    readonly version: FieldRef<"Quote", 'Int'>
    readonly customerId: FieldRef<"Quote", 'String'>
    readonly caseId: FieldRef<"Quote", 'String'>
    readonly projectId: FieldRef<"Quote", 'String'>
    readonly status: FieldRef<"Quote", 'QuoteStatus'>
    readonly validUntil: FieldRef<"Quote", 'DateTime'>
    readonly items: FieldRef<"Quote", 'Json'>
    readonly subtotal: FieldRef<"Quote", 'Decimal'>
    readonly discountAmount: FieldRef<"Quote", 'Decimal'>
    readonly discountPercent: FieldRef<"Quote", 'Decimal'>
    readonly shippingAmount: FieldRef<"Quote", 'Decimal'>
    readonly taxAmount: FieldRef<"Quote", 'Decimal'>
    readonly totalAmount: FieldRef<"Quote", 'Decimal'>
    readonly shippingTerms: FieldRef<"Quote", 'String'>
    readonly leadTimeTerms: FieldRef<"Quote", 'String'>
    readonly paymentTerms: FieldRef<"Quote", 'String'>
    readonly exceptions: FieldRef<"Quote", 'String'>
    readonly acceptedAt: FieldRef<"Quote", 'DateTime'>
    readonly acceptedBy: FieldRef<"Quote", 'String'>
    readonly bcOrderId: FieldRef<"Quote", 'String'>
    readonly createdById: FieldRef<"Quote", 'String'>
    readonly notes: FieldRef<"Quote", 'String'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote.case
   */
  export type Quote$caseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    where?: CaseWhereInput
  }

  /**
   * Quote.project
   */
  export type Quote$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    projectName: string | null
    customerId: string | null
    siteAddress: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    projectName: string | null
    customerId: string | null
    siteAddress: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    projectName: number
    customerId: number
    siteAddress: number
    savedSkus: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    projectName?: true
    customerId?: true
    siteAddress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    projectName?: true
    customerId?: true
    siteAddress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    projectName?: true
    customerId?: true
    siteAddress?: true
    savedSkus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    projectName: string
    customerId: string
    siteAddress: string | null
    savedSkus: string[]
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectName?: boolean
    customerId?: boolean
    siteAddress?: boolean
    savedSkus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    quotes?: boolean | Project$quotesArgs<ExtArgs>
    specPackages?: boolean | Project$specPackagesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectName?: boolean
    customerId?: boolean
    siteAddress?: boolean
    savedSkus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>


  export type ProjectSelectScalar = {
    id?: boolean
    projectName?: boolean
    customerId?: boolean
    siteAddress?: boolean
    savedSkus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectName" | "customerId" | "siteAddress" | "savedSkus" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    quotes?: boolean | Project$quotesArgs<ExtArgs>
    specPackages?: boolean | Project$specPackagesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      specPackages: Prisma.$SpecPackagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectName: string
      customerId: string
      siteAddress: string | null
      savedSkus: string[]
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quotes<T extends Project$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Project$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specPackages<T extends Project$specPackagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$specPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly projectName: FieldRef<"Project", 'String'>
    readonly customerId: FieldRef<"Project", 'String'>
    readonly siteAddress: FieldRef<"Project", 'String'>
    readonly savedSkus: FieldRef<"Project", 'String[]'>
    readonly notes: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.quotes
   */
  export type Project$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Project.specPackages
   */
  export type Project$specPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    where?: SpecPackageWhereInput
    orderBy?: SpecPackageOrderByWithRelationInput | SpecPackageOrderByWithRelationInput[]
    cursor?: SpecPackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecPackageScalarFieldEnum | SpecPackageScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model SpecPackage
   */

  export type AggregateSpecPackage = {
    _count: SpecPackageCountAggregateOutputType | null
    _min: SpecPackageMinAggregateOutputType | null
    _max: SpecPackageMaxAggregateOutputType | null
  }

  export type SpecPackageMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    zipUrl: string | null
    generatedAt: Date | null
    createdAt: Date | null
  }

  export type SpecPackageMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    zipUrl: string | null
    generatedAt: Date | null
    createdAt: Date | null
  }

  export type SpecPackageCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    skus: number
    zipUrl: number
    generatedAt: number
    createdAt: number
    _all: number
  }


  export type SpecPackageMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    zipUrl?: true
    generatedAt?: true
    createdAt?: true
  }

  export type SpecPackageMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    zipUrl?: true
    generatedAt?: true
    createdAt?: true
  }

  export type SpecPackageCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    skus?: true
    zipUrl?: true
    generatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SpecPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecPackage to aggregate.
     */
    where?: SpecPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecPackages to fetch.
     */
    orderBy?: SpecPackageOrderByWithRelationInput | SpecPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecPackages
    **/
    _count?: true | SpecPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecPackageMaxAggregateInputType
  }

  export type GetSpecPackageAggregateType<T extends SpecPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecPackage[P]>
      : GetScalarType<T[P], AggregateSpecPackage[P]>
  }




  export type SpecPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecPackageWhereInput
    orderBy?: SpecPackageOrderByWithAggregationInput | SpecPackageOrderByWithAggregationInput[]
    by: SpecPackageScalarFieldEnum[] | SpecPackageScalarFieldEnum
    having?: SpecPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecPackageCountAggregateInputType | true
    _min?: SpecPackageMinAggregateInputType
    _max?: SpecPackageMaxAggregateInputType
  }

  export type SpecPackageGroupByOutputType = {
    id: string
    projectId: string
    name: string
    skus: string[]
    zipUrl: string | null
    generatedAt: Date | null
    createdAt: Date
    _count: SpecPackageCountAggregateOutputType | null
    _min: SpecPackageMinAggregateOutputType | null
    _max: SpecPackageMaxAggregateOutputType | null
  }

  type GetSpecPackageGroupByPayload<T extends SpecPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecPackageGroupByOutputType[P]>
            : GetScalarType<T[P], SpecPackageGroupByOutputType[P]>
        }
      >
    >


  export type SpecPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    skus?: boolean
    zipUrl?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specPackage"]>

  export type SpecPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    skus?: boolean
    zipUrl?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specPackage"]>


  export type SpecPackageSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    skus?: boolean
    zipUrl?: boolean
    generatedAt?: boolean
    createdAt?: boolean
  }

  export type SpecPackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "skus" | "zipUrl" | "generatedAt" | "createdAt", ExtArgs["result"]["specPackage"]>
  export type SpecPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type SpecPackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SpecPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecPackage"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      skus: string[]
      zipUrl: string | null
      generatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["specPackage"]>
    composites: {}
  }

  type SpecPackageGetPayload<S extends boolean | null | undefined | SpecPackageDefaultArgs> = $Result.GetResult<Prisma.$SpecPackagePayload, S>

  type SpecPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecPackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecPackageCountAggregateInputType | true
    }

  export interface SpecPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecPackage'], meta: { name: 'SpecPackage' } }
    /**
     * Find zero or one SpecPackage that matches the filter.
     * @param {SpecPackageFindUniqueArgs} args - Arguments to find a SpecPackage
     * @example
     * // Get one SpecPackage
     * const specPackage = await prisma.specPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecPackageFindUniqueArgs>(args: SelectSubset<T, SpecPackageFindUniqueArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecPackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecPackageFindUniqueOrThrowArgs} args - Arguments to find a SpecPackage
     * @example
     * // Get one SpecPackage
     * const specPackage = await prisma.specPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecPackageFindFirstArgs} args - Arguments to find a SpecPackage
     * @example
     * // Get one SpecPackage
     * const specPackage = await prisma.specPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecPackageFindFirstArgs>(args?: SelectSubset<T, SpecPackageFindFirstArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecPackageFindFirstOrThrowArgs} args - Arguments to find a SpecPackage
     * @example
     * // Get one SpecPackage
     * const specPackage = await prisma.specPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecPackages
     * const specPackages = await prisma.specPackage.findMany()
     * 
     * // Get first 10 SpecPackages
     * const specPackages = await prisma.specPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specPackageWithIdOnly = await prisma.specPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecPackageFindManyArgs>(args?: SelectSubset<T, SpecPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecPackage.
     * @param {SpecPackageCreateArgs} args - Arguments to create a SpecPackage.
     * @example
     * // Create one SpecPackage
     * const SpecPackage = await prisma.specPackage.create({
     *   data: {
     *     // ... data to create a SpecPackage
     *   }
     * })
     * 
     */
    create<T extends SpecPackageCreateArgs>(args: SelectSubset<T, SpecPackageCreateArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecPackages.
     * @param {SpecPackageCreateManyArgs} args - Arguments to create many SpecPackages.
     * @example
     * // Create many SpecPackages
     * const specPackage = await prisma.specPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecPackageCreateManyArgs>(args?: SelectSubset<T, SpecPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecPackages and returns the data saved in the database.
     * @param {SpecPackageCreateManyAndReturnArgs} args - Arguments to create many SpecPackages.
     * @example
     * // Create many SpecPackages
     * const specPackage = await prisma.specPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecPackages and only return the `id`
     * const specPackageWithIdOnly = await prisma.specPackage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecPackage.
     * @param {SpecPackageDeleteArgs} args - Arguments to delete one SpecPackage.
     * @example
     * // Delete one SpecPackage
     * const SpecPackage = await prisma.specPackage.delete({
     *   where: {
     *     // ... filter to delete one SpecPackage
     *   }
     * })
     * 
     */
    delete<T extends SpecPackageDeleteArgs>(args: SelectSubset<T, SpecPackageDeleteArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecPackage.
     * @param {SpecPackageUpdateArgs} args - Arguments to update one SpecPackage.
     * @example
     * // Update one SpecPackage
     * const specPackage = await prisma.specPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecPackageUpdateArgs>(args: SelectSubset<T, SpecPackageUpdateArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecPackages.
     * @param {SpecPackageDeleteManyArgs} args - Arguments to filter SpecPackages to delete.
     * @example
     * // Delete a few SpecPackages
     * const { count } = await prisma.specPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecPackageDeleteManyArgs>(args?: SelectSubset<T, SpecPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecPackages
     * const specPackage = await prisma.specPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecPackageUpdateManyArgs>(args: SelectSubset<T, SpecPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpecPackage.
     * @param {SpecPackageUpsertArgs} args - Arguments to update or create a SpecPackage.
     * @example
     * // Update or create a SpecPackage
     * const specPackage = await prisma.specPackage.upsert({
     *   create: {
     *     // ... data to create a SpecPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecPackage we want to update
     *   }
     * })
     */
    upsert<T extends SpecPackageUpsertArgs>(args: SelectSubset<T, SpecPackageUpsertArgs<ExtArgs>>): Prisma__SpecPackageClient<$Result.GetResult<Prisma.$SpecPackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecPackageCountArgs} args - Arguments to filter SpecPackages to count.
     * @example
     * // Count the number of SpecPackages
     * const count = await prisma.specPackage.count({
     *   where: {
     *     // ... the filter for the SpecPackages we want to count
     *   }
     * })
    **/
    count<T extends SpecPackageCountArgs>(
      args?: Subset<T, SpecPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecPackageAggregateArgs>(args: Subset<T, SpecPackageAggregateArgs>): Prisma.PrismaPromise<GetSpecPackageAggregateType<T>>

    /**
     * Group by SpecPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecPackageGroupByArgs['orderBy'] }
        : { orderBy?: SpecPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecPackage model
   */
  readonly fields: SpecPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecPackage model
   */
  interface SpecPackageFieldRefs {
    readonly id: FieldRef<"SpecPackage", 'String'>
    readonly projectId: FieldRef<"SpecPackage", 'String'>
    readonly name: FieldRef<"SpecPackage", 'String'>
    readonly skus: FieldRef<"SpecPackage", 'String[]'>
    readonly zipUrl: FieldRef<"SpecPackage", 'String'>
    readonly generatedAt: FieldRef<"SpecPackage", 'DateTime'>
    readonly createdAt: FieldRef<"SpecPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpecPackage findUnique
   */
  export type SpecPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * Filter, which SpecPackage to fetch.
     */
    where: SpecPackageWhereUniqueInput
  }

  /**
   * SpecPackage findUniqueOrThrow
   */
  export type SpecPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * Filter, which SpecPackage to fetch.
     */
    where: SpecPackageWhereUniqueInput
  }

  /**
   * SpecPackage findFirst
   */
  export type SpecPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * Filter, which SpecPackage to fetch.
     */
    where?: SpecPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecPackages to fetch.
     */
    orderBy?: SpecPackageOrderByWithRelationInput | SpecPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecPackages.
     */
    cursor?: SpecPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecPackages.
     */
    distinct?: SpecPackageScalarFieldEnum | SpecPackageScalarFieldEnum[]
  }

  /**
   * SpecPackage findFirstOrThrow
   */
  export type SpecPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * Filter, which SpecPackage to fetch.
     */
    where?: SpecPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecPackages to fetch.
     */
    orderBy?: SpecPackageOrderByWithRelationInput | SpecPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecPackages.
     */
    cursor?: SpecPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecPackages.
     */
    distinct?: SpecPackageScalarFieldEnum | SpecPackageScalarFieldEnum[]
  }

  /**
   * SpecPackage findMany
   */
  export type SpecPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * Filter, which SpecPackages to fetch.
     */
    where?: SpecPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecPackages to fetch.
     */
    orderBy?: SpecPackageOrderByWithRelationInput | SpecPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecPackages.
     */
    cursor?: SpecPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecPackages.
     */
    skip?: number
    distinct?: SpecPackageScalarFieldEnum | SpecPackageScalarFieldEnum[]
  }

  /**
   * SpecPackage create
   */
  export type SpecPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecPackage.
     */
    data: XOR<SpecPackageCreateInput, SpecPackageUncheckedCreateInput>
  }

  /**
   * SpecPackage createMany
   */
  export type SpecPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecPackages.
     */
    data: SpecPackageCreateManyInput | SpecPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecPackage createManyAndReturn
   */
  export type SpecPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * The data used to create many SpecPackages.
     */
    data: SpecPackageCreateManyInput | SpecPackageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecPackage update
   */
  export type SpecPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecPackage.
     */
    data: XOR<SpecPackageUpdateInput, SpecPackageUncheckedUpdateInput>
    /**
     * Choose, which SpecPackage to update.
     */
    where: SpecPackageWhereUniqueInput
  }

  /**
   * SpecPackage updateMany
   */
  export type SpecPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecPackages.
     */
    data: XOR<SpecPackageUpdateManyMutationInput, SpecPackageUncheckedUpdateManyInput>
    /**
     * Filter which SpecPackages to update
     */
    where?: SpecPackageWhereInput
  }

  /**
   * SpecPackage upsert
   */
  export type SpecPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecPackage to update in case it exists.
     */
    where: SpecPackageWhereUniqueInput
    /**
     * In case the SpecPackage found by the `where` argument doesn't exist, create a new SpecPackage with this data.
     */
    create: XOR<SpecPackageCreateInput, SpecPackageUncheckedCreateInput>
    /**
     * In case the SpecPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecPackageUpdateInput, SpecPackageUncheckedUpdateInput>
  }

  /**
   * SpecPackage delete
   */
  export type SpecPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
    /**
     * Filter which SpecPackage to delete.
     */
    where: SpecPackageWhereUniqueInput
  }

  /**
   * SpecPackage deleteMany
   */
  export type SpecPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecPackages to delete
     */
    where?: SpecPackageWhereInput
  }

  /**
   * SpecPackage without action
   */
  export type SpecPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecPackage
     */
    select?: SpecPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecPackage
     */
    omit?: SpecPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecPackageInclude<ExtArgs> | null
  }


  /**
   * Model TaxExemptDocument
   */

  export type AggregateTaxExemptDocument = {
    _count: TaxExemptDocumentCountAggregateOutputType | null
    _min: TaxExemptDocumentMinAggregateOutputType | null
    _max: TaxExemptDocumentMaxAggregateOutputType | null
  }

  export type TaxExemptDocumentMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    state: string | null
    documentUrl: string | null
    documentType: string | null
    status: $Enums.TaxExemptStatus | null
    expiresAt: Date | null
    reviewedById: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxExemptDocumentMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    state: string | null
    documentUrl: string | null
    documentType: string | null
    status: $Enums.TaxExemptStatus | null
    expiresAt: Date | null
    reviewedById: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxExemptDocumentCountAggregateOutputType = {
    id: number
    customerId: number
    state: number
    documentUrl: number
    documentType: number
    status: number
    expiresAt: number
    reviewedById: number
    reviewedAt: number
    rejectionReason: number
    auditLog: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxExemptDocumentMinAggregateInputType = {
    id?: true
    customerId?: true
    state?: true
    documentUrl?: true
    documentType?: true
    status?: true
    expiresAt?: true
    reviewedById?: true
    reviewedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxExemptDocumentMaxAggregateInputType = {
    id?: true
    customerId?: true
    state?: true
    documentUrl?: true
    documentType?: true
    status?: true
    expiresAt?: true
    reviewedById?: true
    reviewedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxExemptDocumentCountAggregateInputType = {
    id?: true
    customerId?: true
    state?: true
    documentUrl?: true
    documentType?: true
    status?: true
    expiresAt?: true
    reviewedById?: true
    reviewedAt?: true
    rejectionReason?: true
    auditLog?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxExemptDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxExemptDocument to aggregate.
     */
    where?: TaxExemptDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxExemptDocuments to fetch.
     */
    orderBy?: TaxExemptDocumentOrderByWithRelationInput | TaxExemptDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxExemptDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxExemptDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxExemptDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxExemptDocuments
    **/
    _count?: true | TaxExemptDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxExemptDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxExemptDocumentMaxAggregateInputType
  }

  export type GetTaxExemptDocumentAggregateType<T extends TaxExemptDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxExemptDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxExemptDocument[P]>
      : GetScalarType<T[P], AggregateTaxExemptDocument[P]>
  }




  export type TaxExemptDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxExemptDocumentWhereInput
    orderBy?: TaxExemptDocumentOrderByWithAggregationInput | TaxExemptDocumentOrderByWithAggregationInput[]
    by: TaxExemptDocumentScalarFieldEnum[] | TaxExemptDocumentScalarFieldEnum
    having?: TaxExemptDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxExemptDocumentCountAggregateInputType | true
    _min?: TaxExemptDocumentMinAggregateInputType
    _max?: TaxExemptDocumentMaxAggregateInputType
  }

  export type TaxExemptDocumentGroupByOutputType = {
    id: string
    customerId: string
    state: string
    documentUrl: string
    documentType: string | null
    status: $Enums.TaxExemptStatus
    expiresAt: Date | null
    reviewedById: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    auditLog: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TaxExemptDocumentCountAggregateOutputType | null
    _min: TaxExemptDocumentMinAggregateOutputType | null
    _max: TaxExemptDocumentMaxAggregateOutputType | null
  }

  type GetTaxExemptDocumentGroupByPayload<T extends TaxExemptDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxExemptDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxExemptDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxExemptDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], TaxExemptDocumentGroupByOutputType[P]>
        }
      >
    >


  export type TaxExemptDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    state?: boolean
    documentUrl?: boolean
    documentType?: boolean
    status?: boolean
    expiresAt?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    auditLog?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxExemptDocument"]>

  export type TaxExemptDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    state?: boolean
    documentUrl?: boolean
    documentType?: boolean
    status?: boolean
    expiresAt?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    auditLog?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxExemptDocument"]>


  export type TaxExemptDocumentSelectScalar = {
    id?: boolean
    customerId?: boolean
    state?: boolean
    documentUrl?: boolean
    documentType?: boolean
    status?: boolean
    expiresAt?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    auditLog?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxExemptDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "state" | "documentUrl" | "documentType" | "status" | "expiresAt" | "reviewedById" | "reviewedAt" | "rejectionReason" | "auditLog" | "createdAt" | "updatedAt", ExtArgs["result"]["taxExemptDocument"]>
  export type TaxExemptDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxExemptDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaxExemptDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxExemptDocument"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      state: string
      documentUrl: string
      documentType: string | null
      status: $Enums.TaxExemptStatus
      expiresAt: Date | null
      reviewedById: string | null
      reviewedAt: Date | null
      rejectionReason: string | null
      auditLog: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxExemptDocument"]>
    composites: {}
  }

  type TaxExemptDocumentGetPayload<S extends boolean | null | undefined | TaxExemptDocumentDefaultArgs> = $Result.GetResult<Prisma.$TaxExemptDocumentPayload, S>

  type TaxExemptDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxExemptDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxExemptDocumentCountAggregateInputType | true
    }

  export interface TaxExemptDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxExemptDocument'], meta: { name: 'TaxExemptDocument' } }
    /**
     * Find zero or one TaxExemptDocument that matches the filter.
     * @param {TaxExemptDocumentFindUniqueArgs} args - Arguments to find a TaxExemptDocument
     * @example
     * // Get one TaxExemptDocument
     * const taxExemptDocument = await prisma.taxExemptDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxExemptDocumentFindUniqueArgs>(args: SelectSubset<T, TaxExemptDocumentFindUniqueArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxExemptDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxExemptDocumentFindUniqueOrThrowArgs} args - Arguments to find a TaxExemptDocument
     * @example
     * // Get one TaxExemptDocument
     * const taxExemptDocument = await prisma.taxExemptDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxExemptDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxExemptDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxExemptDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxExemptDocumentFindFirstArgs} args - Arguments to find a TaxExemptDocument
     * @example
     * // Get one TaxExemptDocument
     * const taxExemptDocument = await prisma.taxExemptDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxExemptDocumentFindFirstArgs>(args?: SelectSubset<T, TaxExemptDocumentFindFirstArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxExemptDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxExemptDocumentFindFirstOrThrowArgs} args - Arguments to find a TaxExemptDocument
     * @example
     * // Get one TaxExemptDocument
     * const taxExemptDocument = await prisma.taxExemptDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxExemptDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxExemptDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxExemptDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxExemptDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxExemptDocuments
     * const taxExemptDocuments = await prisma.taxExemptDocument.findMany()
     * 
     * // Get first 10 TaxExemptDocuments
     * const taxExemptDocuments = await prisma.taxExemptDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxExemptDocumentWithIdOnly = await prisma.taxExemptDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxExemptDocumentFindManyArgs>(args?: SelectSubset<T, TaxExemptDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxExemptDocument.
     * @param {TaxExemptDocumentCreateArgs} args - Arguments to create a TaxExemptDocument.
     * @example
     * // Create one TaxExemptDocument
     * const TaxExemptDocument = await prisma.taxExemptDocument.create({
     *   data: {
     *     // ... data to create a TaxExemptDocument
     *   }
     * })
     * 
     */
    create<T extends TaxExemptDocumentCreateArgs>(args: SelectSubset<T, TaxExemptDocumentCreateArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxExemptDocuments.
     * @param {TaxExemptDocumentCreateManyArgs} args - Arguments to create many TaxExemptDocuments.
     * @example
     * // Create many TaxExemptDocuments
     * const taxExemptDocument = await prisma.taxExemptDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxExemptDocumentCreateManyArgs>(args?: SelectSubset<T, TaxExemptDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxExemptDocuments and returns the data saved in the database.
     * @param {TaxExemptDocumentCreateManyAndReturnArgs} args - Arguments to create many TaxExemptDocuments.
     * @example
     * // Create many TaxExemptDocuments
     * const taxExemptDocument = await prisma.taxExemptDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxExemptDocuments and only return the `id`
     * const taxExemptDocumentWithIdOnly = await prisma.taxExemptDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxExemptDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxExemptDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxExemptDocument.
     * @param {TaxExemptDocumentDeleteArgs} args - Arguments to delete one TaxExemptDocument.
     * @example
     * // Delete one TaxExemptDocument
     * const TaxExemptDocument = await prisma.taxExemptDocument.delete({
     *   where: {
     *     // ... filter to delete one TaxExemptDocument
     *   }
     * })
     * 
     */
    delete<T extends TaxExemptDocumentDeleteArgs>(args: SelectSubset<T, TaxExemptDocumentDeleteArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxExemptDocument.
     * @param {TaxExemptDocumentUpdateArgs} args - Arguments to update one TaxExemptDocument.
     * @example
     * // Update one TaxExemptDocument
     * const taxExemptDocument = await prisma.taxExemptDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxExemptDocumentUpdateArgs>(args: SelectSubset<T, TaxExemptDocumentUpdateArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxExemptDocuments.
     * @param {TaxExemptDocumentDeleteManyArgs} args - Arguments to filter TaxExemptDocuments to delete.
     * @example
     * // Delete a few TaxExemptDocuments
     * const { count } = await prisma.taxExemptDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxExemptDocumentDeleteManyArgs>(args?: SelectSubset<T, TaxExemptDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxExemptDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxExemptDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxExemptDocuments
     * const taxExemptDocument = await prisma.taxExemptDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxExemptDocumentUpdateManyArgs>(args: SelectSubset<T, TaxExemptDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxExemptDocument.
     * @param {TaxExemptDocumentUpsertArgs} args - Arguments to update or create a TaxExemptDocument.
     * @example
     * // Update or create a TaxExemptDocument
     * const taxExemptDocument = await prisma.taxExemptDocument.upsert({
     *   create: {
     *     // ... data to create a TaxExemptDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxExemptDocument we want to update
     *   }
     * })
     */
    upsert<T extends TaxExemptDocumentUpsertArgs>(args: SelectSubset<T, TaxExemptDocumentUpsertArgs<ExtArgs>>): Prisma__TaxExemptDocumentClient<$Result.GetResult<Prisma.$TaxExemptDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxExemptDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxExemptDocumentCountArgs} args - Arguments to filter TaxExemptDocuments to count.
     * @example
     * // Count the number of TaxExemptDocuments
     * const count = await prisma.taxExemptDocument.count({
     *   where: {
     *     // ... the filter for the TaxExemptDocuments we want to count
     *   }
     * })
    **/
    count<T extends TaxExemptDocumentCountArgs>(
      args?: Subset<T, TaxExemptDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxExemptDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxExemptDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxExemptDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxExemptDocumentAggregateArgs>(args: Subset<T, TaxExemptDocumentAggregateArgs>): Prisma.PrismaPromise<GetTaxExemptDocumentAggregateType<T>>

    /**
     * Group by TaxExemptDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxExemptDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxExemptDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxExemptDocumentGroupByArgs['orderBy'] }
        : { orderBy?: TaxExemptDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxExemptDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxExemptDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxExemptDocument model
   */
  readonly fields: TaxExemptDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxExemptDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxExemptDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxExemptDocument model
   */
  interface TaxExemptDocumentFieldRefs {
    readonly id: FieldRef<"TaxExemptDocument", 'String'>
    readonly customerId: FieldRef<"TaxExemptDocument", 'String'>
    readonly state: FieldRef<"TaxExemptDocument", 'String'>
    readonly documentUrl: FieldRef<"TaxExemptDocument", 'String'>
    readonly documentType: FieldRef<"TaxExemptDocument", 'String'>
    readonly status: FieldRef<"TaxExemptDocument", 'TaxExemptStatus'>
    readonly expiresAt: FieldRef<"TaxExemptDocument", 'DateTime'>
    readonly reviewedById: FieldRef<"TaxExemptDocument", 'String'>
    readonly reviewedAt: FieldRef<"TaxExemptDocument", 'DateTime'>
    readonly rejectionReason: FieldRef<"TaxExemptDocument", 'String'>
    readonly auditLog: FieldRef<"TaxExemptDocument", 'Json'>
    readonly createdAt: FieldRef<"TaxExemptDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxExemptDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxExemptDocument findUnique
   */
  export type TaxExemptDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TaxExemptDocument to fetch.
     */
    where: TaxExemptDocumentWhereUniqueInput
  }

  /**
   * TaxExemptDocument findUniqueOrThrow
   */
  export type TaxExemptDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TaxExemptDocument to fetch.
     */
    where: TaxExemptDocumentWhereUniqueInput
  }

  /**
   * TaxExemptDocument findFirst
   */
  export type TaxExemptDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TaxExemptDocument to fetch.
     */
    where?: TaxExemptDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxExemptDocuments to fetch.
     */
    orderBy?: TaxExemptDocumentOrderByWithRelationInput | TaxExemptDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxExemptDocuments.
     */
    cursor?: TaxExemptDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxExemptDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxExemptDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxExemptDocuments.
     */
    distinct?: TaxExemptDocumentScalarFieldEnum | TaxExemptDocumentScalarFieldEnum[]
  }

  /**
   * TaxExemptDocument findFirstOrThrow
   */
  export type TaxExemptDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TaxExemptDocument to fetch.
     */
    where?: TaxExemptDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxExemptDocuments to fetch.
     */
    orderBy?: TaxExemptDocumentOrderByWithRelationInput | TaxExemptDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxExemptDocuments.
     */
    cursor?: TaxExemptDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxExemptDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxExemptDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxExemptDocuments.
     */
    distinct?: TaxExemptDocumentScalarFieldEnum | TaxExemptDocumentScalarFieldEnum[]
  }

  /**
   * TaxExemptDocument findMany
   */
  export type TaxExemptDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TaxExemptDocuments to fetch.
     */
    where?: TaxExemptDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxExemptDocuments to fetch.
     */
    orderBy?: TaxExemptDocumentOrderByWithRelationInput | TaxExemptDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxExemptDocuments.
     */
    cursor?: TaxExemptDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxExemptDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxExemptDocuments.
     */
    skip?: number
    distinct?: TaxExemptDocumentScalarFieldEnum | TaxExemptDocumentScalarFieldEnum[]
  }

  /**
   * TaxExemptDocument create
   */
  export type TaxExemptDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxExemptDocument.
     */
    data: XOR<TaxExemptDocumentCreateInput, TaxExemptDocumentUncheckedCreateInput>
  }

  /**
   * TaxExemptDocument createMany
   */
  export type TaxExemptDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxExemptDocuments.
     */
    data: TaxExemptDocumentCreateManyInput | TaxExemptDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxExemptDocument createManyAndReturn
   */
  export type TaxExemptDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many TaxExemptDocuments.
     */
    data: TaxExemptDocumentCreateManyInput | TaxExemptDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxExemptDocument update
   */
  export type TaxExemptDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxExemptDocument.
     */
    data: XOR<TaxExemptDocumentUpdateInput, TaxExemptDocumentUncheckedUpdateInput>
    /**
     * Choose, which TaxExemptDocument to update.
     */
    where: TaxExemptDocumentWhereUniqueInput
  }

  /**
   * TaxExemptDocument updateMany
   */
  export type TaxExemptDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxExemptDocuments.
     */
    data: XOR<TaxExemptDocumentUpdateManyMutationInput, TaxExemptDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TaxExemptDocuments to update
     */
    where?: TaxExemptDocumentWhereInput
  }

  /**
   * TaxExemptDocument upsert
   */
  export type TaxExemptDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxExemptDocument to update in case it exists.
     */
    where: TaxExemptDocumentWhereUniqueInput
    /**
     * In case the TaxExemptDocument found by the `where` argument doesn't exist, create a new TaxExemptDocument with this data.
     */
    create: XOR<TaxExemptDocumentCreateInput, TaxExemptDocumentUncheckedCreateInput>
    /**
     * In case the TaxExemptDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxExemptDocumentUpdateInput, TaxExemptDocumentUncheckedUpdateInput>
  }

  /**
   * TaxExemptDocument delete
   */
  export type TaxExemptDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
    /**
     * Filter which TaxExemptDocument to delete.
     */
    where: TaxExemptDocumentWhereUniqueInput
  }

  /**
   * TaxExemptDocument deleteMany
   */
  export type TaxExemptDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxExemptDocuments to delete
     */
    where?: TaxExemptDocumentWhereInput
  }

  /**
   * TaxExemptDocument without action
   */
  export type TaxExemptDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxExemptDocument
     */
    select?: TaxExemptDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxExemptDocument
     */
    omit?: TaxExemptDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxExemptDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _avg: PartnerAvgAggregateOutputType | null
    _sum: PartnerSumAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerAvgAggregateOutputType = {
    commissionRate: Decimal | null
  }

  export type PartnerSumAggregateOutputType = {
    commissionRate: Decimal | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    partnerType: $Enums.PartnerType | null
    companyName: string | null
    status: $Enums.PartnerStatus | null
    referralCode: string | null
    commissionRate: Decimal | null
    approvedAt: Date | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    partnerType: $Enums.PartnerType | null
    companyName: string | null
    status: $Enums.PartnerStatus | null
    referralCode: string | null
    commissionRate: Decimal | null
    approvedAt: Date | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    userId: number
    partnerType: number
    companyName: number
    status: number
    referralCode: number
    commissionRate: number
    approvedAt: number
    approvedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerAvgAggregateInputType = {
    commissionRate?: true
  }

  export type PartnerSumAggregateInputType = {
    commissionRate?: true
  }

  export type PartnerMinAggregateInputType = {
    id?: true
    userId?: true
    partnerType?: true
    companyName?: true
    status?: true
    referralCode?: true
    commissionRate?: true
    approvedAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    userId?: true
    partnerType?: true
    companyName?: true
    status?: true
    referralCode?: true
    commissionRate?: true
    approvedAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    userId?: true
    partnerType?: true
    companyName?: true
    status?: true
    referralCode?: true
    commissionRate?: true
    approvedAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _avg?: PartnerAvgAggregateInputType
    _sum?: PartnerSumAggregateInputType
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    userId: string
    partnerType: $Enums.PartnerType
    companyName: string
    status: $Enums.PartnerStatus
    referralCode: string
    commissionRate: Decimal | null
    approvedAt: Date | null
    approvedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PartnerCountAggregateOutputType | null
    _avg: PartnerAvgAggregateOutputType | null
    _sum: PartnerSumAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    partnerType?: boolean
    companyName?: boolean
    status?: boolean
    referralCode?: boolean
    commissionRate?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attributions?: boolean | Partner$attributionsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    partnerType?: boolean
    companyName?: boolean
    status?: boolean
    referralCode?: boolean
    commissionRate?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["partner"]>


  export type PartnerSelectScalar = {
    id?: boolean
    userId?: boolean
    partnerType?: boolean
    companyName?: boolean
    status?: boolean
    referralCode?: boolean
    commissionRate?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "partnerType" | "companyName" | "status" | "referralCode" | "commissionRate" | "approvedAt" | "approvedById" | "createdAt" | "updatedAt", ExtArgs["result"]["partner"]>
  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributions?: boolean | Partner$attributionsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      attributions: Prisma.$PartnerAttributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      partnerType: $Enums.PartnerType
      companyName: string
      status: $Enums.PartnerStatus
      referralCode: string
      commissionRate: Prisma.Decimal | null
      approvedAt: Date | null
      approvedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attributions<T extends Partner$attributionsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$attributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly userId: FieldRef<"Partner", 'String'>
    readonly partnerType: FieldRef<"Partner", 'PartnerType'>
    readonly companyName: FieldRef<"Partner", 'String'>
    readonly status: FieldRef<"Partner", 'PartnerStatus'>
    readonly referralCode: FieldRef<"Partner", 'String'>
    readonly commissionRate: FieldRef<"Partner", 'Decimal'>
    readonly approvedAt: FieldRef<"Partner", 'DateTime'>
    readonly approvedById: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner.attributions
   */
  export type Partner$attributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    where?: PartnerAttributionWhereInput
    orderBy?: PartnerAttributionOrderByWithRelationInput | PartnerAttributionOrderByWithRelationInput[]
    cursor?: PartnerAttributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerAttributionScalarFieldEnum | PartnerAttributionScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model PartnerAttribution
   */

  export type AggregatePartnerAttribution = {
    _count: PartnerAttributionCountAggregateOutputType | null
    _avg: PartnerAttributionAvgAggregateOutputType | null
    _sum: PartnerAttributionSumAggregateOutputType | null
    _min: PartnerAttributionMinAggregateOutputType | null
    _max: PartnerAttributionMaxAggregateOutputType | null
  }

  export type PartnerAttributionAvgAggregateOutputType = {
    orderTotal: Decimal | null
    commission: Decimal | null
  }

  export type PartnerAttributionSumAggregateOutputType = {
    orderTotal: Decimal | null
    commission: Decimal | null
  }

  export type PartnerAttributionMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    bcOrderId: string | null
    orderTotal: Decimal | null
    commission: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PartnerAttributionMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    bcOrderId: string | null
    orderTotal: Decimal | null
    commission: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PartnerAttributionCountAggregateOutputType = {
    id: number
    partnerId: number
    bcOrderId: number
    orderTotal: number
    commission: number
    paidAt: number
    createdAt: number
    _all: number
  }


  export type PartnerAttributionAvgAggregateInputType = {
    orderTotal?: true
    commission?: true
  }

  export type PartnerAttributionSumAggregateInputType = {
    orderTotal?: true
    commission?: true
  }

  export type PartnerAttributionMinAggregateInputType = {
    id?: true
    partnerId?: true
    bcOrderId?: true
    orderTotal?: true
    commission?: true
    paidAt?: true
    createdAt?: true
  }

  export type PartnerAttributionMaxAggregateInputType = {
    id?: true
    partnerId?: true
    bcOrderId?: true
    orderTotal?: true
    commission?: true
    paidAt?: true
    createdAt?: true
  }

  export type PartnerAttributionCountAggregateInputType = {
    id?: true
    partnerId?: true
    bcOrderId?: true
    orderTotal?: true
    commission?: true
    paidAt?: true
    createdAt?: true
    _all?: true
  }

  export type PartnerAttributionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerAttribution to aggregate.
     */
    where?: PartnerAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerAttributions to fetch.
     */
    orderBy?: PartnerAttributionOrderByWithRelationInput | PartnerAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerAttributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerAttributions
    **/
    _count?: true | PartnerAttributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerAttributionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerAttributionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerAttributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerAttributionMaxAggregateInputType
  }

  export type GetPartnerAttributionAggregateType<T extends PartnerAttributionAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerAttribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerAttribution[P]>
      : GetScalarType<T[P], AggregatePartnerAttribution[P]>
  }




  export type PartnerAttributionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerAttributionWhereInput
    orderBy?: PartnerAttributionOrderByWithAggregationInput | PartnerAttributionOrderByWithAggregationInput[]
    by: PartnerAttributionScalarFieldEnum[] | PartnerAttributionScalarFieldEnum
    having?: PartnerAttributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerAttributionCountAggregateInputType | true
    _avg?: PartnerAttributionAvgAggregateInputType
    _sum?: PartnerAttributionSumAggregateInputType
    _min?: PartnerAttributionMinAggregateInputType
    _max?: PartnerAttributionMaxAggregateInputType
  }

  export type PartnerAttributionGroupByOutputType = {
    id: string
    partnerId: string
    bcOrderId: string
    orderTotal: Decimal
    commission: Decimal
    paidAt: Date | null
    createdAt: Date
    _count: PartnerAttributionCountAggregateOutputType | null
    _avg: PartnerAttributionAvgAggregateOutputType | null
    _sum: PartnerAttributionSumAggregateOutputType | null
    _min: PartnerAttributionMinAggregateOutputType | null
    _max: PartnerAttributionMaxAggregateOutputType | null
  }

  type GetPartnerAttributionGroupByPayload<T extends PartnerAttributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerAttributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerAttributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerAttributionGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerAttributionGroupByOutputType[P]>
        }
      >
    >


  export type PartnerAttributionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    bcOrderId?: boolean
    orderTotal?: boolean
    commission?: boolean
    paidAt?: boolean
    createdAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerAttribution"]>

  export type PartnerAttributionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    bcOrderId?: boolean
    orderTotal?: boolean
    commission?: boolean
    paidAt?: boolean
    createdAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerAttribution"]>


  export type PartnerAttributionSelectScalar = {
    id?: boolean
    partnerId?: boolean
    bcOrderId?: boolean
    orderTotal?: boolean
    commission?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }

  export type PartnerAttributionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partnerId" | "bcOrderId" | "orderTotal" | "commission" | "paidAt" | "createdAt", ExtArgs["result"]["partnerAttribution"]>
  export type PartnerAttributionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerAttributionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PartnerAttributionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerAttribution"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      bcOrderId: string
      orderTotal: Prisma.Decimal
      commission: Prisma.Decimal
      paidAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["partnerAttribution"]>
    composites: {}
  }

  type PartnerAttributionGetPayload<S extends boolean | null | undefined | PartnerAttributionDefaultArgs> = $Result.GetResult<Prisma.$PartnerAttributionPayload, S>

  type PartnerAttributionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerAttributionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerAttributionCountAggregateInputType | true
    }

  export interface PartnerAttributionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerAttribution'], meta: { name: 'PartnerAttribution' } }
    /**
     * Find zero or one PartnerAttribution that matches the filter.
     * @param {PartnerAttributionFindUniqueArgs} args - Arguments to find a PartnerAttribution
     * @example
     * // Get one PartnerAttribution
     * const partnerAttribution = await prisma.partnerAttribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerAttributionFindUniqueArgs>(args: SelectSubset<T, PartnerAttributionFindUniqueArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartnerAttribution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerAttributionFindUniqueOrThrowArgs} args - Arguments to find a PartnerAttribution
     * @example
     * // Get one PartnerAttribution
     * const partnerAttribution = await prisma.partnerAttribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerAttributionFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerAttributionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerAttribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAttributionFindFirstArgs} args - Arguments to find a PartnerAttribution
     * @example
     * // Get one PartnerAttribution
     * const partnerAttribution = await prisma.partnerAttribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerAttributionFindFirstArgs>(args?: SelectSubset<T, PartnerAttributionFindFirstArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerAttribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAttributionFindFirstOrThrowArgs} args - Arguments to find a PartnerAttribution
     * @example
     * // Get one PartnerAttribution
     * const partnerAttribution = await prisma.partnerAttribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerAttributionFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerAttributionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartnerAttributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAttributionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerAttributions
     * const partnerAttributions = await prisma.partnerAttribution.findMany()
     * 
     * // Get first 10 PartnerAttributions
     * const partnerAttributions = await prisma.partnerAttribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerAttributionWithIdOnly = await prisma.partnerAttribution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerAttributionFindManyArgs>(args?: SelectSubset<T, PartnerAttributionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartnerAttribution.
     * @param {PartnerAttributionCreateArgs} args - Arguments to create a PartnerAttribution.
     * @example
     * // Create one PartnerAttribution
     * const PartnerAttribution = await prisma.partnerAttribution.create({
     *   data: {
     *     // ... data to create a PartnerAttribution
     *   }
     * })
     * 
     */
    create<T extends PartnerAttributionCreateArgs>(args: SelectSubset<T, PartnerAttributionCreateArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartnerAttributions.
     * @param {PartnerAttributionCreateManyArgs} args - Arguments to create many PartnerAttributions.
     * @example
     * // Create many PartnerAttributions
     * const partnerAttribution = await prisma.partnerAttribution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerAttributionCreateManyArgs>(args?: SelectSubset<T, PartnerAttributionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerAttributions and returns the data saved in the database.
     * @param {PartnerAttributionCreateManyAndReturnArgs} args - Arguments to create many PartnerAttributions.
     * @example
     * // Create many PartnerAttributions
     * const partnerAttribution = await prisma.partnerAttribution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerAttributions and only return the `id`
     * const partnerAttributionWithIdOnly = await prisma.partnerAttribution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerAttributionCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerAttributionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartnerAttribution.
     * @param {PartnerAttributionDeleteArgs} args - Arguments to delete one PartnerAttribution.
     * @example
     * // Delete one PartnerAttribution
     * const PartnerAttribution = await prisma.partnerAttribution.delete({
     *   where: {
     *     // ... filter to delete one PartnerAttribution
     *   }
     * })
     * 
     */
    delete<T extends PartnerAttributionDeleteArgs>(args: SelectSubset<T, PartnerAttributionDeleteArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartnerAttribution.
     * @param {PartnerAttributionUpdateArgs} args - Arguments to update one PartnerAttribution.
     * @example
     * // Update one PartnerAttribution
     * const partnerAttribution = await prisma.partnerAttribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerAttributionUpdateArgs>(args: SelectSubset<T, PartnerAttributionUpdateArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartnerAttributions.
     * @param {PartnerAttributionDeleteManyArgs} args - Arguments to filter PartnerAttributions to delete.
     * @example
     * // Delete a few PartnerAttributions
     * const { count } = await prisma.partnerAttribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerAttributionDeleteManyArgs>(args?: SelectSubset<T, PartnerAttributionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerAttributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAttributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerAttributions
     * const partnerAttribution = await prisma.partnerAttribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerAttributionUpdateManyArgs>(args: SelectSubset<T, PartnerAttributionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartnerAttribution.
     * @param {PartnerAttributionUpsertArgs} args - Arguments to update or create a PartnerAttribution.
     * @example
     * // Update or create a PartnerAttribution
     * const partnerAttribution = await prisma.partnerAttribution.upsert({
     *   create: {
     *     // ... data to create a PartnerAttribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerAttribution we want to update
     *   }
     * })
     */
    upsert<T extends PartnerAttributionUpsertArgs>(args: SelectSubset<T, PartnerAttributionUpsertArgs<ExtArgs>>): Prisma__PartnerAttributionClient<$Result.GetResult<Prisma.$PartnerAttributionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartnerAttributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAttributionCountArgs} args - Arguments to filter PartnerAttributions to count.
     * @example
     * // Count the number of PartnerAttributions
     * const count = await prisma.partnerAttribution.count({
     *   where: {
     *     // ... the filter for the PartnerAttributions we want to count
     *   }
     * })
    **/
    count<T extends PartnerAttributionCountArgs>(
      args?: Subset<T, PartnerAttributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerAttributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerAttribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAttributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAttributionAggregateArgs>(args: Subset<T, PartnerAttributionAggregateArgs>): Prisma.PrismaPromise<GetPartnerAttributionAggregateType<T>>

    /**
     * Group by PartnerAttribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAttributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerAttributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerAttributionGroupByArgs['orderBy'] }
        : { orderBy?: PartnerAttributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerAttributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerAttributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerAttribution model
   */
  readonly fields: PartnerAttributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerAttribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerAttributionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerAttribution model
   */
  interface PartnerAttributionFieldRefs {
    readonly id: FieldRef<"PartnerAttribution", 'String'>
    readonly partnerId: FieldRef<"PartnerAttribution", 'String'>
    readonly bcOrderId: FieldRef<"PartnerAttribution", 'String'>
    readonly orderTotal: FieldRef<"PartnerAttribution", 'Decimal'>
    readonly commission: FieldRef<"PartnerAttribution", 'Decimal'>
    readonly paidAt: FieldRef<"PartnerAttribution", 'DateTime'>
    readonly createdAt: FieldRef<"PartnerAttribution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerAttribution findUnique
   */
  export type PartnerAttributionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * Filter, which PartnerAttribution to fetch.
     */
    where: PartnerAttributionWhereUniqueInput
  }

  /**
   * PartnerAttribution findUniqueOrThrow
   */
  export type PartnerAttributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * Filter, which PartnerAttribution to fetch.
     */
    where: PartnerAttributionWhereUniqueInput
  }

  /**
   * PartnerAttribution findFirst
   */
  export type PartnerAttributionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * Filter, which PartnerAttribution to fetch.
     */
    where?: PartnerAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerAttributions to fetch.
     */
    orderBy?: PartnerAttributionOrderByWithRelationInput | PartnerAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerAttributions.
     */
    cursor?: PartnerAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerAttributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerAttributions.
     */
    distinct?: PartnerAttributionScalarFieldEnum | PartnerAttributionScalarFieldEnum[]
  }

  /**
   * PartnerAttribution findFirstOrThrow
   */
  export type PartnerAttributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * Filter, which PartnerAttribution to fetch.
     */
    where?: PartnerAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerAttributions to fetch.
     */
    orderBy?: PartnerAttributionOrderByWithRelationInput | PartnerAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerAttributions.
     */
    cursor?: PartnerAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerAttributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerAttributions.
     */
    distinct?: PartnerAttributionScalarFieldEnum | PartnerAttributionScalarFieldEnum[]
  }

  /**
   * PartnerAttribution findMany
   */
  export type PartnerAttributionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * Filter, which PartnerAttributions to fetch.
     */
    where?: PartnerAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerAttributions to fetch.
     */
    orderBy?: PartnerAttributionOrderByWithRelationInput | PartnerAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerAttributions.
     */
    cursor?: PartnerAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerAttributions.
     */
    skip?: number
    distinct?: PartnerAttributionScalarFieldEnum | PartnerAttributionScalarFieldEnum[]
  }

  /**
   * PartnerAttribution create
   */
  export type PartnerAttributionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerAttribution.
     */
    data: XOR<PartnerAttributionCreateInput, PartnerAttributionUncheckedCreateInput>
  }

  /**
   * PartnerAttribution createMany
   */
  export type PartnerAttributionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerAttributions.
     */
    data: PartnerAttributionCreateManyInput | PartnerAttributionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PartnerAttribution createManyAndReturn
   */
  export type PartnerAttributionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * The data used to create many PartnerAttributions.
     */
    data: PartnerAttributionCreateManyInput | PartnerAttributionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerAttribution update
   */
  export type PartnerAttributionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerAttribution.
     */
    data: XOR<PartnerAttributionUpdateInput, PartnerAttributionUncheckedUpdateInput>
    /**
     * Choose, which PartnerAttribution to update.
     */
    where: PartnerAttributionWhereUniqueInput
  }

  /**
   * PartnerAttribution updateMany
   */
  export type PartnerAttributionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerAttributions.
     */
    data: XOR<PartnerAttributionUpdateManyMutationInput, PartnerAttributionUncheckedUpdateManyInput>
    /**
     * Filter which PartnerAttributions to update
     */
    where?: PartnerAttributionWhereInput
  }

  /**
   * PartnerAttribution upsert
   */
  export type PartnerAttributionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerAttribution to update in case it exists.
     */
    where: PartnerAttributionWhereUniqueInput
    /**
     * In case the PartnerAttribution found by the `where` argument doesn't exist, create a new PartnerAttribution with this data.
     */
    create: XOR<PartnerAttributionCreateInput, PartnerAttributionUncheckedCreateInput>
    /**
     * In case the PartnerAttribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerAttributionUpdateInput, PartnerAttributionUncheckedUpdateInput>
  }

  /**
   * PartnerAttribution delete
   */
  export type PartnerAttributionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
    /**
     * Filter which PartnerAttribution to delete.
     */
    where: PartnerAttributionWhereUniqueInput
  }

  /**
   * PartnerAttribution deleteMany
   */
  export type PartnerAttributionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerAttributions to delete
     */
    where?: PartnerAttributionWhereInput
  }

  /**
   * PartnerAttribution without action
   */
  export type PartnerAttributionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerAttribution
     */
    select?: PartnerAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerAttribution
     */
    omit?: PartnerAttributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerAttributionInclude<ExtArgs> | null
  }


  /**
   * Model QboSyncLog
   */

  export type AggregateQboSyncLog = {
    _count: QboSyncLogCountAggregateOutputType | null
    _avg: QboSyncLogAvgAggregateOutputType | null
    _sum: QboSyncLogSumAggregateOutputType | null
    _min: QboSyncLogMinAggregateOutputType | null
    _max: QboSyncLogMaxAggregateOutputType | null
  }

  export type QboSyncLogAvgAggregateOutputType = {
    attempts: number | null
  }

  export type QboSyncLogSumAggregateOutputType = {
    attempts: number | null
  }

  export type QboSyncLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    sourceId: string | null
    qboId: string | null
    status: $Enums.SyncStatus | null
    attempts: number | null
    lastError: string | null
    lastAttemptAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QboSyncLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    sourceId: string | null
    qboId: string | null
    status: $Enums.SyncStatus | null
    attempts: number | null
    lastError: string | null
    lastAttemptAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QboSyncLogCountAggregateOutputType = {
    id: number
    entityType: number
    sourceId: number
    qboId: number
    status: number
    attempts: number
    lastError: number
    lastAttemptAt: number
    payload: number
    response: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QboSyncLogAvgAggregateInputType = {
    attempts?: true
  }

  export type QboSyncLogSumAggregateInputType = {
    attempts?: true
  }

  export type QboSyncLogMinAggregateInputType = {
    id?: true
    entityType?: true
    sourceId?: true
    qboId?: true
    status?: true
    attempts?: true
    lastError?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QboSyncLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    sourceId?: true
    qboId?: true
    status?: true
    attempts?: true
    lastError?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QboSyncLogCountAggregateInputType = {
    id?: true
    entityType?: true
    sourceId?: true
    qboId?: true
    status?: true
    attempts?: true
    lastError?: true
    lastAttemptAt?: true
    payload?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QboSyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QboSyncLog to aggregate.
     */
    where?: QboSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QboSyncLogs to fetch.
     */
    orderBy?: QboSyncLogOrderByWithRelationInput | QboSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QboSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QboSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QboSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QboSyncLogs
    **/
    _count?: true | QboSyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QboSyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QboSyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QboSyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QboSyncLogMaxAggregateInputType
  }

  export type GetQboSyncLogAggregateType<T extends QboSyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateQboSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQboSyncLog[P]>
      : GetScalarType<T[P], AggregateQboSyncLog[P]>
  }




  export type QboSyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QboSyncLogWhereInput
    orderBy?: QboSyncLogOrderByWithAggregationInput | QboSyncLogOrderByWithAggregationInput[]
    by: QboSyncLogScalarFieldEnum[] | QboSyncLogScalarFieldEnum
    having?: QboSyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QboSyncLogCountAggregateInputType | true
    _avg?: QboSyncLogAvgAggregateInputType
    _sum?: QboSyncLogSumAggregateInputType
    _min?: QboSyncLogMinAggregateInputType
    _max?: QboSyncLogMaxAggregateInputType
  }

  export type QboSyncLogGroupByOutputType = {
    id: string
    entityType: string
    sourceId: string
    qboId: string | null
    status: $Enums.SyncStatus
    attempts: number
    lastError: string | null
    lastAttemptAt: Date | null
    payload: JsonValue | null
    response: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QboSyncLogCountAggregateOutputType | null
    _avg: QboSyncLogAvgAggregateOutputType | null
    _sum: QboSyncLogSumAggregateOutputType | null
    _min: QboSyncLogMinAggregateOutputType | null
    _max: QboSyncLogMaxAggregateOutputType | null
  }

  type GetQboSyncLogGroupByPayload<T extends QboSyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QboSyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QboSyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QboSyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], QboSyncLogGroupByOutputType[P]>
        }
      >
    >


  export type QboSyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    sourceId?: boolean
    qboId?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    lastAttemptAt?: boolean
    payload?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["qboSyncLog"]>

  export type QboSyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    sourceId?: boolean
    qboId?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    lastAttemptAt?: boolean
    payload?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["qboSyncLog"]>


  export type QboSyncLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    sourceId?: boolean
    qboId?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    lastAttemptAt?: boolean
    payload?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QboSyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "sourceId" | "qboId" | "status" | "attempts" | "lastError" | "lastAttemptAt" | "payload" | "response" | "createdAt" | "updatedAt", ExtArgs["result"]["qboSyncLog"]>

  export type $QboSyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QboSyncLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      sourceId: string
      qboId: string | null
      status: $Enums.SyncStatus
      attempts: number
      lastError: string | null
      lastAttemptAt: Date | null
      payload: Prisma.JsonValue | null
      response: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qboSyncLog"]>
    composites: {}
  }

  type QboSyncLogGetPayload<S extends boolean | null | undefined | QboSyncLogDefaultArgs> = $Result.GetResult<Prisma.$QboSyncLogPayload, S>

  type QboSyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QboSyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QboSyncLogCountAggregateInputType | true
    }

  export interface QboSyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QboSyncLog'], meta: { name: 'QboSyncLog' } }
    /**
     * Find zero or one QboSyncLog that matches the filter.
     * @param {QboSyncLogFindUniqueArgs} args - Arguments to find a QboSyncLog
     * @example
     * // Get one QboSyncLog
     * const qboSyncLog = await prisma.qboSyncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QboSyncLogFindUniqueArgs>(args: SelectSubset<T, QboSyncLogFindUniqueArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QboSyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QboSyncLogFindUniqueOrThrowArgs} args - Arguments to find a QboSyncLog
     * @example
     * // Get one QboSyncLog
     * const qboSyncLog = await prisma.qboSyncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QboSyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, QboSyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QboSyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QboSyncLogFindFirstArgs} args - Arguments to find a QboSyncLog
     * @example
     * // Get one QboSyncLog
     * const qboSyncLog = await prisma.qboSyncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QboSyncLogFindFirstArgs>(args?: SelectSubset<T, QboSyncLogFindFirstArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QboSyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QboSyncLogFindFirstOrThrowArgs} args - Arguments to find a QboSyncLog
     * @example
     * // Get one QboSyncLog
     * const qboSyncLog = await prisma.qboSyncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QboSyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, QboSyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QboSyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QboSyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QboSyncLogs
     * const qboSyncLogs = await prisma.qboSyncLog.findMany()
     * 
     * // Get first 10 QboSyncLogs
     * const qboSyncLogs = await prisma.qboSyncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qboSyncLogWithIdOnly = await prisma.qboSyncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QboSyncLogFindManyArgs>(args?: SelectSubset<T, QboSyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QboSyncLog.
     * @param {QboSyncLogCreateArgs} args - Arguments to create a QboSyncLog.
     * @example
     * // Create one QboSyncLog
     * const QboSyncLog = await prisma.qboSyncLog.create({
     *   data: {
     *     // ... data to create a QboSyncLog
     *   }
     * })
     * 
     */
    create<T extends QboSyncLogCreateArgs>(args: SelectSubset<T, QboSyncLogCreateArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QboSyncLogs.
     * @param {QboSyncLogCreateManyArgs} args - Arguments to create many QboSyncLogs.
     * @example
     * // Create many QboSyncLogs
     * const qboSyncLog = await prisma.qboSyncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QboSyncLogCreateManyArgs>(args?: SelectSubset<T, QboSyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QboSyncLogs and returns the data saved in the database.
     * @param {QboSyncLogCreateManyAndReturnArgs} args - Arguments to create many QboSyncLogs.
     * @example
     * // Create many QboSyncLogs
     * const qboSyncLog = await prisma.qboSyncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QboSyncLogs and only return the `id`
     * const qboSyncLogWithIdOnly = await prisma.qboSyncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QboSyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, QboSyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QboSyncLog.
     * @param {QboSyncLogDeleteArgs} args - Arguments to delete one QboSyncLog.
     * @example
     * // Delete one QboSyncLog
     * const QboSyncLog = await prisma.qboSyncLog.delete({
     *   where: {
     *     // ... filter to delete one QboSyncLog
     *   }
     * })
     * 
     */
    delete<T extends QboSyncLogDeleteArgs>(args: SelectSubset<T, QboSyncLogDeleteArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QboSyncLog.
     * @param {QboSyncLogUpdateArgs} args - Arguments to update one QboSyncLog.
     * @example
     * // Update one QboSyncLog
     * const qboSyncLog = await prisma.qboSyncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QboSyncLogUpdateArgs>(args: SelectSubset<T, QboSyncLogUpdateArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QboSyncLogs.
     * @param {QboSyncLogDeleteManyArgs} args - Arguments to filter QboSyncLogs to delete.
     * @example
     * // Delete a few QboSyncLogs
     * const { count } = await prisma.qboSyncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QboSyncLogDeleteManyArgs>(args?: SelectSubset<T, QboSyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QboSyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QboSyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QboSyncLogs
     * const qboSyncLog = await prisma.qboSyncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QboSyncLogUpdateManyArgs>(args: SelectSubset<T, QboSyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QboSyncLog.
     * @param {QboSyncLogUpsertArgs} args - Arguments to update or create a QboSyncLog.
     * @example
     * // Update or create a QboSyncLog
     * const qboSyncLog = await prisma.qboSyncLog.upsert({
     *   create: {
     *     // ... data to create a QboSyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QboSyncLog we want to update
     *   }
     * })
     */
    upsert<T extends QboSyncLogUpsertArgs>(args: SelectSubset<T, QboSyncLogUpsertArgs<ExtArgs>>): Prisma__QboSyncLogClient<$Result.GetResult<Prisma.$QboSyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QboSyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QboSyncLogCountArgs} args - Arguments to filter QboSyncLogs to count.
     * @example
     * // Count the number of QboSyncLogs
     * const count = await prisma.qboSyncLog.count({
     *   where: {
     *     // ... the filter for the QboSyncLogs we want to count
     *   }
     * })
    **/
    count<T extends QboSyncLogCountArgs>(
      args?: Subset<T, QboSyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QboSyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QboSyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QboSyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QboSyncLogAggregateArgs>(args: Subset<T, QboSyncLogAggregateArgs>): Prisma.PrismaPromise<GetQboSyncLogAggregateType<T>>

    /**
     * Group by QboSyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QboSyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QboSyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QboSyncLogGroupByArgs['orderBy'] }
        : { orderBy?: QboSyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QboSyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQboSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QboSyncLog model
   */
  readonly fields: QboSyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QboSyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QboSyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QboSyncLog model
   */
  interface QboSyncLogFieldRefs {
    readonly id: FieldRef<"QboSyncLog", 'String'>
    readonly entityType: FieldRef<"QboSyncLog", 'String'>
    readonly sourceId: FieldRef<"QboSyncLog", 'String'>
    readonly qboId: FieldRef<"QboSyncLog", 'String'>
    readonly status: FieldRef<"QboSyncLog", 'SyncStatus'>
    readonly attempts: FieldRef<"QboSyncLog", 'Int'>
    readonly lastError: FieldRef<"QboSyncLog", 'String'>
    readonly lastAttemptAt: FieldRef<"QboSyncLog", 'DateTime'>
    readonly payload: FieldRef<"QboSyncLog", 'Json'>
    readonly response: FieldRef<"QboSyncLog", 'Json'>
    readonly createdAt: FieldRef<"QboSyncLog", 'DateTime'>
    readonly updatedAt: FieldRef<"QboSyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QboSyncLog findUnique
   */
  export type QboSyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which QboSyncLog to fetch.
     */
    where: QboSyncLogWhereUniqueInput
  }

  /**
   * QboSyncLog findUniqueOrThrow
   */
  export type QboSyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which QboSyncLog to fetch.
     */
    where: QboSyncLogWhereUniqueInput
  }

  /**
   * QboSyncLog findFirst
   */
  export type QboSyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which QboSyncLog to fetch.
     */
    where?: QboSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QboSyncLogs to fetch.
     */
    orderBy?: QboSyncLogOrderByWithRelationInput | QboSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QboSyncLogs.
     */
    cursor?: QboSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QboSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QboSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QboSyncLogs.
     */
    distinct?: QboSyncLogScalarFieldEnum | QboSyncLogScalarFieldEnum[]
  }

  /**
   * QboSyncLog findFirstOrThrow
   */
  export type QboSyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which QboSyncLog to fetch.
     */
    where?: QboSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QboSyncLogs to fetch.
     */
    orderBy?: QboSyncLogOrderByWithRelationInput | QboSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QboSyncLogs.
     */
    cursor?: QboSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QboSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QboSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QboSyncLogs.
     */
    distinct?: QboSyncLogScalarFieldEnum | QboSyncLogScalarFieldEnum[]
  }

  /**
   * QboSyncLog findMany
   */
  export type QboSyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which QboSyncLogs to fetch.
     */
    where?: QboSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QboSyncLogs to fetch.
     */
    orderBy?: QboSyncLogOrderByWithRelationInput | QboSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QboSyncLogs.
     */
    cursor?: QboSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QboSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QboSyncLogs.
     */
    skip?: number
    distinct?: QboSyncLogScalarFieldEnum | QboSyncLogScalarFieldEnum[]
  }

  /**
   * QboSyncLog create
   */
  export type QboSyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * The data needed to create a QboSyncLog.
     */
    data: XOR<QboSyncLogCreateInput, QboSyncLogUncheckedCreateInput>
  }

  /**
   * QboSyncLog createMany
   */
  export type QboSyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QboSyncLogs.
     */
    data: QboSyncLogCreateManyInput | QboSyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QboSyncLog createManyAndReturn
   */
  export type QboSyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many QboSyncLogs.
     */
    data: QboSyncLogCreateManyInput | QboSyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QboSyncLog update
   */
  export type QboSyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * The data needed to update a QboSyncLog.
     */
    data: XOR<QboSyncLogUpdateInput, QboSyncLogUncheckedUpdateInput>
    /**
     * Choose, which QboSyncLog to update.
     */
    where: QboSyncLogWhereUniqueInput
  }

  /**
   * QboSyncLog updateMany
   */
  export type QboSyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QboSyncLogs.
     */
    data: XOR<QboSyncLogUpdateManyMutationInput, QboSyncLogUncheckedUpdateManyInput>
    /**
     * Filter which QboSyncLogs to update
     */
    where?: QboSyncLogWhereInput
  }

  /**
   * QboSyncLog upsert
   */
  export type QboSyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * The filter to search for the QboSyncLog to update in case it exists.
     */
    where: QboSyncLogWhereUniqueInput
    /**
     * In case the QboSyncLog found by the `where` argument doesn't exist, create a new QboSyncLog with this data.
     */
    create: XOR<QboSyncLogCreateInput, QboSyncLogUncheckedCreateInput>
    /**
     * In case the QboSyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QboSyncLogUpdateInput, QboSyncLogUncheckedUpdateInput>
  }

  /**
   * QboSyncLog delete
   */
  export type QboSyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
    /**
     * Filter which QboSyncLog to delete.
     */
    where: QboSyncLogWhereUniqueInput
  }

  /**
   * QboSyncLog deleteMany
   */
  export type QboSyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QboSyncLogs to delete
     */
    where?: QboSyncLogWhereInput
  }

  /**
   * QboSyncLog without action
   */
  export type QboSyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QboSyncLog
     */
    select?: QboSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QboSyncLog
     */
    omit?: QboSyncLogOmit<ExtArgs> | null
  }


  /**
   * Model ShippingSyncLog
   */

  export type AggregateShippingSyncLog = {
    _count: ShippingSyncLogCountAggregateOutputType | null
    _avg: ShippingSyncLogAvgAggregateOutputType | null
    _sum: ShippingSyncLogSumAggregateOutputType | null
    _min: ShippingSyncLogMinAggregateOutputType | null
    _max: ShippingSyncLogMaxAggregateOutputType | null
  }

  export type ShippingSyncLogAvgAggregateOutputType = {
    attempts: number | null
  }

  export type ShippingSyncLogSumAggregateOutputType = {
    attempts: number | null
  }

  export type ShippingSyncLogMinAggregateOutputType = {
    id: string | null
    bcOrderId: string | null
    shipmentId: string | null
    carrier: string | null
    trackingNumber: string | null
    status: $Enums.SyncStatus | null
    attempts: number | null
    lastError: string | null
    lastAttemptAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingSyncLogMaxAggregateOutputType = {
    id: string | null
    bcOrderId: string | null
    shipmentId: string | null
    carrier: string | null
    trackingNumber: string | null
    status: $Enums.SyncStatus | null
    attempts: number | null
    lastError: string | null
    lastAttemptAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingSyncLogCountAggregateOutputType = {
    id: number
    bcOrderId: number
    shipmentId: number
    carrier: number
    trackingNumber: number
    status: number
    attempts: number
    lastError: number
    lastAttemptAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingSyncLogAvgAggregateInputType = {
    attempts?: true
  }

  export type ShippingSyncLogSumAggregateInputType = {
    attempts?: true
  }

  export type ShippingSyncLogMinAggregateInputType = {
    id?: true
    bcOrderId?: true
    shipmentId?: true
    carrier?: true
    trackingNumber?: true
    status?: true
    attempts?: true
    lastError?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingSyncLogMaxAggregateInputType = {
    id?: true
    bcOrderId?: true
    shipmentId?: true
    carrier?: true
    trackingNumber?: true
    status?: true
    attempts?: true
    lastError?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingSyncLogCountAggregateInputType = {
    id?: true
    bcOrderId?: true
    shipmentId?: true
    carrier?: true
    trackingNumber?: true
    status?: true
    attempts?: true
    lastError?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingSyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingSyncLog to aggregate.
     */
    where?: ShippingSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingSyncLogs to fetch.
     */
    orderBy?: ShippingSyncLogOrderByWithRelationInput | ShippingSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingSyncLogs
    **/
    _count?: true | ShippingSyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingSyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingSyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingSyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingSyncLogMaxAggregateInputType
  }

  export type GetShippingSyncLogAggregateType<T extends ShippingSyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingSyncLog[P]>
      : GetScalarType<T[P], AggregateShippingSyncLog[P]>
  }




  export type ShippingSyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingSyncLogWhereInput
    orderBy?: ShippingSyncLogOrderByWithAggregationInput | ShippingSyncLogOrderByWithAggregationInput[]
    by: ShippingSyncLogScalarFieldEnum[] | ShippingSyncLogScalarFieldEnum
    having?: ShippingSyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingSyncLogCountAggregateInputType | true
    _avg?: ShippingSyncLogAvgAggregateInputType
    _sum?: ShippingSyncLogSumAggregateInputType
    _min?: ShippingSyncLogMinAggregateInputType
    _max?: ShippingSyncLogMaxAggregateInputType
  }

  export type ShippingSyncLogGroupByOutputType = {
    id: string
    bcOrderId: string
    shipmentId: string | null
    carrier: string | null
    trackingNumber: string | null
    status: $Enums.SyncStatus
    attempts: number
    lastError: string | null
    lastAttemptAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ShippingSyncLogCountAggregateOutputType | null
    _avg: ShippingSyncLogAvgAggregateOutputType | null
    _sum: ShippingSyncLogSumAggregateOutputType | null
    _min: ShippingSyncLogMinAggregateOutputType | null
    _max: ShippingSyncLogMaxAggregateOutputType | null
  }

  type GetShippingSyncLogGroupByPayload<T extends ShippingSyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingSyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingSyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingSyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingSyncLogGroupByOutputType[P]>
        }
      >
    >


  export type ShippingSyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bcOrderId?: boolean
    shipmentId?: boolean
    carrier?: boolean
    trackingNumber?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    lastAttemptAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shippingSyncLog"]>

  export type ShippingSyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bcOrderId?: boolean
    shipmentId?: boolean
    carrier?: boolean
    trackingNumber?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    lastAttemptAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shippingSyncLog"]>


  export type ShippingSyncLogSelectScalar = {
    id?: boolean
    bcOrderId?: boolean
    shipmentId?: boolean
    carrier?: boolean
    trackingNumber?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    lastAttemptAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShippingSyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bcOrderId" | "shipmentId" | "carrier" | "trackingNumber" | "status" | "attempts" | "lastError" | "lastAttemptAt" | "createdAt" | "updatedAt", ExtArgs["result"]["shippingSyncLog"]>

  export type $ShippingSyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingSyncLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bcOrderId: string
      shipmentId: string | null
      carrier: string | null
      trackingNumber: string | null
      status: $Enums.SyncStatus
      attempts: number
      lastError: string | null
      lastAttemptAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shippingSyncLog"]>
    composites: {}
  }

  type ShippingSyncLogGetPayload<S extends boolean | null | undefined | ShippingSyncLogDefaultArgs> = $Result.GetResult<Prisma.$ShippingSyncLogPayload, S>

  type ShippingSyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShippingSyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShippingSyncLogCountAggregateInputType | true
    }

  export interface ShippingSyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingSyncLog'], meta: { name: 'ShippingSyncLog' } }
    /**
     * Find zero or one ShippingSyncLog that matches the filter.
     * @param {ShippingSyncLogFindUniqueArgs} args - Arguments to find a ShippingSyncLog
     * @example
     * // Get one ShippingSyncLog
     * const shippingSyncLog = await prisma.shippingSyncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShippingSyncLogFindUniqueArgs>(args: SelectSubset<T, ShippingSyncLogFindUniqueArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShippingSyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShippingSyncLogFindUniqueOrThrowArgs} args - Arguments to find a ShippingSyncLog
     * @example
     * // Get one ShippingSyncLog
     * const shippingSyncLog = await prisma.shippingSyncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShippingSyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ShippingSyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingSyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingSyncLogFindFirstArgs} args - Arguments to find a ShippingSyncLog
     * @example
     * // Get one ShippingSyncLog
     * const shippingSyncLog = await prisma.shippingSyncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShippingSyncLogFindFirstArgs>(args?: SelectSubset<T, ShippingSyncLogFindFirstArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingSyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingSyncLogFindFirstOrThrowArgs} args - Arguments to find a ShippingSyncLog
     * @example
     * // Get one ShippingSyncLog
     * const shippingSyncLog = await prisma.shippingSyncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShippingSyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ShippingSyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShippingSyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingSyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingSyncLogs
     * const shippingSyncLogs = await prisma.shippingSyncLog.findMany()
     * 
     * // Get first 10 ShippingSyncLogs
     * const shippingSyncLogs = await prisma.shippingSyncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingSyncLogWithIdOnly = await prisma.shippingSyncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShippingSyncLogFindManyArgs>(args?: SelectSubset<T, ShippingSyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShippingSyncLog.
     * @param {ShippingSyncLogCreateArgs} args - Arguments to create a ShippingSyncLog.
     * @example
     * // Create one ShippingSyncLog
     * const ShippingSyncLog = await prisma.shippingSyncLog.create({
     *   data: {
     *     // ... data to create a ShippingSyncLog
     *   }
     * })
     * 
     */
    create<T extends ShippingSyncLogCreateArgs>(args: SelectSubset<T, ShippingSyncLogCreateArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShippingSyncLogs.
     * @param {ShippingSyncLogCreateManyArgs} args - Arguments to create many ShippingSyncLogs.
     * @example
     * // Create many ShippingSyncLogs
     * const shippingSyncLog = await prisma.shippingSyncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShippingSyncLogCreateManyArgs>(args?: SelectSubset<T, ShippingSyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShippingSyncLogs and returns the data saved in the database.
     * @param {ShippingSyncLogCreateManyAndReturnArgs} args - Arguments to create many ShippingSyncLogs.
     * @example
     * // Create many ShippingSyncLogs
     * const shippingSyncLog = await prisma.shippingSyncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShippingSyncLogs and only return the `id`
     * const shippingSyncLogWithIdOnly = await prisma.shippingSyncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShippingSyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ShippingSyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShippingSyncLog.
     * @param {ShippingSyncLogDeleteArgs} args - Arguments to delete one ShippingSyncLog.
     * @example
     * // Delete one ShippingSyncLog
     * const ShippingSyncLog = await prisma.shippingSyncLog.delete({
     *   where: {
     *     // ... filter to delete one ShippingSyncLog
     *   }
     * })
     * 
     */
    delete<T extends ShippingSyncLogDeleteArgs>(args: SelectSubset<T, ShippingSyncLogDeleteArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShippingSyncLog.
     * @param {ShippingSyncLogUpdateArgs} args - Arguments to update one ShippingSyncLog.
     * @example
     * // Update one ShippingSyncLog
     * const shippingSyncLog = await prisma.shippingSyncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShippingSyncLogUpdateArgs>(args: SelectSubset<T, ShippingSyncLogUpdateArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShippingSyncLogs.
     * @param {ShippingSyncLogDeleteManyArgs} args - Arguments to filter ShippingSyncLogs to delete.
     * @example
     * // Delete a few ShippingSyncLogs
     * const { count } = await prisma.shippingSyncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShippingSyncLogDeleteManyArgs>(args?: SelectSubset<T, ShippingSyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingSyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingSyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingSyncLogs
     * const shippingSyncLog = await prisma.shippingSyncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShippingSyncLogUpdateManyArgs>(args: SelectSubset<T, ShippingSyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShippingSyncLog.
     * @param {ShippingSyncLogUpsertArgs} args - Arguments to update or create a ShippingSyncLog.
     * @example
     * // Update or create a ShippingSyncLog
     * const shippingSyncLog = await prisma.shippingSyncLog.upsert({
     *   create: {
     *     // ... data to create a ShippingSyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingSyncLog we want to update
     *   }
     * })
     */
    upsert<T extends ShippingSyncLogUpsertArgs>(args: SelectSubset<T, ShippingSyncLogUpsertArgs<ExtArgs>>): Prisma__ShippingSyncLogClient<$Result.GetResult<Prisma.$ShippingSyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShippingSyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingSyncLogCountArgs} args - Arguments to filter ShippingSyncLogs to count.
     * @example
     * // Count the number of ShippingSyncLogs
     * const count = await prisma.shippingSyncLog.count({
     *   where: {
     *     // ... the filter for the ShippingSyncLogs we want to count
     *   }
     * })
    **/
    count<T extends ShippingSyncLogCountArgs>(
      args?: Subset<T, ShippingSyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingSyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingSyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingSyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingSyncLogAggregateArgs>(args: Subset<T, ShippingSyncLogAggregateArgs>): Prisma.PrismaPromise<GetShippingSyncLogAggregateType<T>>

    /**
     * Group by ShippingSyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingSyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingSyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingSyncLogGroupByArgs['orderBy'] }
        : { orderBy?: ShippingSyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingSyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingSyncLog model
   */
  readonly fields: ShippingSyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingSyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingSyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShippingSyncLog model
   */
  interface ShippingSyncLogFieldRefs {
    readonly id: FieldRef<"ShippingSyncLog", 'String'>
    readonly bcOrderId: FieldRef<"ShippingSyncLog", 'String'>
    readonly shipmentId: FieldRef<"ShippingSyncLog", 'String'>
    readonly carrier: FieldRef<"ShippingSyncLog", 'String'>
    readonly trackingNumber: FieldRef<"ShippingSyncLog", 'String'>
    readonly status: FieldRef<"ShippingSyncLog", 'SyncStatus'>
    readonly attempts: FieldRef<"ShippingSyncLog", 'Int'>
    readonly lastError: FieldRef<"ShippingSyncLog", 'String'>
    readonly lastAttemptAt: FieldRef<"ShippingSyncLog", 'DateTime'>
    readonly createdAt: FieldRef<"ShippingSyncLog", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingSyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShippingSyncLog findUnique
   */
  export type ShippingSyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ShippingSyncLog to fetch.
     */
    where: ShippingSyncLogWhereUniqueInput
  }

  /**
   * ShippingSyncLog findUniqueOrThrow
   */
  export type ShippingSyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ShippingSyncLog to fetch.
     */
    where: ShippingSyncLogWhereUniqueInput
  }

  /**
   * ShippingSyncLog findFirst
   */
  export type ShippingSyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ShippingSyncLog to fetch.
     */
    where?: ShippingSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingSyncLogs to fetch.
     */
    orderBy?: ShippingSyncLogOrderByWithRelationInput | ShippingSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingSyncLogs.
     */
    cursor?: ShippingSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingSyncLogs.
     */
    distinct?: ShippingSyncLogScalarFieldEnum | ShippingSyncLogScalarFieldEnum[]
  }

  /**
   * ShippingSyncLog findFirstOrThrow
   */
  export type ShippingSyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ShippingSyncLog to fetch.
     */
    where?: ShippingSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingSyncLogs to fetch.
     */
    orderBy?: ShippingSyncLogOrderByWithRelationInput | ShippingSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingSyncLogs.
     */
    cursor?: ShippingSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingSyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingSyncLogs.
     */
    distinct?: ShippingSyncLogScalarFieldEnum | ShippingSyncLogScalarFieldEnum[]
  }

  /**
   * ShippingSyncLog findMany
   */
  export type ShippingSyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * Filter, which ShippingSyncLogs to fetch.
     */
    where?: ShippingSyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingSyncLogs to fetch.
     */
    orderBy?: ShippingSyncLogOrderByWithRelationInput | ShippingSyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingSyncLogs.
     */
    cursor?: ShippingSyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingSyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingSyncLogs.
     */
    skip?: number
    distinct?: ShippingSyncLogScalarFieldEnum | ShippingSyncLogScalarFieldEnum[]
  }

  /**
   * ShippingSyncLog create
   */
  export type ShippingSyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ShippingSyncLog.
     */
    data: XOR<ShippingSyncLogCreateInput, ShippingSyncLogUncheckedCreateInput>
  }

  /**
   * ShippingSyncLog createMany
   */
  export type ShippingSyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingSyncLogs.
     */
    data: ShippingSyncLogCreateManyInput | ShippingSyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingSyncLog createManyAndReturn
   */
  export type ShippingSyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many ShippingSyncLogs.
     */
    data: ShippingSyncLogCreateManyInput | ShippingSyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingSyncLog update
   */
  export type ShippingSyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ShippingSyncLog.
     */
    data: XOR<ShippingSyncLogUpdateInput, ShippingSyncLogUncheckedUpdateInput>
    /**
     * Choose, which ShippingSyncLog to update.
     */
    where: ShippingSyncLogWhereUniqueInput
  }

  /**
   * ShippingSyncLog updateMany
   */
  export type ShippingSyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingSyncLogs.
     */
    data: XOR<ShippingSyncLogUpdateManyMutationInput, ShippingSyncLogUncheckedUpdateManyInput>
    /**
     * Filter which ShippingSyncLogs to update
     */
    where?: ShippingSyncLogWhereInput
  }

  /**
   * ShippingSyncLog upsert
   */
  export type ShippingSyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ShippingSyncLog to update in case it exists.
     */
    where: ShippingSyncLogWhereUniqueInput
    /**
     * In case the ShippingSyncLog found by the `where` argument doesn't exist, create a new ShippingSyncLog with this data.
     */
    create: XOR<ShippingSyncLogCreateInput, ShippingSyncLogUncheckedCreateInput>
    /**
     * In case the ShippingSyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingSyncLogUpdateInput, ShippingSyncLogUncheckedUpdateInput>
  }

  /**
   * ShippingSyncLog delete
   */
  export type ShippingSyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
    /**
     * Filter which ShippingSyncLog to delete.
     */
    where: ShippingSyncLogWhereUniqueInput
  }

  /**
   * ShippingSyncLog deleteMany
   */
  export type ShippingSyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingSyncLogs to delete
     */
    where?: ShippingSyncLogWhereInput
  }

  /**
   * ShippingSyncLog without action
   */
  export type ShippingSyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingSyncLog
     */
    select?: ShippingSyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingSyncLog
     */
    omit?: ShippingSyncLogOmit<ExtArgs> | null
  }


  /**
   * Model KnowledgeBaseEntry
   */

  export type AggregateKnowledgeBaseEntry = {
    _count: KnowledgeBaseEntryCountAggregateOutputType | null
    _min: KnowledgeBaseEntryMinAggregateOutputType | null
    _max: KnowledgeBaseEntryMaxAggregateOutputType | null
  }

  export type KnowledgeBaseEntryMinAggregateOutputType = {
    id: string | null
    category: string | null
    title: string | null
    content: string | null
    sourceUrl: string | null
    embedding: Bytes | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseEntryMaxAggregateOutputType = {
    id: string | null
    category: string | null
    title: string | null
    content: string | null
    sourceUrl: string | null
    embedding: Bytes | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseEntryCountAggregateOutputType = {
    id: number
    category: number
    title: number
    content: number
    sourceUrl: number
    embedding: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeBaseEntryMinAggregateInputType = {
    id?: true
    category?: true
    title?: true
    content?: true
    sourceUrl?: true
    embedding?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseEntryMaxAggregateInputType = {
    id?: true
    category?: true
    title?: true
    content?: true
    sourceUrl?: true
    embedding?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseEntryCountAggregateInputType = {
    id?: true
    category?: true
    title?: true
    content?: true
    sourceUrl?: true
    embedding?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeBaseEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseEntry to aggregate.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBaseEntries
    **/
    _count?: true | KnowledgeBaseEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseEntryMaxAggregateInputType
  }

  export type GetKnowledgeBaseEntryAggregateType<T extends KnowledgeBaseEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBaseEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBaseEntry[P]>
      : GetScalarType<T[P], AggregateKnowledgeBaseEntry[P]>
  }




  export type KnowledgeBaseEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseEntryWhereInput
    orderBy?: KnowledgeBaseEntryOrderByWithAggregationInput | KnowledgeBaseEntryOrderByWithAggregationInput[]
    by: KnowledgeBaseEntryScalarFieldEnum[] | KnowledgeBaseEntryScalarFieldEnum
    having?: KnowledgeBaseEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseEntryCountAggregateInputType | true
    _min?: KnowledgeBaseEntryMinAggregateInputType
    _max?: KnowledgeBaseEntryMaxAggregateInputType
  }

  export type KnowledgeBaseEntryGroupByOutputType = {
    id: string
    category: string
    title: string
    content: string
    sourceUrl: string | null
    embedding: Bytes | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeBaseEntryCountAggregateOutputType | null
    _min: KnowledgeBaseEntryMinAggregateOutputType | null
    _max: KnowledgeBaseEntryMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseEntryGroupByPayload<T extends KnowledgeBaseEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseEntryGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseEntryGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    sourceUrl?: boolean
    embedding?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeBaseEntry"]>

  export type KnowledgeBaseEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    sourceUrl?: boolean
    embedding?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeBaseEntry"]>


  export type KnowledgeBaseEntrySelectScalar = {
    id?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    sourceUrl?: boolean
    embedding?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeBaseEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "title" | "content" | "sourceUrl" | "embedding" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledgeBaseEntry"]>

  export type $KnowledgeBaseEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBaseEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      title: string
      content: string
      sourceUrl: string | null
      embedding: Prisma.Bytes | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeBaseEntry"]>
    composites: {}
  }

  type KnowledgeBaseEntryGetPayload<S extends boolean | null | undefined | KnowledgeBaseEntryDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBaseEntryPayload, S>

  type KnowledgeBaseEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeBaseEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeBaseEntryCountAggregateInputType | true
    }

  export interface KnowledgeBaseEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBaseEntry'], meta: { name: 'KnowledgeBaseEntry' } }
    /**
     * Find zero or one KnowledgeBaseEntry that matches the filter.
     * @param {KnowledgeBaseEntryFindUniqueArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseEntryFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseEntryFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeBaseEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeBaseEntryFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBaseEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryFindFirstArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseEntryFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseEntryFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBaseEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeBaseEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBaseEntries
     * const knowledgeBaseEntries = await prisma.knowledgeBaseEntry.findMany()
     * 
     * // Get first 10 KnowledgeBaseEntries
     * const knowledgeBaseEntries = await prisma.knowledgeBaseEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseEntryWithIdOnly = await prisma.knowledgeBaseEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseEntryFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryCreateArgs} args - Arguments to create a KnowledgeBaseEntry.
     * @example
     * // Create one KnowledgeBaseEntry
     * const KnowledgeBaseEntry = await prisma.knowledgeBaseEntry.create({
     *   data: {
     *     // ... data to create a KnowledgeBaseEntry
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseEntryCreateArgs>(args: SelectSubset<T, KnowledgeBaseEntryCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeBaseEntries.
     * @param {KnowledgeBaseEntryCreateManyArgs} args - Arguments to create many KnowledgeBaseEntries.
     * @example
     * // Create many KnowledgeBaseEntries
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseEntryCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeBaseEntries and returns the data saved in the database.
     * @param {KnowledgeBaseEntryCreateManyAndReturnArgs} args - Arguments to create many KnowledgeBaseEntries.
     * @example
     * // Create many KnowledgeBaseEntries
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeBaseEntries and only return the `id`
     * const knowledgeBaseEntryWithIdOnly = await prisma.knowledgeBaseEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeBaseEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeBaseEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryDeleteArgs} args - Arguments to delete one KnowledgeBaseEntry.
     * @example
     * // Delete one KnowledgeBaseEntry
     * const KnowledgeBaseEntry = await prisma.knowledgeBaseEntry.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBaseEntry
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseEntryDeleteArgs>(args: SelectSubset<T, KnowledgeBaseEntryDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryUpdateArgs} args - Arguments to update one KnowledgeBaseEntry.
     * @example
     * // Update one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseEntryUpdateArgs>(args: SelectSubset<T, KnowledgeBaseEntryUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeBaseEntries.
     * @param {KnowledgeBaseEntryDeleteManyArgs} args - Arguments to filter KnowledgeBaseEntries to delete.
     * @example
     * // Delete a few KnowledgeBaseEntries
     * const { count } = await prisma.knowledgeBaseEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseEntryDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBaseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBaseEntries
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseEntryUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryUpsertArgs} args - Arguments to update or create a KnowledgeBaseEntry.
     * @example
     * // Update or create a KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBaseEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBaseEntry we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseEntryUpsertArgs>(args: SelectSubset<T, KnowledgeBaseEntryUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeBaseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryCountArgs} args - Arguments to filter KnowledgeBaseEntries to count.
     * @example
     * // Count the number of KnowledgeBaseEntries
     * const count = await prisma.knowledgeBaseEntry.count({
     *   where: {
     *     // ... the filter for the KnowledgeBaseEntries we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseEntryCountArgs>(
      args?: Subset<T, KnowledgeBaseEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBaseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseEntryAggregateArgs>(args: Subset<T, KnowledgeBaseEntryAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseEntryAggregateType<T>>

    /**
     * Group by KnowledgeBaseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseEntryGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBaseEntry model
   */
  readonly fields: KnowledgeBaseEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBaseEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBaseEntry model
   */
  interface KnowledgeBaseEntryFieldRefs {
    readonly id: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly category: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly title: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly content: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly sourceUrl: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly embedding: FieldRef<"KnowledgeBaseEntry", 'Bytes'>
    readonly isActive: FieldRef<"KnowledgeBaseEntry", 'Boolean'>
    readonly createdAt: FieldRef<"KnowledgeBaseEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeBaseEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBaseEntry findUnique
   */
  export type KnowledgeBaseEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry findUniqueOrThrow
   */
  export type KnowledgeBaseEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry findFirst
   */
  export type KnowledgeBaseEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseEntries.
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseEntries.
     */
    distinct?: KnowledgeBaseEntryScalarFieldEnum | KnowledgeBaseEntryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseEntry findFirstOrThrow
   */
  export type KnowledgeBaseEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseEntries.
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseEntries.
     */
    distinct?: KnowledgeBaseEntryScalarFieldEnum | KnowledgeBaseEntryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseEntry findMany
   */
  export type KnowledgeBaseEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntries to fetch.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBaseEntries.
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    distinct?: KnowledgeBaseEntryScalarFieldEnum | KnowledgeBaseEntryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseEntry create
   */
  export type KnowledgeBaseEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBaseEntry.
     */
    data: XOR<KnowledgeBaseEntryCreateInput, KnowledgeBaseEntryUncheckedCreateInput>
  }

  /**
   * KnowledgeBaseEntry createMany
   */
  export type KnowledgeBaseEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBaseEntries.
     */
    data: KnowledgeBaseEntryCreateManyInput | KnowledgeBaseEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBaseEntry createManyAndReturn
   */
  export type KnowledgeBaseEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeBaseEntries.
     */
    data: KnowledgeBaseEntryCreateManyInput | KnowledgeBaseEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBaseEntry update
   */
  export type KnowledgeBaseEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBaseEntry.
     */
    data: XOR<KnowledgeBaseEntryUpdateInput, KnowledgeBaseEntryUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBaseEntry to update.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry updateMany
   */
  export type KnowledgeBaseEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBaseEntries.
     */
    data: XOR<KnowledgeBaseEntryUpdateManyMutationInput, KnowledgeBaseEntryUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBaseEntries to update
     */
    where?: KnowledgeBaseEntryWhereInput
  }

  /**
   * KnowledgeBaseEntry upsert
   */
  export type KnowledgeBaseEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBaseEntry to update in case it exists.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
    /**
     * In case the KnowledgeBaseEntry found by the `where` argument doesn't exist, create a new KnowledgeBaseEntry with this data.
     */
    create: XOR<KnowledgeBaseEntryCreateInput, KnowledgeBaseEntryUncheckedCreateInput>
    /**
     * In case the KnowledgeBaseEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseEntryUpdateInput, KnowledgeBaseEntryUncheckedUpdateInput>
  }

  /**
   * KnowledgeBaseEntry delete
   */
  export type KnowledgeBaseEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
    /**
     * Filter which KnowledgeBaseEntry to delete.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry deleteMany
   */
  export type KnowledgeBaseEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseEntries to delete
     */
    where?: KnowledgeBaseEntryWhereInput
  }

  /**
   * KnowledgeBaseEntry without action
   */
  export type KnowledgeBaseEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseEntry
     */
    omit?: KnowledgeBaseEntryOmit<ExtArgs> | null
  }


  /**
   * Model AIChatLog
   */

  export type AggregateAIChatLog = {
    _count: AIChatLogCountAggregateOutputType | null
    _avg: AIChatLogAvgAggregateOutputType | null
    _sum: AIChatLogSumAggregateOutputType | null
    _min: AIChatLogMinAggregateOutputType | null
    _max: AIChatLogMaxAggregateOutputType | null
  }

  export type AIChatLogAvgAggregateOutputType = {
    feedbackRating: number | null
  }

  export type AIChatLogSumAggregateOutputType = {
    feedbackRating: number | null
  }

  export type AIChatLogMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    userMessage: string | null
    aiResponse: string | null
    handoffCaseId: string | null
    feedbackRating: number | null
    createdAt: Date | null
  }

  export type AIChatLogMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    userMessage: string | null
    aiResponse: string | null
    handoffCaseId: string | null
    feedbackRating: number | null
    createdAt: Date | null
  }

  export type AIChatLogCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    userMessage: number
    aiResponse: number
    sourcesUsed: number
    handoffCaseId: number
    feedbackRating: number
    createdAt: number
    _all: number
  }


  export type AIChatLogAvgAggregateInputType = {
    feedbackRating?: true
  }

  export type AIChatLogSumAggregateInputType = {
    feedbackRating?: true
  }

  export type AIChatLogMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    userMessage?: true
    aiResponse?: true
    handoffCaseId?: true
    feedbackRating?: true
    createdAt?: true
  }

  export type AIChatLogMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    userMessage?: true
    aiResponse?: true
    handoffCaseId?: true
    feedbackRating?: true
    createdAt?: true
  }

  export type AIChatLogCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    userMessage?: true
    aiResponse?: true
    sourcesUsed?: true
    handoffCaseId?: true
    feedbackRating?: true
    createdAt?: true
    _all?: true
  }

  export type AIChatLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIChatLog to aggregate.
     */
    where?: AIChatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatLogs to fetch.
     */
    orderBy?: AIChatLogOrderByWithRelationInput | AIChatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIChatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIChatLogs
    **/
    _count?: true | AIChatLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIChatLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIChatLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIChatLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIChatLogMaxAggregateInputType
  }

  export type GetAIChatLogAggregateType<T extends AIChatLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAIChatLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIChatLog[P]>
      : GetScalarType<T[P], AggregateAIChatLog[P]>
  }




  export type AIChatLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIChatLogWhereInput
    orderBy?: AIChatLogOrderByWithAggregationInput | AIChatLogOrderByWithAggregationInput[]
    by: AIChatLogScalarFieldEnum[] | AIChatLogScalarFieldEnum
    having?: AIChatLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIChatLogCountAggregateInputType | true
    _avg?: AIChatLogAvgAggregateInputType
    _sum?: AIChatLogSumAggregateInputType
    _min?: AIChatLogMinAggregateInputType
    _max?: AIChatLogMaxAggregateInputType
  }

  export type AIChatLogGroupByOutputType = {
    id: string
    sessionId: string
    userId: string | null
    userMessage: string
    aiResponse: string
    sourcesUsed: string[]
    handoffCaseId: string | null
    feedbackRating: number | null
    createdAt: Date
    _count: AIChatLogCountAggregateOutputType | null
    _avg: AIChatLogAvgAggregateOutputType | null
    _sum: AIChatLogSumAggregateOutputType | null
    _min: AIChatLogMinAggregateOutputType | null
    _max: AIChatLogMaxAggregateOutputType | null
  }

  type GetAIChatLogGroupByPayload<T extends AIChatLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIChatLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIChatLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIChatLogGroupByOutputType[P]>
            : GetScalarType<T[P], AIChatLogGroupByOutputType[P]>
        }
      >
    >


  export type AIChatLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    userMessage?: boolean
    aiResponse?: boolean
    sourcesUsed?: boolean
    handoffCaseId?: boolean
    feedbackRating?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIChatLog"]>

  export type AIChatLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    userMessage?: boolean
    aiResponse?: boolean
    sourcesUsed?: boolean
    handoffCaseId?: boolean
    feedbackRating?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIChatLog"]>


  export type AIChatLogSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    userMessage?: boolean
    aiResponse?: boolean
    sourcesUsed?: boolean
    handoffCaseId?: boolean
    feedbackRating?: boolean
    createdAt?: boolean
  }

  export type AIChatLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "userMessage" | "aiResponse" | "sourcesUsed" | "handoffCaseId" | "feedbackRating" | "createdAt", ExtArgs["result"]["aIChatLog"]>

  export type $AIChatLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIChatLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string | null
      userMessage: string
      aiResponse: string
      sourcesUsed: string[]
      handoffCaseId: string | null
      feedbackRating: number | null
      createdAt: Date
    }, ExtArgs["result"]["aIChatLog"]>
    composites: {}
  }

  type AIChatLogGetPayload<S extends boolean | null | undefined | AIChatLogDefaultArgs> = $Result.GetResult<Prisma.$AIChatLogPayload, S>

  type AIChatLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIChatLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIChatLogCountAggregateInputType | true
    }

  export interface AIChatLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIChatLog'], meta: { name: 'AIChatLog' } }
    /**
     * Find zero or one AIChatLog that matches the filter.
     * @param {AIChatLogFindUniqueArgs} args - Arguments to find a AIChatLog
     * @example
     * // Get one AIChatLog
     * const aIChatLog = await prisma.aIChatLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIChatLogFindUniqueArgs>(args: SelectSubset<T, AIChatLogFindUniqueArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIChatLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIChatLogFindUniqueOrThrowArgs} args - Arguments to find a AIChatLog
     * @example
     * // Get one AIChatLog
     * const aIChatLog = await prisma.aIChatLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIChatLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AIChatLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIChatLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatLogFindFirstArgs} args - Arguments to find a AIChatLog
     * @example
     * // Get one AIChatLog
     * const aIChatLog = await prisma.aIChatLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIChatLogFindFirstArgs>(args?: SelectSubset<T, AIChatLogFindFirstArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIChatLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatLogFindFirstOrThrowArgs} args - Arguments to find a AIChatLog
     * @example
     * // Get one AIChatLog
     * const aIChatLog = await prisma.aIChatLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIChatLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AIChatLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIChatLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIChatLogs
     * const aIChatLogs = await prisma.aIChatLog.findMany()
     * 
     * // Get first 10 AIChatLogs
     * const aIChatLogs = await prisma.aIChatLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIChatLogWithIdOnly = await prisma.aIChatLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIChatLogFindManyArgs>(args?: SelectSubset<T, AIChatLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIChatLog.
     * @param {AIChatLogCreateArgs} args - Arguments to create a AIChatLog.
     * @example
     * // Create one AIChatLog
     * const AIChatLog = await prisma.aIChatLog.create({
     *   data: {
     *     // ... data to create a AIChatLog
     *   }
     * })
     * 
     */
    create<T extends AIChatLogCreateArgs>(args: SelectSubset<T, AIChatLogCreateArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIChatLogs.
     * @param {AIChatLogCreateManyArgs} args - Arguments to create many AIChatLogs.
     * @example
     * // Create many AIChatLogs
     * const aIChatLog = await prisma.aIChatLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIChatLogCreateManyArgs>(args?: SelectSubset<T, AIChatLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIChatLogs and returns the data saved in the database.
     * @param {AIChatLogCreateManyAndReturnArgs} args - Arguments to create many AIChatLogs.
     * @example
     * // Create many AIChatLogs
     * const aIChatLog = await prisma.aIChatLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIChatLogs and only return the `id`
     * const aIChatLogWithIdOnly = await prisma.aIChatLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIChatLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AIChatLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIChatLog.
     * @param {AIChatLogDeleteArgs} args - Arguments to delete one AIChatLog.
     * @example
     * // Delete one AIChatLog
     * const AIChatLog = await prisma.aIChatLog.delete({
     *   where: {
     *     // ... filter to delete one AIChatLog
     *   }
     * })
     * 
     */
    delete<T extends AIChatLogDeleteArgs>(args: SelectSubset<T, AIChatLogDeleteArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIChatLog.
     * @param {AIChatLogUpdateArgs} args - Arguments to update one AIChatLog.
     * @example
     * // Update one AIChatLog
     * const aIChatLog = await prisma.aIChatLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIChatLogUpdateArgs>(args: SelectSubset<T, AIChatLogUpdateArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIChatLogs.
     * @param {AIChatLogDeleteManyArgs} args - Arguments to filter AIChatLogs to delete.
     * @example
     * // Delete a few AIChatLogs
     * const { count } = await prisma.aIChatLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIChatLogDeleteManyArgs>(args?: SelectSubset<T, AIChatLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIChatLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIChatLogs
     * const aIChatLog = await prisma.aIChatLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIChatLogUpdateManyArgs>(args: SelectSubset<T, AIChatLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIChatLog.
     * @param {AIChatLogUpsertArgs} args - Arguments to update or create a AIChatLog.
     * @example
     * // Update or create a AIChatLog
     * const aIChatLog = await prisma.aIChatLog.upsert({
     *   create: {
     *     // ... data to create a AIChatLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIChatLog we want to update
     *   }
     * })
     */
    upsert<T extends AIChatLogUpsertArgs>(args: SelectSubset<T, AIChatLogUpsertArgs<ExtArgs>>): Prisma__AIChatLogClient<$Result.GetResult<Prisma.$AIChatLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIChatLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatLogCountArgs} args - Arguments to filter AIChatLogs to count.
     * @example
     * // Count the number of AIChatLogs
     * const count = await prisma.aIChatLog.count({
     *   where: {
     *     // ... the filter for the AIChatLogs we want to count
     *   }
     * })
    **/
    count<T extends AIChatLogCountArgs>(
      args?: Subset<T, AIChatLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIChatLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIChatLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIChatLogAggregateArgs>(args: Subset<T, AIChatLogAggregateArgs>): Prisma.PrismaPromise<GetAIChatLogAggregateType<T>>

    /**
     * Group by AIChatLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIChatLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIChatLogGroupByArgs['orderBy'] }
        : { orderBy?: AIChatLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIChatLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIChatLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIChatLog model
   */
  readonly fields: AIChatLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIChatLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIChatLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIChatLog model
   */
  interface AIChatLogFieldRefs {
    readonly id: FieldRef<"AIChatLog", 'String'>
    readonly sessionId: FieldRef<"AIChatLog", 'String'>
    readonly userId: FieldRef<"AIChatLog", 'String'>
    readonly userMessage: FieldRef<"AIChatLog", 'String'>
    readonly aiResponse: FieldRef<"AIChatLog", 'String'>
    readonly sourcesUsed: FieldRef<"AIChatLog", 'String[]'>
    readonly handoffCaseId: FieldRef<"AIChatLog", 'String'>
    readonly feedbackRating: FieldRef<"AIChatLog", 'Int'>
    readonly createdAt: FieldRef<"AIChatLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIChatLog findUnique
   */
  export type AIChatLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * Filter, which AIChatLog to fetch.
     */
    where: AIChatLogWhereUniqueInput
  }

  /**
   * AIChatLog findUniqueOrThrow
   */
  export type AIChatLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * Filter, which AIChatLog to fetch.
     */
    where: AIChatLogWhereUniqueInput
  }

  /**
   * AIChatLog findFirst
   */
  export type AIChatLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * Filter, which AIChatLog to fetch.
     */
    where?: AIChatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatLogs to fetch.
     */
    orderBy?: AIChatLogOrderByWithRelationInput | AIChatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIChatLogs.
     */
    cursor?: AIChatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIChatLogs.
     */
    distinct?: AIChatLogScalarFieldEnum | AIChatLogScalarFieldEnum[]
  }

  /**
   * AIChatLog findFirstOrThrow
   */
  export type AIChatLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * Filter, which AIChatLog to fetch.
     */
    where?: AIChatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatLogs to fetch.
     */
    orderBy?: AIChatLogOrderByWithRelationInput | AIChatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIChatLogs.
     */
    cursor?: AIChatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIChatLogs.
     */
    distinct?: AIChatLogScalarFieldEnum | AIChatLogScalarFieldEnum[]
  }

  /**
   * AIChatLog findMany
   */
  export type AIChatLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * Filter, which AIChatLogs to fetch.
     */
    where?: AIChatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatLogs to fetch.
     */
    orderBy?: AIChatLogOrderByWithRelationInput | AIChatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIChatLogs.
     */
    cursor?: AIChatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatLogs.
     */
    skip?: number
    distinct?: AIChatLogScalarFieldEnum | AIChatLogScalarFieldEnum[]
  }

  /**
   * AIChatLog create
   */
  export type AIChatLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AIChatLog.
     */
    data: XOR<AIChatLogCreateInput, AIChatLogUncheckedCreateInput>
  }

  /**
   * AIChatLog createMany
   */
  export type AIChatLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIChatLogs.
     */
    data: AIChatLogCreateManyInput | AIChatLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIChatLog createManyAndReturn
   */
  export type AIChatLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * The data used to create many AIChatLogs.
     */
    data: AIChatLogCreateManyInput | AIChatLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIChatLog update
   */
  export type AIChatLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AIChatLog.
     */
    data: XOR<AIChatLogUpdateInput, AIChatLogUncheckedUpdateInput>
    /**
     * Choose, which AIChatLog to update.
     */
    where: AIChatLogWhereUniqueInput
  }

  /**
   * AIChatLog updateMany
   */
  export type AIChatLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIChatLogs.
     */
    data: XOR<AIChatLogUpdateManyMutationInput, AIChatLogUncheckedUpdateManyInput>
    /**
     * Filter which AIChatLogs to update
     */
    where?: AIChatLogWhereInput
  }

  /**
   * AIChatLog upsert
   */
  export type AIChatLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AIChatLog to update in case it exists.
     */
    where: AIChatLogWhereUniqueInput
    /**
     * In case the AIChatLog found by the `where` argument doesn't exist, create a new AIChatLog with this data.
     */
    create: XOR<AIChatLogCreateInput, AIChatLogUncheckedCreateInput>
    /**
     * In case the AIChatLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIChatLogUpdateInput, AIChatLogUncheckedUpdateInput>
  }

  /**
   * AIChatLog delete
   */
  export type AIChatLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
    /**
     * Filter which AIChatLog to delete.
     */
    where: AIChatLogWhereUniqueInput
  }

  /**
   * AIChatLog deleteMany
   */
  export type AIChatLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIChatLogs to delete
     */
    where?: AIChatLogWhereInput
  }

  /**
   * AIChatLog without action
   */
  export type AIChatLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatLog
     */
    select?: AIChatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatLog
     */
    omit?: AIChatLogOmit<ExtArgs> | null
  }


  /**
   * Model CaseStudy
   */

  export type AggregateCaseStudy = {
    _count: CaseStudyCountAggregateOutputType | null
    _avg: CaseStudyAvgAggregateOutputType | null
    _sum: CaseStudySumAggregateOutputType | null
    _min: CaseStudyMinAggregateOutputType | null
    _max: CaseStudyMaxAggregateOutputType | null
  }

  export type CaseStudyAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CaseStudySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CaseStudyMinAggregateOutputType = {
    id: string | null
    slug: string | null
    category: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    product: string | null
    productSlug: string | null
    location: string | null
    youtubeId: string | null
    sortOrder: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaseStudyMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    category: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    product: string | null
    productSlug: string | null
    location: string | null
    youtubeId: string | null
    sortOrder: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaseStudyCountAggregateOutputType = {
    id: number
    slug: number
    category: number
    title: number
    subtitle: number
    description: number
    highlights: number
    product: number
    productSlug: number
    clients: number
    location: number
    images: number
    youtubeId: number
    stats: number
    sortOrder: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CaseStudyAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CaseStudySumAggregateInputType = {
    sortOrder?: true
  }

  export type CaseStudyMinAggregateInputType = {
    id?: true
    slug?: true
    category?: true
    title?: true
    subtitle?: true
    description?: true
    product?: true
    productSlug?: true
    location?: true
    youtubeId?: true
    sortOrder?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaseStudyMaxAggregateInputType = {
    id?: true
    slug?: true
    category?: true
    title?: true
    subtitle?: true
    description?: true
    product?: true
    productSlug?: true
    location?: true
    youtubeId?: true
    sortOrder?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaseStudyCountAggregateInputType = {
    id?: true
    slug?: true
    category?: true
    title?: true
    subtitle?: true
    description?: true
    highlights?: true
    product?: true
    productSlug?: true
    clients?: true
    location?: true
    images?: true
    youtubeId?: true
    stats?: true
    sortOrder?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CaseStudyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudy to aggregate.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaseStudies
    **/
    _count?: true | CaseStudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaseStudyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaseStudySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseStudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseStudyMaxAggregateInputType
  }

  export type GetCaseStudyAggregateType<T extends CaseStudyAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseStudy[P]>
      : GetScalarType<T[P], AggregateCaseStudy[P]>
  }




  export type CaseStudyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyWhereInput
    orderBy?: CaseStudyOrderByWithAggregationInput | CaseStudyOrderByWithAggregationInput[]
    by: CaseStudyScalarFieldEnum[] | CaseStudyScalarFieldEnum
    having?: CaseStudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseStudyCountAggregateInputType | true
    _avg?: CaseStudyAvgAggregateInputType
    _sum?: CaseStudySumAggregateInputType
    _min?: CaseStudyMinAggregateInputType
    _max?: CaseStudyMaxAggregateInputType
  }

  export type CaseStudyGroupByOutputType = {
    id: string
    slug: string
    category: string
    title: string
    subtitle: string | null
    description: string
    highlights: string[]
    product: string | null
    productSlug: string | null
    clients: string[]
    location: string | null
    images: string[]
    youtubeId: string | null
    stats: JsonValue | null
    sortOrder: number
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: CaseStudyCountAggregateOutputType | null
    _avg: CaseStudyAvgAggregateOutputType | null
    _sum: CaseStudySumAggregateOutputType | null
    _min: CaseStudyMinAggregateOutputType | null
    _max: CaseStudyMaxAggregateOutputType | null
  }

  type GetCaseStudyGroupByPayload<T extends CaseStudyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseStudyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseStudyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseStudyGroupByOutputType[P]>
            : GetScalarType<T[P], CaseStudyGroupByOutputType[P]>
        }
      >
    >


  export type CaseStudySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    category?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    highlights?: boolean
    product?: boolean
    productSlug?: boolean
    clients?: boolean
    location?: boolean
    images?: boolean
    youtubeId?: boolean
    stats?: boolean
    sortOrder?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["caseStudy"]>

  export type CaseStudySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    category?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    highlights?: boolean
    product?: boolean
    productSlug?: boolean
    clients?: boolean
    location?: boolean
    images?: boolean
    youtubeId?: boolean
    stats?: boolean
    sortOrder?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["caseStudy"]>


  export type CaseStudySelectScalar = {
    id?: boolean
    slug?: boolean
    category?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    highlights?: boolean
    product?: boolean
    productSlug?: boolean
    clients?: boolean
    location?: boolean
    images?: boolean
    youtubeId?: boolean
    stats?: boolean
    sortOrder?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CaseStudyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "category" | "title" | "subtitle" | "description" | "highlights" | "product" | "productSlug" | "clients" | "location" | "images" | "youtubeId" | "stats" | "sortOrder" | "isPublished" | "createdAt" | "updatedAt", ExtArgs["result"]["caseStudy"]>

  export type $CaseStudyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseStudy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      category: string
      title: string
      subtitle: string | null
      description: string
      highlights: string[]
      product: string | null
      productSlug: string | null
      clients: string[]
      location: string | null
      images: string[]
      youtubeId: string | null
      stats: Prisma.JsonValue | null
      sortOrder: number
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["caseStudy"]>
    composites: {}
  }

  type CaseStudyGetPayload<S extends boolean | null | undefined | CaseStudyDefaultArgs> = $Result.GetResult<Prisma.$CaseStudyPayload, S>

  type CaseStudyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseStudyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseStudyCountAggregateInputType | true
    }

  export interface CaseStudyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseStudy'], meta: { name: 'CaseStudy' } }
    /**
     * Find zero or one CaseStudy that matches the filter.
     * @param {CaseStudyFindUniqueArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseStudyFindUniqueArgs>(args: SelectSubset<T, CaseStudyFindUniqueArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseStudy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseStudyFindUniqueOrThrowArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseStudyFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseStudyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindFirstArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseStudyFindFirstArgs>(args?: SelectSubset<T, CaseStudyFindFirstArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindFirstOrThrowArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseStudyFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseStudyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseStudies
     * const caseStudies = await prisma.caseStudy.findMany()
     * 
     * // Get first 10 CaseStudies
     * const caseStudies = await prisma.caseStudy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseStudyWithIdOnly = await prisma.caseStudy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseStudyFindManyArgs>(args?: SelectSubset<T, CaseStudyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseStudy.
     * @param {CaseStudyCreateArgs} args - Arguments to create a CaseStudy.
     * @example
     * // Create one CaseStudy
     * const CaseStudy = await prisma.caseStudy.create({
     *   data: {
     *     // ... data to create a CaseStudy
     *   }
     * })
     * 
     */
    create<T extends CaseStudyCreateArgs>(args: SelectSubset<T, CaseStudyCreateArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseStudies.
     * @param {CaseStudyCreateManyArgs} args - Arguments to create many CaseStudies.
     * @example
     * // Create many CaseStudies
     * const caseStudy = await prisma.caseStudy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseStudyCreateManyArgs>(args?: SelectSubset<T, CaseStudyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseStudies and returns the data saved in the database.
     * @param {CaseStudyCreateManyAndReturnArgs} args - Arguments to create many CaseStudies.
     * @example
     * // Create many CaseStudies
     * const caseStudy = await prisma.caseStudy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CaseStudies and only return the `id`
     * const caseStudyWithIdOnly = await prisma.caseStudy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseStudyCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseStudyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseStudy.
     * @param {CaseStudyDeleteArgs} args - Arguments to delete one CaseStudy.
     * @example
     * // Delete one CaseStudy
     * const CaseStudy = await prisma.caseStudy.delete({
     *   where: {
     *     // ... filter to delete one CaseStudy
     *   }
     * })
     * 
     */
    delete<T extends CaseStudyDeleteArgs>(args: SelectSubset<T, CaseStudyDeleteArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseStudy.
     * @param {CaseStudyUpdateArgs} args - Arguments to update one CaseStudy.
     * @example
     * // Update one CaseStudy
     * const caseStudy = await prisma.caseStudy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseStudyUpdateArgs>(args: SelectSubset<T, CaseStudyUpdateArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseStudies.
     * @param {CaseStudyDeleteManyArgs} args - Arguments to filter CaseStudies to delete.
     * @example
     * // Delete a few CaseStudies
     * const { count } = await prisma.caseStudy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseStudyDeleteManyArgs>(args?: SelectSubset<T, CaseStudyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseStudies
     * const caseStudy = await prisma.caseStudy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseStudyUpdateManyArgs>(args: SelectSubset<T, CaseStudyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CaseStudy.
     * @param {CaseStudyUpsertArgs} args - Arguments to update or create a CaseStudy.
     * @example
     * // Update or create a CaseStudy
     * const caseStudy = await prisma.caseStudy.upsert({
     *   create: {
     *     // ... data to create a CaseStudy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseStudy we want to update
     *   }
     * })
     */
    upsert<T extends CaseStudyUpsertArgs>(args: SelectSubset<T, CaseStudyUpsertArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyCountArgs} args - Arguments to filter CaseStudies to count.
     * @example
     * // Count the number of CaseStudies
     * const count = await prisma.caseStudy.count({
     *   where: {
     *     // ... the filter for the CaseStudies we want to count
     *   }
     * })
    **/
    count<T extends CaseStudyCountArgs>(
      args?: Subset<T, CaseStudyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseStudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseStudyAggregateArgs>(args: Subset<T, CaseStudyAggregateArgs>): Prisma.PrismaPromise<GetCaseStudyAggregateType<T>>

    /**
     * Group by CaseStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseStudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseStudyGroupByArgs['orderBy'] }
        : { orderBy?: CaseStudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseStudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseStudyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseStudy model
   */
  readonly fields: CaseStudyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseStudy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseStudyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseStudy model
   */
  interface CaseStudyFieldRefs {
    readonly id: FieldRef<"CaseStudy", 'String'>
    readonly slug: FieldRef<"CaseStudy", 'String'>
    readonly category: FieldRef<"CaseStudy", 'String'>
    readonly title: FieldRef<"CaseStudy", 'String'>
    readonly subtitle: FieldRef<"CaseStudy", 'String'>
    readonly description: FieldRef<"CaseStudy", 'String'>
    readonly highlights: FieldRef<"CaseStudy", 'String[]'>
    readonly product: FieldRef<"CaseStudy", 'String'>
    readonly productSlug: FieldRef<"CaseStudy", 'String'>
    readonly clients: FieldRef<"CaseStudy", 'String[]'>
    readonly location: FieldRef<"CaseStudy", 'String'>
    readonly images: FieldRef<"CaseStudy", 'String[]'>
    readonly youtubeId: FieldRef<"CaseStudy", 'String'>
    readonly stats: FieldRef<"CaseStudy", 'Json'>
    readonly sortOrder: FieldRef<"CaseStudy", 'Int'>
    readonly isPublished: FieldRef<"CaseStudy", 'Boolean'>
    readonly createdAt: FieldRef<"CaseStudy", 'DateTime'>
    readonly updatedAt: FieldRef<"CaseStudy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CaseStudy findUnique
   */
  export type CaseStudyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy findUniqueOrThrow
   */
  export type CaseStudyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy findFirst
   */
  export type CaseStudyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseStudies.
     */
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy findFirstOrThrow
   */
  export type CaseStudyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseStudies.
     */
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy findMany
   */
  export type CaseStudyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Filter, which CaseStudies to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy create
   */
  export type CaseStudyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * The data needed to create a CaseStudy.
     */
    data: XOR<CaseStudyCreateInput, CaseStudyUncheckedCreateInput>
  }

  /**
   * CaseStudy createMany
   */
  export type CaseStudyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseStudies.
     */
    data: CaseStudyCreateManyInput | CaseStudyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseStudy createManyAndReturn
   */
  export type CaseStudyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * The data used to create many CaseStudies.
     */
    data: CaseStudyCreateManyInput | CaseStudyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseStudy update
   */
  export type CaseStudyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * The data needed to update a CaseStudy.
     */
    data: XOR<CaseStudyUpdateInput, CaseStudyUncheckedUpdateInput>
    /**
     * Choose, which CaseStudy to update.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy updateMany
   */
  export type CaseStudyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseStudies.
     */
    data: XOR<CaseStudyUpdateManyMutationInput, CaseStudyUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudies to update
     */
    where?: CaseStudyWhereInput
  }

  /**
   * CaseStudy upsert
   */
  export type CaseStudyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * The filter to search for the CaseStudy to update in case it exists.
     */
    where: CaseStudyWhereUniqueInput
    /**
     * In case the CaseStudy found by the `where` argument doesn't exist, create a new CaseStudy with this data.
     */
    create: XOR<CaseStudyCreateInput, CaseStudyUncheckedCreateInput>
    /**
     * In case the CaseStudy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseStudyUpdateInput, CaseStudyUncheckedUpdateInput>
  }

  /**
   * CaseStudy delete
   */
  export type CaseStudyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Filter which CaseStudy to delete.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy deleteMany
   */
  export type CaseStudyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudies to delete
     */
    where?: CaseStudyWhereInput
  }

  /**
   * CaseStudy without action
   */
  export type CaseStudyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    eventName: string | null
    userId: string | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    eventName: string | null
    userId: string | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    eventName: number
    userId: number
    sessionId: number
    properties: number
    createdAt: number
    _all: number
  }


  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    eventName?: true
    userId?: true
    sessionId?: true
    createdAt?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    eventName?: true
    userId?: true
    sessionId?: true
    createdAt?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    eventName?: true
    userId?: true
    sessionId?: true
    properties?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    eventName: string
    userId: string | null
    sessionId: string | null
    properties: JsonValue | null
    createdAt: Date
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventName?: boolean
    userId?: boolean
    sessionId?: boolean
    properties?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventName?: boolean
    userId?: boolean
    sessionId?: boolean
    properties?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>


  export type AnalyticsEventSelectScalar = {
    id?: boolean
    eventName?: boolean
    userId?: boolean
    sessionId?: boolean
    properties?: boolean
    createdAt?: boolean
  }

  export type AnalyticsEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventName" | "userId" | "sessionId" | "properties" | "createdAt", ExtArgs["result"]["analyticsEvent"]>

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventName: string
      userId: string | null
      sessionId: string | null
      properties: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventName: FieldRef<"AnalyticsEvent", 'String'>
    readonly userId: FieldRef<"AnalyticsEvent", 'String'>
    readonly sessionId: FieldRef<"AnalyticsEvent", 'String'>
    readonly properties: FieldRef<"AnalyticsEvent", 'Json'>
    readonly createdAt: FieldRef<"AnalyticsEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
  }


  /**
   * Model AIClientProfile
   */

  export type AggregateAIClientProfile = {
    _count: AIClientProfileCountAggregateOutputType | null
    _avg: AIClientProfileAvgAggregateOutputType | null
    _sum: AIClientProfileSumAggregateOutputType | null
    _min: AIClientProfileMinAggregateOutputType | null
    _max: AIClientProfileMaxAggregateOutputType | null
  }

  export type AIClientProfileAvgAggregateOutputType = {
    avgResponseTime: number | null
    totalMessages: number | null
    avgSentiment: number | null
    avgEngagement: number | null
  }

  export type AIClientProfileSumAggregateOutputType = {
    avgResponseTime: number | null
    totalMessages: number | null
    avgSentiment: number | null
    avgEngagement: number | null
  }

  export type AIClientProfileMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    website: string | null
    position: string | null
    industry: string | null
    companySize: $Enums.CompanySize | null
    communicationStyle: string | null
    decisionSpeed: string | null
    techLevel: string | null
    priceSensitivity: string | null
    avgResponseTime: number | null
    messageLength: string | null
    interestLevel: string | null
    budget: string | null
    timeline: string | null
    conversationSummary: string | null
    totalMessages: number | null
    avgSentiment: number | null
    avgEngagement: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActiveAt: Date | null
  }

  export type AIClientProfileMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    website: string | null
    position: string | null
    industry: string | null
    companySize: $Enums.CompanySize | null
    communicationStyle: string | null
    decisionSpeed: string | null
    techLevel: string | null
    priceSensitivity: string | null
    avgResponseTime: number | null
    messageLength: string | null
    interestLevel: string | null
    budget: string | null
    timeline: string | null
    conversationSummary: string | null
    totalMessages: number | null
    avgSentiment: number | null
    avgEngagement: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActiveAt: Date | null
  }

  export type AIClientProfileCountAggregateOutputType = {
    id: number
    sessionId: number
    name: number
    email: number
    phone: number
    company: number
    website: number
    position: number
    industry: number
    companySize: number
    communicationStyle: number
    decisionSpeed: number
    techLevel: number
    priceSensitivity: number
    avgResponseTime: number
    messageLength: number
    interestLevel: number
    painPoints: number
    budget: number
    timeline: number
    competitors: number
    conversationSummary: number
    totalMessages: number
    avgSentiment: number
    avgEngagement: number
    strategyEffectiveness: number
    createdAt: number
    updatedAt: number
    lastActiveAt: number
    _all: number
  }


  export type AIClientProfileAvgAggregateInputType = {
    avgResponseTime?: true
    totalMessages?: true
    avgSentiment?: true
    avgEngagement?: true
  }

  export type AIClientProfileSumAggregateInputType = {
    avgResponseTime?: true
    totalMessages?: true
    avgSentiment?: true
    avgEngagement?: true
  }

  export type AIClientProfileMinAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    website?: true
    position?: true
    industry?: true
    companySize?: true
    communicationStyle?: true
    decisionSpeed?: true
    techLevel?: true
    priceSensitivity?: true
    avgResponseTime?: true
    messageLength?: true
    interestLevel?: true
    budget?: true
    timeline?: true
    conversationSummary?: true
    totalMessages?: true
    avgSentiment?: true
    avgEngagement?: true
    createdAt?: true
    updatedAt?: true
    lastActiveAt?: true
  }

  export type AIClientProfileMaxAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    website?: true
    position?: true
    industry?: true
    companySize?: true
    communicationStyle?: true
    decisionSpeed?: true
    techLevel?: true
    priceSensitivity?: true
    avgResponseTime?: true
    messageLength?: true
    interestLevel?: true
    budget?: true
    timeline?: true
    conversationSummary?: true
    totalMessages?: true
    avgSentiment?: true
    avgEngagement?: true
    createdAt?: true
    updatedAt?: true
    lastActiveAt?: true
  }

  export type AIClientProfileCountAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    website?: true
    position?: true
    industry?: true
    companySize?: true
    communicationStyle?: true
    decisionSpeed?: true
    techLevel?: true
    priceSensitivity?: true
    avgResponseTime?: true
    messageLength?: true
    interestLevel?: true
    painPoints?: true
    budget?: true
    timeline?: true
    competitors?: true
    conversationSummary?: true
    totalMessages?: true
    avgSentiment?: true
    avgEngagement?: true
    strategyEffectiveness?: true
    createdAt?: true
    updatedAt?: true
    lastActiveAt?: true
    _all?: true
  }

  export type AIClientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIClientProfile to aggregate.
     */
    where?: AIClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIClientProfiles to fetch.
     */
    orderBy?: AIClientProfileOrderByWithRelationInput | AIClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIClientProfiles
    **/
    _count?: true | AIClientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIClientProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIClientProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIClientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIClientProfileMaxAggregateInputType
  }

  export type GetAIClientProfileAggregateType<T extends AIClientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAIClientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIClientProfile[P]>
      : GetScalarType<T[P], AggregateAIClientProfile[P]>
  }




  export type AIClientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIClientProfileWhereInput
    orderBy?: AIClientProfileOrderByWithAggregationInput | AIClientProfileOrderByWithAggregationInput[]
    by: AIClientProfileScalarFieldEnum[] | AIClientProfileScalarFieldEnum
    having?: AIClientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIClientProfileCountAggregateInputType | true
    _avg?: AIClientProfileAvgAggregateInputType
    _sum?: AIClientProfileSumAggregateInputType
    _min?: AIClientProfileMinAggregateInputType
    _max?: AIClientProfileMaxAggregateInputType
  }

  export type AIClientProfileGroupByOutputType = {
    id: string
    sessionId: string
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    website: string | null
    position: string | null
    industry: string | null
    companySize: $Enums.CompanySize | null
    communicationStyle: string | null
    decisionSpeed: string | null
    techLevel: string | null
    priceSensitivity: string | null
    avgResponseTime: number | null
    messageLength: string | null
    interestLevel: string | null
    painPoints: string[]
    budget: string | null
    timeline: string | null
    competitors: string[]
    conversationSummary: string | null
    totalMessages: number
    avgSentiment: number | null
    avgEngagement: number | null
    strategyEffectiveness: JsonValue | null
    createdAt: Date
    updatedAt: Date
    lastActiveAt: Date
    _count: AIClientProfileCountAggregateOutputType | null
    _avg: AIClientProfileAvgAggregateOutputType | null
    _sum: AIClientProfileSumAggregateOutputType | null
    _min: AIClientProfileMinAggregateOutputType | null
    _max: AIClientProfileMaxAggregateOutputType | null
  }

  type GetAIClientProfileGroupByPayload<T extends AIClientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIClientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIClientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIClientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AIClientProfileGroupByOutputType[P]>
        }
      >
    >


  export type AIClientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    website?: boolean
    position?: boolean
    industry?: boolean
    companySize?: boolean
    communicationStyle?: boolean
    decisionSpeed?: boolean
    techLevel?: boolean
    priceSensitivity?: boolean
    avgResponseTime?: boolean
    messageLength?: boolean
    interestLevel?: boolean
    painPoints?: boolean
    budget?: boolean
    timeline?: boolean
    competitors?: boolean
    conversationSummary?: boolean
    totalMessages?: boolean
    avgSentiment?: boolean
    avgEngagement?: boolean
    strategyEffectiveness?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActiveAt?: boolean
    conversations?: boolean | AIClientProfile$conversationsArgs<ExtArgs>
    leadData?: boolean | AIClientProfile$leadDataArgs<ExtArgs>
    _count?: boolean | AIClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIClientProfile"]>

  export type AIClientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    website?: boolean
    position?: boolean
    industry?: boolean
    companySize?: boolean
    communicationStyle?: boolean
    decisionSpeed?: boolean
    techLevel?: boolean
    priceSensitivity?: boolean
    avgResponseTime?: boolean
    messageLength?: boolean
    interestLevel?: boolean
    painPoints?: boolean
    budget?: boolean
    timeline?: boolean
    competitors?: boolean
    conversationSummary?: boolean
    totalMessages?: boolean
    avgSentiment?: boolean
    avgEngagement?: boolean
    strategyEffectiveness?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActiveAt?: boolean
  }, ExtArgs["result"]["aIClientProfile"]>


  export type AIClientProfileSelectScalar = {
    id?: boolean
    sessionId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    website?: boolean
    position?: boolean
    industry?: boolean
    companySize?: boolean
    communicationStyle?: boolean
    decisionSpeed?: boolean
    techLevel?: boolean
    priceSensitivity?: boolean
    avgResponseTime?: boolean
    messageLength?: boolean
    interestLevel?: boolean
    painPoints?: boolean
    budget?: boolean
    timeline?: boolean
    competitors?: boolean
    conversationSummary?: boolean
    totalMessages?: boolean
    avgSentiment?: boolean
    avgEngagement?: boolean
    strategyEffectiveness?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActiveAt?: boolean
  }

  export type AIClientProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "name" | "email" | "phone" | "company" | "website" | "position" | "industry" | "companySize" | "communicationStyle" | "decisionSpeed" | "techLevel" | "priceSensitivity" | "avgResponseTime" | "messageLength" | "interestLevel" | "painPoints" | "budget" | "timeline" | "competitors" | "conversationSummary" | "totalMessages" | "avgSentiment" | "avgEngagement" | "strategyEffectiveness" | "createdAt" | "updatedAt" | "lastActiveAt", ExtArgs["result"]["aIClientProfile"]>
  export type AIClientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | AIClientProfile$conversationsArgs<ExtArgs>
    leadData?: boolean | AIClientProfile$leadDataArgs<ExtArgs>
    _count?: boolean | AIClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIClientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AIClientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIClientProfile"
    objects: {
      conversations: Prisma.$AIConversationPayload<ExtArgs>[]
      leadData: Prisma.$AILeadDataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      name: string | null
      email: string | null
      phone: string | null
      company: string | null
      website: string | null
      position: string | null
      industry: string | null
      companySize: $Enums.CompanySize | null
      communicationStyle: string | null
      decisionSpeed: string | null
      techLevel: string | null
      priceSensitivity: string | null
      avgResponseTime: number | null
      messageLength: string | null
      interestLevel: string | null
      painPoints: string[]
      budget: string | null
      timeline: string | null
      competitors: string[]
      conversationSummary: string | null
      totalMessages: number
      avgSentiment: number | null
      avgEngagement: number | null
      strategyEffectiveness: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      lastActiveAt: Date
    }, ExtArgs["result"]["aIClientProfile"]>
    composites: {}
  }

  type AIClientProfileGetPayload<S extends boolean | null | undefined | AIClientProfileDefaultArgs> = $Result.GetResult<Prisma.$AIClientProfilePayload, S>

  type AIClientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIClientProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIClientProfileCountAggregateInputType | true
    }

  export interface AIClientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIClientProfile'], meta: { name: 'AIClientProfile' } }
    /**
     * Find zero or one AIClientProfile that matches the filter.
     * @param {AIClientProfileFindUniqueArgs} args - Arguments to find a AIClientProfile
     * @example
     * // Get one AIClientProfile
     * const aIClientProfile = await prisma.aIClientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIClientProfileFindUniqueArgs>(args: SelectSubset<T, AIClientProfileFindUniqueArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIClientProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIClientProfileFindUniqueOrThrowArgs} args - Arguments to find a AIClientProfile
     * @example
     * // Get one AIClientProfile
     * const aIClientProfile = await prisma.aIClientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIClientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AIClientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIClientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIClientProfileFindFirstArgs} args - Arguments to find a AIClientProfile
     * @example
     * // Get one AIClientProfile
     * const aIClientProfile = await prisma.aIClientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIClientProfileFindFirstArgs>(args?: SelectSubset<T, AIClientProfileFindFirstArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIClientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIClientProfileFindFirstOrThrowArgs} args - Arguments to find a AIClientProfile
     * @example
     * // Get one AIClientProfile
     * const aIClientProfile = await prisma.aIClientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIClientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AIClientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIClientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIClientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIClientProfiles
     * const aIClientProfiles = await prisma.aIClientProfile.findMany()
     * 
     * // Get first 10 AIClientProfiles
     * const aIClientProfiles = await prisma.aIClientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIClientProfileWithIdOnly = await prisma.aIClientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIClientProfileFindManyArgs>(args?: SelectSubset<T, AIClientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIClientProfile.
     * @param {AIClientProfileCreateArgs} args - Arguments to create a AIClientProfile.
     * @example
     * // Create one AIClientProfile
     * const AIClientProfile = await prisma.aIClientProfile.create({
     *   data: {
     *     // ... data to create a AIClientProfile
     *   }
     * })
     * 
     */
    create<T extends AIClientProfileCreateArgs>(args: SelectSubset<T, AIClientProfileCreateArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIClientProfiles.
     * @param {AIClientProfileCreateManyArgs} args - Arguments to create many AIClientProfiles.
     * @example
     * // Create many AIClientProfiles
     * const aIClientProfile = await prisma.aIClientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIClientProfileCreateManyArgs>(args?: SelectSubset<T, AIClientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIClientProfiles and returns the data saved in the database.
     * @param {AIClientProfileCreateManyAndReturnArgs} args - Arguments to create many AIClientProfiles.
     * @example
     * // Create many AIClientProfiles
     * const aIClientProfile = await prisma.aIClientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIClientProfiles and only return the `id`
     * const aIClientProfileWithIdOnly = await prisma.aIClientProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIClientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AIClientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIClientProfile.
     * @param {AIClientProfileDeleteArgs} args - Arguments to delete one AIClientProfile.
     * @example
     * // Delete one AIClientProfile
     * const AIClientProfile = await prisma.aIClientProfile.delete({
     *   where: {
     *     // ... filter to delete one AIClientProfile
     *   }
     * })
     * 
     */
    delete<T extends AIClientProfileDeleteArgs>(args: SelectSubset<T, AIClientProfileDeleteArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIClientProfile.
     * @param {AIClientProfileUpdateArgs} args - Arguments to update one AIClientProfile.
     * @example
     * // Update one AIClientProfile
     * const aIClientProfile = await prisma.aIClientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIClientProfileUpdateArgs>(args: SelectSubset<T, AIClientProfileUpdateArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIClientProfiles.
     * @param {AIClientProfileDeleteManyArgs} args - Arguments to filter AIClientProfiles to delete.
     * @example
     * // Delete a few AIClientProfiles
     * const { count } = await prisma.aIClientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIClientProfileDeleteManyArgs>(args?: SelectSubset<T, AIClientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIClientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIClientProfiles
     * const aIClientProfile = await prisma.aIClientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIClientProfileUpdateManyArgs>(args: SelectSubset<T, AIClientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIClientProfile.
     * @param {AIClientProfileUpsertArgs} args - Arguments to update or create a AIClientProfile.
     * @example
     * // Update or create a AIClientProfile
     * const aIClientProfile = await prisma.aIClientProfile.upsert({
     *   create: {
     *     // ... data to create a AIClientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIClientProfile we want to update
     *   }
     * })
     */
    upsert<T extends AIClientProfileUpsertArgs>(args: SelectSubset<T, AIClientProfileUpsertArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIClientProfileCountArgs} args - Arguments to filter AIClientProfiles to count.
     * @example
     * // Count the number of AIClientProfiles
     * const count = await prisma.aIClientProfile.count({
     *   where: {
     *     // ... the filter for the AIClientProfiles we want to count
     *   }
     * })
    **/
    count<T extends AIClientProfileCountArgs>(
      args?: Subset<T, AIClientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIClientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIClientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIClientProfileAggregateArgs>(args: Subset<T, AIClientProfileAggregateArgs>): Prisma.PrismaPromise<GetAIClientProfileAggregateType<T>>

    /**
     * Group by AIClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIClientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIClientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIClientProfileGroupByArgs['orderBy'] }
        : { orderBy?: AIClientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIClientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIClientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIClientProfile model
   */
  readonly fields: AIClientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIClientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIClientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends AIClientProfile$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, AIClientProfile$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leadData<T extends AIClientProfile$leadDataArgs<ExtArgs> = {}>(args?: Subset<T, AIClientProfile$leadDataArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIClientProfile model
   */
  interface AIClientProfileFieldRefs {
    readonly id: FieldRef<"AIClientProfile", 'String'>
    readonly sessionId: FieldRef<"AIClientProfile", 'String'>
    readonly name: FieldRef<"AIClientProfile", 'String'>
    readonly email: FieldRef<"AIClientProfile", 'String'>
    readonly phone: FieldRef<"AIClientProfile", 'String'>
    readonly company: FieldRef<"AIClientProfile", 'String'>
    readonly website: FieldRef<"AIClientProfile", 'String'>
    readonly position: FieldRef<"AIClientProfile", 'String'>
    readonly industry: FieldRef<"AIClientProfile", 'String'>
    readonly companySize: FieldRef<"AIClientProfile", 'CompanySize'>
    readonly communicationStyle: FieldRef<"AIClientProfile", 'String'>
    readonly decisionSpeed: FieldRef<"AIClientProfile", 'String'>
    readonly techLevel: FieldRef<"AIClientProfile", 'String'>
    readonly priceSensitivity: FieldRef<"AIClientProfile", 'String'>
    readonly avgResponseTime: FieldRef<"AIClientProfile", 'Int'>
    readonly messageLength: FieldRef<"AIClientProfile", 'String'>
    readonly interestLevel: FieldRef<"AIClientProfile", 'String'>
    readonly painPoints: FieldRef<"AIClientProfile", 'String[]'>
    readonly budget: FieldRef<"AIClientProfile", 'String'>
    readonly timeline: FieldRef<"AIClientProfile", 'String'>
    readonly competitors: FieldRef<"AIClientProfile", 'String[]'>
    readonly conversationSummary: FieldRef<"AIClientProfile", 'String'>
    readonly totalMessages: FieldRef<"AIClientProfile", 'Int'>
    readonly avgSentiment: FieldRef<"AIClientProfile", 'Float'>
    readonly avgEngagement: FieldRef<"AIClientProfile", 'Float'>
    readonly strategyEffectiveness: FieldRef<"AIClientProfile", 'Json'>
    readonly createdAt: FieldRef<"AIClientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AIClientProfile", 'DateTime'>
    readonly lastActiveAt: FieldRef<"AIClientProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIClientProfile findUnique
   */
  export type AIClientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which AIClientProfile to fetch.
     */
    where: AIClientProfileWhereUniqueInput
  }

  /**
   * AIClientProfile findUniqueOrThrow
   */
  export type AIClientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which AIClientProfile to fetch.
     */
    where: AIClientProfileWhereUniqueInput
  }

  /**
   * AIClientProfile findFirst
   */
  export type AIClientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which AIClientProfile to fetch.
     */
    where?: AIClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIClientProfiles to fetch.
     */
    orderBy?: AIClientProfileOrderByWithRelationInput | AIClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIClientProfiles.
     */
    cursor?: AIClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIClientProfiles.
     */
    distinct?: AIClientProfileScalarFieldEnum | AIClientProfileScalarFieldEnum[]
  }

  /**
   * AIClientProfile findFirstOrThrow
   */
  export type AIClientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which AIClientProfile to fetch.
     */
    where?: AIClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIClientProfiles to fetch.
     */
    orderBy?: AIClientProfileOrderByWithRelationInput | AIClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIClientProfiles.
     */
    cursor?: AIClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIClientProfiles.
     */
    distinct?: AIClientProfileScalarFieldEnum | AIClientProfileScalarFieldEnum[]
  }

  /**
   * AIClientProfile findMany
   */
  export type AIClientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which AIClientProfiles to fetch.
     */
    where?: AIClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIClientProfiles to fetch.
     */
    orderBy?: AIClientProfileOrderByWithRelationInput | AIClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIClientProfiles.
     */
    cursor?: AIClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIClientProfiles.
     */
    skip?: number
    distinct?: AIClientProfileScalarFieldEnum | AIClientProfileScalarFieldEnum[]
  }

  /**
   * AIClientProfile create
   */
  export type AIClientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AIClientProfile.
     */
    data: XOR<AIClientProfileCreateInput, AIClientProfileUncheckedCreateInput>
  }

  /**
   * AIClientProfile createMany
   */
  export type AIClientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIClientProfiles.
     */
    data: AIClientProfileCreateManyInput | AIClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIClientProfile createManyAndReturn
   */
  export type AIClientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * The data used to create many AIClientProfiles.
     */
    data: AIClientProfileCreateManyInput | AIClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIClientProfile update
   */
  export type AIClientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AIClientProfile.
     */
    data: XOR<AIClientProfileUpdateInput, AIClientProfileUncheckedUpdateInput>
    /**
     * Choose, which AIClientProfile to update.
     */
    where: AIClientProfileWhereUniqueInput
  }

  /**
   * AIClientProfile updateMany
   */
  export type AIClientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIClientProfiles.
     */
    data: XOR<AIClientProfileUpdateManyMutationInput, AIClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which AIClientProfiles to update
     */
    where?: AIClientProfileWhereInput
  }

  /**
   * AIClientProfile upsert
   */
  export type AIClientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AIClientProfile to update in case it exists.
     */
    where: AIClientProfileWhereUniqueInput
    /**
     * In case the AIClientProfile found by the `where` argument doesn't exist, create a new AIClientProfile with this data.
     */
    create: XOR<AIClientProfileCreateInput, AIClientProfileUncheckedCreateInput>
    /**
     * In case the AIClientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIClientProfileUpdateInput, AIClientProfileUncheckedUpdateInput>
  }

  /**
   * AIClientProfile delete
   */
  export type AIClientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
    /**
     * Filter which AIClientProfile to delete.
     */
    where: AIClientProfileWhereUniqueInput
  }

  /**
   * AIClientProfile deleteMany
   */
  export type AIClientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIClientProfiles to delete
     */
    where?: AIClientProfileWhereInput
  }

  /**
   * AIClientProfile.conversations
   */
  export type AIClientProfile$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    cursor?: AIConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIClientProfile.leadData
   */
  export type AIClientProfile$leadDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    where?: AILeadDataWhereInput
  }

  /**
   * AIClientProfile without action
   */
  export type AIClientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIClientProfile
     */
    select?: AIClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIClientProfile
     */
    omit?: AIClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIClientProfileInclude<ExtArgs> | null
  }


  /**
   * Model AIConversation
   */

  export type AggregateAIConversation = {
    _count: AIConversationCountAggregateOutputType | null
    _avg: AIConversationAvgAggregateOutputType | null
    _sum: AIConversationSumAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  export type AIConversationAvgAggregateOutputType = {
    sentiment: number | null
    engagement: number | null
    effectiveness: number | null
  }

  export type AIConversationSumAggregateOutputType = {
    sentiment: number | null
    engagement: number | null
    effectiveness: number | null
  }

  export type AIConversationMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    profileId: string | null
    role: string | null
    content: string | null
    messageType: string | null
    sentiment: number | null
    engagement: number | null
    urgency: string | null
    strategy: string | null
    effectiveness: number | null
    createdAt: Date | null
  }

  export type AIConversationMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    profileId: string | null
    role: string | null
    content: string | null
    messageType: string | null
    sentiment: number | null
    engagement: number | null
    urgency: string | null
    strategy: string | null
    effectiveness: number | null
    createdAt: Date | null
  }

  export type AIConversationCountAggregateOutputType = {
    id: number
    sessionId: number
    profileId: number
    role: number
    content: number
    messageType: number
    attachments: number
    sentiment: number
    engagement: number
    intent: number
    urgency: number
    strategy: number
    effectiveness: number
    createdAt: number
    _all: number
  }


  export type AIConversationAvgAggregateInputType = {
    sentiment?: true
    engagement?: true
    effectiveness?: true
  }

  export type AIConversationSumAggregateInputType = {
    sentiment?: true
    engagement?: true
    effectiveness?: true
  }

  export type AIConversationMinAggregateInputType = {
    id?: true
    sessionId?: true
    profileId?: true
    role?: true
    content?: true
    messageType?: true
    sentiment?: true
    engagement?: true
    urgency?: true
    strategy?: true
    effectiveness?: true
    createdAt?: true
  }

  export type AIConversationMaxAggregateInputType = {
    id?: true
    sessionId?: true
    profileId?: true
    role?: true
    content?: true
    messageType?: true
    sentiment?: true
    engagement?: true
    urgency?: true
    strategy?: true
    effectiveness?: true
    createdAt?: true
  }

  export type AIConversationCountAggregateInputType = {
    id?: true
    sessionId?: true
    profileId?: true
    role?: true
    content?: true
    messageType?: true
    attachments?: true
    sentiment?: true
    engagement?: true
    intent?: true
    urgency?: true
    strategy?: true
    effectiveness?: true
    createdAt?: true
    _all?: true
  }

  export type AIConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversation to aggregate.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIConversations
    **/
    _count?: true | AIConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIConversationMaxAggregateInputType
  }

  export type GetAIConversationAggregateType<T extends AIConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIConversation[P]>
      : GetScalarType<T[P], AggregateAIConversation[P]>
  }




  export type AIConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithAggregationInput | AIConversationOrderByWithAggregationInput[]
    by: AIConversationScalarFieldEnum[] | AIConversationScalarFieldEnum
    having?: AIConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIConversationCountAggregateInputType | true
    _avg?: AIConversationAvgAggregateInputType
    _sum?: AIConversationSumAggregateInputType
    _min?: AIConversationMinAggregateInputType
    _max?: AIConversationMaxAggregateInputType
  }

  export type AIConversationGroupByOutputType = {
    id: string
    sessionId: string
    profileId: string
    role: string
    content: string
    messageType: string | null
    attachments: JsonValue | null
    sentiment: number | null
    engagement: number | null
    intent: string[]
    urgency: string | null
    strategy: string | null
    effectiveness: number | null
    createdAt: Date
    _count: AIConversationCountAggregateOutputType | null
    _avg: AIConversationAvgAggregateOutputType | null
    _sum: AIConversationSumAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  type GetAIConversationGroupByPayload<T extends AIConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
            : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
        }
      >
    >


  export type AIConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    profileId?: boolean
    role?: boolean
    content?: boolean
    messageType?: boolean
    attachments?: boolean
    sentiment?: boolean
    engagement?: boolean
    intent?: boolean
    urgency?: boolean
    strategy?: boolean
    effectiveness?: boolean
    createdAt?: boolean
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    profileId?: boolean
    role?: boolean
    content?: boolean
    messageType?: boolean
    attachments?: boolean
    sentiment?: boolean
    engagement?: boolean
    intent?: boolean
    urgency?: boolean
    strategy?: boolean
    effectiveness?: boolean
    createdAt?: boolean
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>


  export type AIConversationSelectScalar = {
    id?: boolean
    sessionId?: boolean
    profileId?: boolean
    role?: boolean
    content?: boolean
    messageType?: boolean
    attachments?: boolean
    sentiment?: boolean
    engagement?: boolean
    intent?: boolean
    urgency?: boolean
    strategy?: boolean
    effectiveness?: boolean
    createdAt?: boolean
  }

  export type AIConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "profileId" | "role" | "content" | "messageType" | "attachments" | "sentiment" | "engagement" | "intent" | "urgency" | "strategy" | "effectiveness" | "createdAt", ExtArgs["result"]["aIConversation"]>
  export type AIConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }
  export type AIConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }

  export type $AIConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIConversation"
    objects: {
      profile: Prisma.$AIClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      profileId: string
      role: string
      content: string
      messageType: string | null
      attachments: Prisma.JsonValue | null
      sentiment: number | null
      engagement: number | null
      intent: string[]
      urgency: string | null
      strategy: string | null
      effectiveness: number | null
      createdAt: Date
    }, ExtArgs["result"]["aIConversation"]>
    composites: {}
  }

  type AIConversationGetPayload<S extends boolean | null | undefined | AIConversationDefaultArgs> = $Result.GetResult<Prisma.$AIConversationPayload, S>

  type AIConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIConversationCountAggregateInputType | true
    }

  export interface AIConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIConversation'], meta: { name: 'AIConversation' } }
    /**
     * Find zero or one AIConversation that matches the filter.
     * @param {AIConversationFindUniqueArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIConversationFindUniqueArgs>(args: SelectSubset<T, AIConversationFindUniqueArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIConversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIConversationFindUniqueOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIConversationFindFirstArgs>(args?: SelectSubset<T, AIConversationFindFirstArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIConversations
     * const aIConversations = await prisma.aIConversation.findMany()
     * 
     * // Get first 10 AIConversations
     * const aIConversations = await prisma.aIConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIConversationFindManyArgs>(args?: SelectSubset<T, AIConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIConversation.
     * @param {AIConversationCreateArgs} args - Arguments to create a AIConversation.
     * @example
     * // Create one AIConversation
     * const AIConversation = await prisma.aIConversation.create({
     *   data: {
     *     // ... data to create a AIConversation
     *   }
     * })
     * 
     */
    create<T extends AIConversationCreateArgs>(args: SelectSubset<T, AIConversationCreateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIConversations.
     * @param {AIConversationCreateManyArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIConversationCreateManyArgs>(args?: SelectSubset<T, AIConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIConversations and returns the data saved in the database.
     * @param {AIConversationCreateManyAndReturnArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIConversations and only return the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, AIConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIConversation.
     * @param {AIConversationDeleteArgs} args - Arguments to delete one AIConversation.
     * @example
     * // Delete one AIConversation
     * const AIConversation = await prisma.aIConversation.delete({
     *   where: {
     *     // ... filter to delete one AIConversation
     *   }
     * })
     * 
     */
    delete<T extends AIConversationDeleteArgs>(args: SelectSubset<T, AIConversationDeleteArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIConversation.
     * @param {AIConversationUpdateArgs} args - Arguments to update one AIConversation.
     * @example
     * // Update one AIConversation
     * const aIConversation = await prisma.aIConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIConversationUpdateArgs>(args: SelectSubset<T, AIConversationUpdateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIConversations.
     * @param {AIConversationDeleteManyArgs} args - Arguments to filter AIConversations to delete.
     * @example
     * // Delete a few AIConversations
     * const { count } = await prisma.aIConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIConversationDeleteManyArgs>(args?: SelectSubset<T, AIConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIConversations
     * const aIConversation = await prisma.aIConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIConversationUpdateManyArgs>(args: SelectSubset<T, AIConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIConversation.
     * @param {AIConversationUpsertArgs} args - Arguments to update or create a AIConversation.
     * @example
     * // Update or create a AIConversation
     * const aIConversation = await prisma.aIConversation.upsert({
     *   create: {
     *     // ... data to create a AIConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIConversation we want to update
     *   }
     * })
     */
    upsert<T extends AIConversationUpsertArgs>(args: SelectSubset<T, AIConversationUpsertArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationCountArgs} args - Arguments to filter AIConversations to count.
     * @example
     * // Count the number of AIConversations
     * const count = await prisma.aIConversation.count({
     *   where: {
     *     // ... the filter for the AIConversations we want to count
     *   }
     * })
    **/
    count<T extends AIConversationCountArgs>(
      args?: Subset<T, AIConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIConversationAggregateArgs>(args: Subset<T, AIConversationAggregateArgs>): Prisma.PrismaPromise<GetAIConversationAggregateType<T>>

    /**
     * Group by AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIConversationGroupByArgs['orderBy'] }
        : { orderBy?: AIConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIConversation model
   */
  readonly fields: AIConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends AIClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIClientProfileDefaultArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIConversation model
   */
  interface AIConversationFieldRefs {
    readonly id: FieldRef<"AIConversation", 'String'>
    readonly sessionId: FieldRef<"AIConversation", 'String'>
    readonly profileId: FieldRef<"AIConversation", 'String'>
    readonly role: FieldRef<"AIConversation", 'String'>
    readonly content: FieldRef<"AIConversation", 'String'>
    readonly messageType: FieldRef<"AIConversation", 'String'>
    readonly attachments: FieldRef<"AIConversation", 'Json'>
    readonly sentiment: FieldRef<"AIConversation", 'Float'>
    readonly engagement: FieldRef<"AIConversation", 'Float'>
    readonly intent: FieldRef<"AIConversation", 'String[]'>
    readonly urgency: FieldRef<"AIConversation", 'String'>
    readonly strategy: FieldRef<"AIConversation", 'String'>
    readonly effectiveness: FieldRef<"AIConversation", 'Float'>
    readonly createdAt: FieldRef<"AIConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIConversation findUnique
   */
  export type AIConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findUniqueOrThrow
   */
  export type AIConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findFirst
   */
  export type AIConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findFirstOrThrow
   */
  export type AIConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findMany
   */
  export type AIConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversations to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation create
   */
  export type AIConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a AIConversation.
     */
    data: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
  }

  /**
   * AIConversation createMany
   */
  export type AIConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIConversation createManyAndReturn
   */
  export type AIConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIConversation update
   */
  export type AIConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a AIConversation.
     */
    data: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
    /**
     * Choose, which AIConversation to update.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation updateMany
   */
  export type AIConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIConversations.
     */
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyInput>
    /**
     * Filter which AIConversations to update
     */
    where?: AIConversationWhereInput
  }

  /**
   * AIConversation upsert
   */
  export type AIConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the AIConversation to update in case it exists.
     */
    where: AIConversationWhereUniqueInput
    /**
     * In case the AIConversation found by the `where` argument doesn't exist, create a new AIConversation with this data.
     */
    create: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
    /**
     * In case the AIConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
  }

  /**
   * AIConversation delete
   */
  export type AIConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter which AIConversation to delete.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation deleteMany
   */
  export type AIConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversations to delete
     */
    where?: AIConversationWhereInput
  }

  /**
   * AIConversation without action
   */
  export type AIConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
  }


  /**
   * Model AILeadData
   */

  export type AggregateAILeadData = {
    _count: AILeadDataCountAggregateOutputType | null
    _avg: AILeadDataAvgAggregateOutputType | null
    _sum: AILeadDataSumAggregateOutputType | null
    _min: AILeadDataMinAggregateOutputType | null
    _max: AILeadDataMaxAggregateOutputType | null
  }

  export type AILeadDataAvgAggregateOutputType = {
    leadScore: number | null
    conversionValue: number | null
  }

  export type AILeadDataSumAggregateOutputType = {
    leadScore: number | null
    conversionValue: number | null
  }

  export type AILeadDataMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    leadScore: number | null
    leadStatus: $Enums.LeadStatus | null
    estimatedValue: string | null
    salesStage: $Enums.SalesStage | null
    nextAction: string | null
    notes: string | null
    assignedTo: string | null
    followUpAt: Date | null
    convertedAt: Date | null
    conversionValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AILeadDataMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    leadScore: number | null
    leadStatus: $Enums.LeadStatus | null
    estimatedValue: string | null
    salesStage: $Enums.SalesStage | null
    nextAction: string | null
    notes: string | null
    assignedTo: string | null
    followUpAt: Date | null
    convertedAt: Date | null
    conversionValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AILeadDataCountAggregateOutputType = {
    id: number
    profileId: number
    leadScore: number
    leadStatus: number
    estimatedValue: number
    salesStage: number
    nextAction: number
    notes: number
    assignedTo: number
    followUpAt: number
    convertedAt: number
    conversionValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AILeadDataAvgAggregateInputType = {
    leadScore?: true
    conversionValue?: true
  }

  export type AILeadDataSumAggregateInputType = {
    leadScore?: true
    conversionValue?: true
  }

  export type AILeadDataMinAggregateInputType = {
    id?: true
    profileId?: true
    leadScore?: true
    leadStatus?: true
    estimatedValue?: true
    salesStage?: true
    nextAction?: true
    notes?: true
    assignedTo?: true
    followUpAt?: true
    convertedAt?: true
    conversionValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AILeadDataMaxAggregateInputType = {
    id?: true
    profileId?: true
    leadScore?: true
    leadStatus?: true
    estimatedValue?: true
    salesStage?: true
    nextAction?: true
    notes?: true
    assignedTo?: true
    followUpAt?: true
    convertedAt?: true
    conversionValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AILeadDataCountAggregateInputType = {
    id?: true
    profileId?: true
    leadScore?: true
    leadStatus?: true
    estimatedValue?: true
    salesStage?: true
    nextAction?: true
    notes?: true
    assignedTo?: true
    followUpAt?: true
    convertedAt?: true
    conversionValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AILeadDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AILeadData to aggregate.
     */
    where?: AILeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILeadData to fetch.
     */
    orderBy?: AILeadDataOrderByWithRelationInput | AILeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AILeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILeadData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AILeadData
    **/
    _count?: true | AILeadDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AILeadDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AILeadDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AILeadDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AILeadDataMaxAggregateInputType
  }

  export type GetAILeadDataAggregateType<T extends AILeadDataAggregateArgs> = {
        [P in keyof T & keyof AggregateAILeadData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAILeadData[P]>
      : GetScalarType<T[P], AggregateAILeadData[P]>
  }




  export type AILeadDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AILeadDataWhereInput
    orderBy?: AILeadDataOrderByWithAggregationInput | AILeadDataOrderByWithAggregationInput[]
    by: AILeadDataScalarFieldEnum[] | AILeadDataScalarFieldEnum
    having?: AILeadDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AILeadDataCountAggregateInputType | true
    _avg?: AILeadDataAvgAggregateInputType
    _sum?: AILeadDataSumAggregateInputType
    _min?: AILeadDataMinAggregateInputType
    _max?: AILeadDataMaxAggregateInputType
  }

  export type AILeadDataGroupByOutputType = {
    id: string
    profileId: string
    leadScore: number
    leadStatus: $Enums.LeadStatus
    estimatedValue: string | null
    salesStage: $Enums.SalesStage
    nextAction: string | null
    notes: string | null
    assignedTo: string | null
    followUpAt: Date | null
    convertedAt: Date | null
    conversionValue: number | null
    createdAt: Date
    updatedAt: Date
    _count: AILeadDataCountAggregateOutputType | null
    _avg: AILeadDataAvgAggregateOutputType | null
    _sum: AILeadDataSumAggregateOutputType | null
    _min: AILeadDataMinAggregateOutputType | null
    _max: AILeadDataMaxAggregateOutputType | null
  }

  type GetAILeadDataGroupByPayload<T extends AILeadDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AILeadDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AILeadDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AILeadDataGroupByOutputType[P]>
            : GetScalarType<T[P], AILeadDataGroupByOutputType[P]>
        }
      >
    >


  export type AILeadDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    leadScore?: boolean
    leadStatus?: boolean
    estimatedValue?: boolean
    salesStage?: boolean
    nextAction?: boolean
    notes?: boolean
    assignedTo?: boolean
    followUpAt?: boolean
    convertedAt?: boolean
    conversionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aILeadData"]>

  export type AILeadDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    leadScore?: boolean
    leadStatus?: boolean
    estimatedValue?: boolean
    salesStage?: boolean
    nextAction?: boolean
    notes?: boolean
    assignedTo?: boolean
    followUpAt?: boolean
    convertedAt?: boolean
    conversionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aILeadData"]>


  export type AILeadDataSelectScalar = {
    id?: boolean
    profileId?: boolean
    leadScore?: boolean
    leadStatus?: boolean
    estimatedValue?: boolean
    salesStage?: boolean
    nextAction?: boolean
    notes?: boolean
    assignedTo?: boolean
    followUpAt?: boolean
    convertedAt?: boolean
    conversionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AILeadDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "leadScore" | "leadStatus" | "estimatedValue" | "salesStage" | "nextAction" | "notes" | "assignedTo" | "followUpAt" | "convertedAt" | "conversionValue" | "createdAt" | "updatedAt", ExtArgs["result"]["aILeadData"]>
  export type AILeadDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }
  export type AILeadDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | AIClientProfileDefaultArgs<ExtArgs>
  }

  export type $AILeadDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AILeadData"
    objects: {
      profile: Prisma.$AIClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      leadScore: number
      leadStatus: $Enums.LeadStatus
      estimatedValue: string | null
      salesStage: $Enums.SalesStage
      nextAction: string | null
      notes: string | null
      assignedTo: string | null
      followUpAt: Date | null
      convertedAt: Date | null
      conversionValue: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aILeadData"]>
    composites: {}
  }

  type AILeadDataGetPayload<S extends boolean | null | undefined | AILeadDataDefaultArgs> = $Result.GetResult<Prisma.$AILeadDataPayload, S>

  type AILeadDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AILeadDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AILeadDataCountAggregateInputType | true
    }

  export interface AILeadDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AILeadData'], meta: { name: 'AILeadData' } }
    /**
     * Find zero or one AILeadData that matches the filter.
     * @param {AILeadDataFindUniqueArgs} args - Arguments to find a AILeadData
     * @example
     * // Get one AILeadData
     * const aILeadData = await prisma.aILeadData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AILeadDataFindUniqueArgs>(args: SelectSubset<T, AILeadDataFindUniqueArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AILeadData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AILeadDataFindUniqueOrThrowArgs} args - Arguments to find a AILeadData
     * @example
     * // Get one AILeadData
     * const aILeadData = await prisma.aILeadData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AILeadDataFindUniqueOrThrowArgs>(args: SelectSubset<T, AILeadDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AILeadData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILeadDataFindFirstArgs} args - Arguments to find a AILeadData
     * @example
     * // Get one AILeadData
     * const aILeadData = await prisma.aILeadData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AILeadDataFindFirstArgs>(args?: SelectSubset<T, AILeadDataFindFirstArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AILeadData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILeadDataFindFirstOrThrowArgs} args - Arguments to find a AILeadData
     * @example
     * // Get one AILeadData
     * const aILeadData = await prisma.aILeadData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AILeadDataFindFirstOrThrowArgs>(args?: SelectSubset<T, AILeadDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AILeadData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILeadDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AILeadData
     * const aILeadData = await prisma.aILeadData.findMany()
     * 
     * // Get first 10 AILeadData
     * const aILeadData = await prisma.aILeadData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aILeadDataWithIdOnly = await prisma.aILeadData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AILeadDataFindManyArgs>(args?: SelectSubset<T, AILeadDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AILeadData.
     * @param {AILeadDataCreateArgs} args - Arguments to create a AILeadData.
     * @example
     * // Create one AILeadData
     * const AILeadData = await prisma.aILeadData.create({
     *   data: {
     *     // ... data to create a AILeadData
     *   }
     * })
     * 
     */
    create<T extends AILeadDataCreateArgs>(args: SelectSubset<T, AILeadDataCreateArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AILeadData.
     * @param {AILeadDataCreateManyArgs} args - Arguments to create many AILeadData.
     * @example
     * // Create many AILeadData
     * const aILeadData = await prisma.aILeadData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AILeadDataCreateManyArgs>(args?: SelectSubset<T, AILeadDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AILeadData and returns the data saved in the database.
     * @param {AILeadDataCreateManyAndReturnArgs} args - Arguments to create many AILeadData.
     * @example
     * // Create many AILeadData
     * const aILeadData = await prisma.aILeadData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AILeadData and only return the `id`
     * const aILeadDataWithIdOnly = await prisma.aILeadData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AILeadDataCreateManyAndReturnArgs>(args?: SelectSubset<T, AILeadDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AILeadData.
     * @param {AILeadDataDeleteArgs} args - Arguments to delete one AILeadData.
     * @example
     * // Delete one AILeadData
     * const AILeadData = await prisma.aILeadData.delete({
     *   where: {
     *     // ... filter to delete one AILeadData
     *   }
     * })
     * 
     */
    delete<T extends AILeadDataDeleteArgs>(args: SelectSubset<T, AILeadDataDeleteArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AILeadData.
     * @param {AILeadDataUpdateArgs} args - Arguments to update one AILeadData.
     * @example
     * // Update one AILeadData
     * const aILeadData = await prisma.aILeadData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AILeadDataUpdateArgs>(args: SelectSubset<T, AILeadDataUpdateArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AILeadData.
     * @param {AILeadDataDeleteManyArgs} args - Arguments to filter AILeadData to delete.
     * @example
     * // Delete a few AILeadData
     * const { count } = await prisma.aILeadData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AILeadDataDeleteManyArgs>(args?: SelectSubset<T, AILeadDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AILeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILeadDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AILeadData
     * const aILeadData = await prisma.aILeadData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AILeadDataUpdateManyArgs>(args: SelectSubset<T, AILeadDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AILeadData.
     * @param {AILeadDataUpsertArgs} args - Arguments to update or create a AILeadData.
     * @example
     * // Update or create a AILeadData
     * const aILeadData = await prisma.aILeadData.upsert({
     *   create: {
     *     // ... data to create a AILeadData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AILeadData we want to update
     *   }
     * })
     */
    upsert<T extends AILeadDataUpsertArgs>(args: SelectSubset<T, AILeadDataUpsertArgs<ExtArgs>>): Prisma__AILeadDataClient<$Result.GetResult<Prisma.$AILeadDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AILeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILeadDataCountArgs} args - Arguments to filter AILeadData to count.
     * @example
     * // Count the number of AILeadData
     * const count = await prisma.aILeadData.count({
     *   where: {
     *     // ... the filter for the AILeadData we want to count
     *   }
     * })
    **/
    count<T extends AILeadDataCountArgs>(
      args?: Subset<T, AILeadDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AILeadDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AILeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILeadDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AILeadDataAggregateArgs>(args: Subset<T, AILeadDataAggregateArgs>): Prisma.PrismaPromise<GetAILeadDataAggregateType<T>>

    /**
     * Group by AILeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILeadDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AILeadDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AILeadDataGroupByArgs['orderBy'] }
        : { orderBy?: AILeadDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AILeadDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAILeadDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AILeadData model
   */
  readonly fields: AILeadDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AILeadData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AILeadDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends AIClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIClientProfileDefaultArgs<ExtArgs>>): Prisma__AIClientProfileClient<$Result.GetResult<Prisma.$AIClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AILeadData model
   */
  interface AILeadDataFieldRefs {
    readonly id: FieldRef<"AILeadData", 'String'>
    readonly profileId: FieldRef<"AILeadData", 'String'>
    readonly leadScore: FieldRef<"AILeadData", 'Int'>
    readonly leadStatus: FieldRef<"AILeadData", 'LeadStatus'>
    readonly estimatedValue: FieldRef<"AILeadData", 'String'>
    readonly salesStage: FieldRef<"AILeadData", 'SalesStage'>
    readonly nextAction: FieldRef<"AILeadData", 'String'>
    readonly notes: FieldRef<"AILeadData", 'String'>
    readonly assignedTo: FieldRef<"AILeadData", 'String'>
    readonly followUpAt: FieldRef<"AILeadData", 'DateTime'>
    readonly convertedAt: FieldRef<"AILeadData", 'DateTime'>
    readonly conversionValue: FieldRef<"AILeadData", 'Float'>
    readonly createdAt: FieldRef<"AILeadData", 'DateTime'>
    readonly updatedAt: FieldRef<"AILeadData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AILeadData findUnique
   */
  export type AILeadDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * Filter, which AILeadData to fetch.
     */
    where: AILeadDataWhereUniqueInput
  }

  /**
   * AILeadData findUniqueOrThrow
   */
  export type AILeadDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * Filter, which AILeadData to fetch.
     */
    where: AILeadDataWhereUniqueInput
  }

  /**
   * AILeadData findFirst
   */
  export type AILeadDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * Filter, which AILeadData to fetch.
     */
    where?: AILeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILeadData to fetch.
     */
    orderBy?: AILeadDataOrderByWithRelationInput | AILeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AILeadData.
     */
    cursor?: AILeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILeadData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AILeadData.
     */
    distinct?: AILeadDataScalarFieldEnum | AILeadDataScalarFieldEnum[]
  }

  /**
   * AILeadData findFirstOrThrow
   */
  export type AILeadDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * Filter, which AILeadData to fetch.
     */
    where?: AILeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILeadData to fetch.
     */
    orderBy?: AILeadDataOrderByWithRelationInput | AILeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AILeadData.
     */
    cursor?: AILeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILeadData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AILeadData.
     */
    distinct?: AILeadDataScalarFieldEnum | AILeadDataScalarFieldEnum[]
  }

  /**
   * AILeadData findMany
   */
  export type AILeadDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * Filter, which AILeadData to fetch.
     */
    where?: AILeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILeadData to fetch.
     */
    orderBy?: AILeadDataOrderByWithRelationInput | AILeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AILeadData.
     */
    cursor?: AILeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILeadData.
     */
    skip?: number
    distinct?: AILeadDataScalarFieldEnum | AILeadDataScalarFieldEnum[]
  }

  /**
   * AILeadData create
   */
  export type AILeadDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * The data needed to create a AILeadData.
     */
    data: XOR<AILeadDataCreateInput, AILeadDataUncheckedCreateInput>
  }

  /**
   * AILeadData createMany
   */
  export type AILeadDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AILeadData.
     */
    data: AILeadDataCreateManyInput | AILeadDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AILeadData createManyAndReturn
   */
  export type AILeadDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * The data used to create many AILeadData.
     */
    data: AILeadDataCreateManyInput | AILeadDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AILeadData update
   */
  export type AILeadDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * The data needed to update a AILeadData.
     */
    data: XOR<AILeadDataUpdateInput, AILeadDataUncheckedUpdateInput>
    /**
     * Choose, which AILeadData to update.
     */
    where: AILeadDataWhereUniqueInput
  }

  /**
   * AILeadData updateMany
   */
  export type AILeadDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AILeadData.
     */
    data: XOR<AILeadDataUpdateManyMutationInput, AILeadDataUncheckedUpdateManyInput>
    /**
     * Filter which AILeadData to update
     */
    where?: AILeadDataWhereInput
  }

  /**
   * AILeadData upsert
   */
  export type AILeadDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * The filter to search for the AILeadData to update in case it exists.
     */
    where: AILeadDataWhereUniqueInput
    /**
     * In case the AILeadData found by the `where` argument doesn't exist, create a new AILeadData with this data.
     */
    create: XOR<AILeadDataCreateInput, AILeadDataUncheckedCreateInput>
    /**
     * In case the AILeadData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AILeadDataUpdateInput, AILeadDataUncheckedUpdateInput>
  }

  /**
   * AILeadData delete
   */
  export type AILeadDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
    /**
     * Filter which AILeadData to delete.
     */
    where: AILeadDataWhereUniqueInput
  }

  /**
   * AILeadData deleteMany
   */
  export type AILeadDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AILeadData to delete
     */
    where?: AILeadDataWhereInput
  }

  /**
   * AILeadData without action
   */
  export type AILeadDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILeadData
     */
    select?: AILeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILeadData
     */
    omit?: AILeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILeadDataInclude<ExtArgs> | null
  }


  /**
   * Model AICompanyIntelligence
   */

  export type AggregateAICompanyIntelligence = {
    _count: AICompanyIntelligenceCountAggregateOutputType | null
    _avg: AICompanyIntelligenceAvgAggregateOutputType | null
    _sum: AICompanyIntelligenceSumAggregateOutputType | null
    _min: AICompanyIntelligenceMinAggregateOutputType | null
    _max: AICompanyIntelligenceMaxAggregateOutputType | null
  }

  export type AICompanyIntelligenceAvgAggregateOutputType = {
    timesAnalyzed: number | null
  }

  export type AICompanyIntelligenceSumAggregateOutputType = {
    timesAnalyzed: number | null
  }

  export type AICompanyIntelligenceMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    website: string | null
    industry: string | null
    size: $Enums.CompanySize | null
    description: string | null
    budgetEstimate: string | null
    phone: string | null
    email: string | null
    address: string | null
    timesAnalyzed: number | null
    lastAnalyzed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AICompanyIntelligenceMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    website: string | null
    industry: string | null
    size: $Enums.CompanySize | null
    description: string | null
    budgetEstimate: string | null
    phone: string | null
    email: string | null
    address: string | null
    timesAnalyzed: number | null
    lastAnalyzed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AICompanyIntelligenceCountAggregateOutputType = {
    id: number
    companyName: number
    website: number
    industry: number
    size: number
    description: number
    painPoints: number
    budgetEstimate: number
    decisionMakers: number
    competitors: number
    recentNews: number
    marketTrends: number
    phone: number
    email: number
    address: number
    timesAnalyzed: number
    lastAnalyzed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AICompanyIntelligenceAvgAggregateInputType = {
    timesAnalyzed?: true
  }

  export type AICompanyIntelligenceSumAggregateInputType = {
    timesAnalyzed?: true
  }

  export type AICompanyIntelligenceMinAggregateInputType = {
    id?: true
    companyName?: true
    website?: true
    industry?: true
    size?: true
    description?: true
    budgetEstimate?: true
    phone?: true
    email?: true
    address?: true
    timesAnalyzed?: true
    lastAnalyzed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AICompanyIntelligenceMaxAggregateInputType = {
    id?: true
    companyName?: true
    website?: true
    industry?: true
    size?: true
    description?: true
    budgetEstimate?: true
    phone?: true
    email?: true
    address?: true
    timesAnalyzed?: true
    lastAnalyzed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AICompanyIntelligenceCountAggregateInputType = {
    id?: true
    companyName?: true
    website?: true
    industry?: true
    size?: true
    description?: true
    painPoints?: true
    budgetEstimate?: true
    decisionMakers?: true
    competitors?: true
    recentNews?: true
    marketTrends?: true
    phone?: true
    email?: true
    address?: true
    timesAnalyzed?: true
    lastAnalyzed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AICompanyIntelligenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AICompanyIntelligence to aggregate.
     */
    where?: AICompanyIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICompanyIntelligences to fetch.
     */
    orderBy?: AICompanyIntelligenceOrderByWithRelationInput | AICompanyIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AICompanyIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICompanyIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICompanyIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AICompanyIntelligences
    **/
    _count?: true | AICompanyIntelligenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AICompanyIntelligenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AICompanyIntelligenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AICompanyIntelligenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AICompanyIntelligenceMaxAggregateInputType
  }

  export type GetAICompanyIntelligenceAggregateType<T extends AICompanyIntelligenceAggregateArgs> = {
        [P in keyof T & keyof AggregateAICompanyIntelligence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAICompanyIntelligence[P]>
      : GetScalarType<T[P], AggregateAICompanyIntelligence[P]>
  }




  export type AICompanyIntelligenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AICompanyIntelligenceWhereInput
    orderBy?: AICompanyIntelligenceOrderByWithAggregationInput | AICompanyIntelligenceOrderByWithAggregationInput[]
    by: AICompanyIntelligenceScalarFieldEnum[] | AICompanyIntelligenceScalarFieldEnum
    having?: AICompanyIntelligenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AICompanyIntelligenceCountAggregateInputType | true
    _avg?: AICompanyIntelligenceAvgAggregateInputType
    _sum?: AICompanyIntelligenceSumAggregateInputType
    _min?: AICompanyIntelligenceMinAggregateInputType
    _max?: AICompanyIntelligenceMaxAggregateInputType
  }

  export type AICompanyIntelligenceGroupByOutputType = {
    id: string
    companyName: string
    website: string | null
    industry: string | null
    size: $Enums.CompanySize | null
    description: string | null
    painPoints: string[]
    budgetEstimate: string | null
    decisionMakers: string[]
    competitors: string[]
    recentNews: JsonValue | null
    marketTrends: JsonValue | null
    phone: string | null
    email: string | null
    address: string | null
    timesAnalyzed: number
    lastAnalyzed: Date
    createdAt: Date
    updatedAt: Date
    _count: AICompanyIntelligenceCountAggregateOutputType | null
    _avg: AICompanyIntelligenceAvgAggregateOutputType | null
    _sum: AICompanyIntelligenceSumAggregateOutputType | null
    _min: AICompanyIntelligenceMinAggregateOutputType | null
    _max: AICompanyIntelligenceMaxAggregateOutputType | null
  }

  type GetAICompanyIntelligenceGroupByPayload<T extends AICompanyIntelligenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AICompanyIntelligenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AICompanyIntelligenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AICompanyIntelligenceGroupByOutputType[P]>
            : GetScalarType<T[P], AICompanyIntelligenceGroupByOutputType[P]>
        }
      >
    >


  export type AICompanyIntelligenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    website?: boolean
    industry?: boolean
    size?: boolean
    description?: boolean
    painPoints?: boolean
    budgetEstimate?: boolean
    decisionMakers?: boolean
    competitors?: boolean
    recentNews?: boolean
    marketTrends?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    timesAnalyzed?: boolean
    lastAnalyzed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aICompanyIntelligence"]>

  export type AICompanyIntelligenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    website?: boolean
    industry?: boolean
    size?: boolean
    description?: boolean
    painPoints?: boolean
    budgetEstimate?: boolean
    decisionMakers?: boolean
    competitors?: boolean
    recentNews?: boolean
    marketTrends?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    timesAnalyzed?: boolean
    lastAnalyzed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aICompanyIntelligence"]>


  export type AICompanyIntelligenceSelectScalar = {
    id?: boolean
    companyName?: boolean
    website?: boolean
    industry?: boolean
    size?: boolean
    description?: boolean
    painPoints?: boolean
    budgetEstimate?: boolean
    decisionMakers?: boolean
    competitors?: boolean
    recentNews?: boolean
    marketTrends?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    timesAnalyzed?: boolean
    lastAnalyzed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AICompanyIntelligenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "website" | "industry" | "size" | "description" | "painPoints" | "budgetEstimate" | "decisionMakers" | "competitors" | "recentNews" | "marketTrends" | "phone" | "email" | "address" | "timesAnalyzed" | "lastAnalyzed" | "createdAt" | "updatedAt", ExtArgs["result"]["aICompanyIntelligence"]>

  export type $AICompanyIntelligencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AICompanyIntelligence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      website: string | null
      industry: string | null
      size: $Enums.CompanySize | null
      description: string | null
      painPoints: string[]
      budgetEstimate: string | null
      decisionMakers: string[]
      competitors: string[]
      recentNews: Prisma.JsonValue | null
      marketTrends: Prisma.JsonValue | null
      phone: string | null
      email: string | null
      address: string | null
      timesAnalyzed: number
      lastAnalyzed: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aICompanyIntelligence"]>
    composites: {}
  }

  type AICompanyIntelligenceGetPayload<S extends boolean | null | undefined | AICompanyIntelligenceDefaultArgs> = $Result.GetResult<Prisma.$AICompanyIntelligencePayload, S>

  type AICompanyIntelligenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AICompanyIntelligenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AICompanyIntelligenceCountAggregateInputType | true
    }

  export interface AICompanyIntelligenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AICompanyIntelligence'], meta: { name: 'AICompanyIntelligence' } }
    /**
     * Find zero or one AICompanyIntelligence that matches the filter.
     * @param {AICompanyIntelligenceFindUniqueArgs} args - Arguments to find a AICompanyIntelligence
     * @example
     * // Get one AICompanyIntelligence
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AICompanyIntelligenceFindUniqueArgs>(args: SelectSubset<T, AICompanyIntelligenceFindUniqueArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AICompanyIntelligence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AICompanyIntelligenceFindUniqueOrThrowArgs} args - Arguments to find a AICompanyIntelligence
     * @example
     * // Get one AICompanyIntelligence
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AICompanyIntelligenceFindUniqueOrThrowArgs>(args: SelectSubset<T, AICompanyIntelligenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AICompanyIntelligence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICompanyIntelligenceFindFirstArgs} args - Arguments to find a AICompanyIntelligence
     * @example
     * // Get one AICompanyIntelligence
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AICompanyIntelligenceFindFirstArgs>(args?: SelectSubset<T, AICompanyIntelligenceFindFirstArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AICompanyIntelligence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICompanyIntelligenceFindFirstOrThrowArgs} args - Arguments to find a AICompanyIntelligence
     * @example
     * // Get one AICompanyIntelligence
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AICompanyIntelligenceFindFirstOrThrowArgs>(args?: SelectSubset<T, AICompanyIntelligenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AICompanyIntelligences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICompanyIntelligenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AICompanyIntelligences
     * const aICompanyIntelligences = await prisma.aICompanyIntelligence.findMany()
     * 
     * // Get first 10 AICompanyIntelligences
     * const aICompanyIntelligences = await prisma.aICompanyIntelligence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aICompanyIntelligenceWithIdOnly = await prisma.aICompanyIntelligence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AICompanyIntelligenceFindManyArgs>(args?: SelectSubset<T, AICompanyIntelligenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AICompanyIntelligence.
     * @param {AICompanyIntelligenceCreateArgs} args - Arguments to create a AICompanyIntelligence.
     * @example
     * // Create one AICompanyIntelligence
     * const AICompanyIntelligence = await prisma.aICompanyIntelligence.create({
     *   data: {
     *     // ... data to create a AICompanyIntelligence
     *   }
     * })
     * 
     */
    create<T extends AICompanyIntelligenceCreateArgs>(args: SelectSubset<T, AICompanyIntelligenceCreateArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AICompanyIntelligences.
     * @param {AICompanyIntelligenceCreateManyArgs} args - Arguments to create many AICompanyIntelligences.
     * @example
     * // Create many AICompanyIntelligences
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AICompanyIntelligenceCreateManyArgs>(args?: SelectSubset<T, AICompanyIntelligenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AICompanyIntelligences and returns the data saved in the database.
     * @param {AICompanyIntelligenceCreateManyAndReturnArgs} args - Arguments to create many AICompanyIntelligences.
     * @example
     * // Create many AICompanyIntelligences
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AICompanyIntelligences and only return the `id`
     * const aICompanyIntelligenceWithIdOnly = await prisma.aICompanyIntelligence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AICompanyIntelligenceCreateManyAndReturnArgs>(args?: SelectSubset<T, AICompanyIntelligenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AICompanyIntelligence.
     * @param {AICompanyIntelligenceDeleteArgs} args - Arguments to delete one AICompanyIntelligence.
     * @example
     * // Delete one AICompanyIntelligence
     * const AICompanyIntelligence = await prisma.aICompanyIntelligence.delete({
     *   where: {
     *     // ... filter to delete one AICompanyIntelligence
     *   }
     * })
     * 
     */
    delete<T extends AICompanyIntelligenceDeleteArgs>(args: SelectSubset<T, AICompanyIntelligenceDeleteArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AICompanyIntelligence.
     * @param {AICompanyIntelligenceUpdateArgs} args - Arguments to update one AICompanyIntelligence.
     * @example
     * // Update one AICompanyIntelligence
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AICompanyIntelligenceUpdateArgs>(args: SelectSubset<T, AICompanyIntelligenceUpdateArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AICompanyIntelligences.
     * @param {AICompanyIntelligenceDeleteManyArgs} args - Arguments to filter AICompanyIntelligences to delete.
     * @example
     * // Delete a few AICompanyIntelligences
     * const { count } = await prisma.aICompanyIntelligence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AICompanyIntelligenceDeleteManyArgs>(args?: SelectSubset<T, AICompanyIntelligenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AICompanyIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICompanyIntelligenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AICompanyIntelligences
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AICompanyIntelligenceUpdateManyArgs>(args: SelectSubset<T, AICompanyIntelligenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AICompanyIntelligence.
     * @param {AICompanyIntelligenceUpsertArgs} args - Arguments to update or create a AICompanyIntelligence.
     * @example
     * // Update or create a AICompanyIntelligence
     * const aICompanyIntelligence = await prisma.aICompanyIntelligence.upsert({
     *   create: {
     *     // ... data to create a AICompanyIntelligence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AICompanyIntelligence we want to update
     *   }
     * })
     */
    upsert<T extends AICompanyIntelligenceUpsertArgs>(args: SelectSubset<T, AICompanyIntelligenceUpsertArgs<ExtArgs>>): Prisma__AICompanyIntelligenceClient<$Result.GetResult<Prisma.$AICompanyIntelligencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AICompanyIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICompanyIntelligenceCountArgs} args - Arguments to filter AICompanyIntelligences to count.
     * @example
     * // Count the number of AICompanyIntelligences
     * const count = await prisma.aICompanyIntelligence.count({
     *   where: {
     *     // ... the filter for the AICompanyIntelligences we want to count
     *   }
     * })
    **/
    count<T extends AICompanyIntelligenceCountArgs>(
      args?: Subset<T, AICompanyIntelligenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AICompanyIntelligenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AICompanyIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICompanyIntelligenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AICompanyIntelligenceAggregateArgs>(args: Subset<T, AICompanyIntelligenceAggregateArgs>): Prisma.PrismaPromise<GetAICompanyIntelligenceAggregateType<T>>

    /**
     * Group by AICompanyIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICompanyIntelligenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AICompanyIntelligenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AICompanyIntelligenceGroupByArgs['orderBy'] }
        : { orderBy?: AICompanyIntelligenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AICompanyIntelligenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAICompanyIntelligenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AICompanyIntelligence model
   */
  readonly fields: AICompanyIntelligenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AICompanyIntelligence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AICompanyIntelligenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AICompanyIntelligence model
   */
  interface AICompanyIntelligenceFieldRefs {
    readonly id: FieldRef<"AICompanyIntelligence", 'String'>
    readonly companyName: FieldRef<"AICompanyIntelligence", 'String'>
    readonly website: FieldRef<"AICompanyIntelligence", 'String'>
    readonly industry: FieldRef<"AICompanyIntelligence", 'String'>
    readonly size: FieldRef<"AICompanyIntelligence", 'CompanySize'>
    readonly description: FieldRef<"AICompanyIntelligence", 'String'>
    readonly painPoints: FieldRef<"AICompanyIntelligence", 'String[]'>
    readonly budgetEstimate: FieldRef<"AICompanyIntelligence", 'String'>
    readonly decisionMakers: FieldRef<"AICompanyIntelligence", 'String[]'>
    readonly competitors: FieldRef<"AICompanyIntelligence", 'String[]'>
    readonly recentNews: FieldRef<"AICompanyIntelligence", 'Json'>
    readonly marketTrends: FieldRef<"AICompanyIntelligence", 'Json'>
    readonly phone: FieldRef<"AICompanyIntelligence", 'String'>
    readonly email: FieldRef<"AICompanyIntelligence", 'String'>
    readonly address: FieldRef<"AICompanyIntelligence", 'String'>
    readonly timesAnalyzed: FieldRef<"AICompanyIntelligence", 'Int'>
    readonly lastAnalyzed: FieldRef<"AICompanyIntelligence", 'DateTime'>
    readonly createdAt: FieldRef<"AICompanyIntelligence", 'DateTime'>
    readonly updatedAt: FieldRef<"AICompanyIntelligence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AICompanyIntelligence findUnique
   */
  export type AICompanyIntelligenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * Filter, which AICompanyIntelligence to fetch.
     */
    where: AICompanyIntelligenceWhereUniqueInput
  }

  /**
   * AICompanyIntelligence findUniqueOrThrow
   */
  export type AICompanyIntelligenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * Filter, which AICompanyIntelligence to fetch.
     */
    where: AICompanyIntelligenceWhereUniqueInput
  }

  /**
   * AICompanyIntelligence findFirst
   */
  export type AICompanyIntelligenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * Filter, which AICompanyIntelligence to fetch.
     */
    where?: AICompanyIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICompanyIntelligences to fetch.
     */
    orderBy?: AICompanyIntelligenceOrderByWithRelationInput | AICompanyIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AICompanyIntelligences.
     */
    cursor?: AICompanyIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICompanyIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICompanyIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AICompanyIntelligences.
     */
    distinct?: AICompanyIntelligenceScalarFieldEnum | AICompanyIntelligenceScalarFieldEnum[]
  }

  /**
   * AICompanyIntelligence findFirstOrThrow
   */
  export type AICompanyIntelligenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * Filter, which AICompanyIntelligence to fetch.
     */
    where?: AICompanyIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICompanyIntelligences to fetch.
     */
    orderBy?: AICompanyIntelligenceOrderByWithRelationInput | AICompanyIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AICompanyIntelligences.
     */
    cursor?: AICompanyIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICompanyIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICompanyIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AICompanyIntelligences.
     */
    distinct?: AICompanyIntelligenceScalarFieldEnum | AICompanyIntelligenceScalarFieldEnum[]
  }

  /**
   * AICompanyIntelligence findMany
   */
  export type AICompanyIntelligenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * Filter, which AICompanyIntelligences to fetch.
     */
    where?: AICompanyIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICompanyIntelligences to fetch.
     */
    orderBy?: AICompanyIntelligenceOrderByWithRelationInput | AICompanyIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AICompanyIntelligences.
     */
    cursor?: AICompanyIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICompanyIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICompanyIntelligences.
     */
    skip?: number
    distinct?: AICompanyIntelligenceScalarFieldEnum | AICompanyIntelligenceScalarFieldEnum[]
  }

  /**
   * AICompanyIntelligence create
   */
  export type AICompanyIntelligenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * The data needed to create a AICompanyIntelligence.
     */
    data: XOR<AICompanyIntelligenceCreateInput, AICompanyIntelligenceUncheckedCreateInput>
  }

  /**
   * AICompanyIntelligence createMany
   */
  export type AICompanyIntelligenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AICompanyIntelligences.
     */
    data: AICompanyIntelligenceCreateManyInput | AICompanyIntelligenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AICompanyIntelligence createManyAndReturn
   */
  export type AICompanyIntelligenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * The data used to create many AICompanyIntelligences.
     */
    data: AICompanyIntelligenceCreateManyInput | AICompanyIntelligenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AICompanyIntelligence update
   */
  export type AICompanyIntelligenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * The data needed to update a AICompanyIntelligence.
     */
    data: XOR<AICompanyIntelligenceUpdateInput, AICompanyIntelligenceUncheckedUpdateInput>
    /**
     * Choose, which AICompanyIntelligence to update.
     */
    where: AICompanyIntelligenceWhereUniqueInput
  }

  /**
   * AICompanyIntelligence updateMany
   */
  export type AICompanyIntelligenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AICompanyIntelligences.
     */
    data: XOR<AICompanyIntelligenceUpdateManyMutationInput, AICompanyIntelligenceUncheckedUpdateManyInput>
    /**
     * Filter which AICompanyIntelligences to update
     */
    where?: AICompanyIntelligenceWhereInput
  }

  /**
   * AICompanyIntelligence upsert
   */
  export type AICompanyIntelligenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * The filter to search for the AICompanyIntelligence to update in case it exists.
     */
    where: AICompanyIntelligenceWhereUniqueInput
    /**
     * In case the AICompanyIntelligence found by the `where` argument doesn't exist, create a new AICompanyIntelligence with this data.
     */
    create: XOR<AICompanyIntelligenceCreateInput, AICompanyIntelligenceUncheckedCreateInput>
    /**
     * In case the AICompanyIntelligence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AICompanyIntelligenceUpdateInput, AICompanyIntelligenceUncheckedUpdateInput>
  }

  /**
   * AICompanyIntelligence delete
   */
  export type AICompanyIntelligenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
    /**
     * Filter which AICompanyIntelligence to delete.
     */
    where: AICompanyIntelligenceWhereUniqueInput
  }

  /**
   * AICompanyIntelligence deleteMany
   */
  export type AICompanyIntelligenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AICompanyIntelligences to delete
     */
    where?: AICompanyIntelligenceWhereInput
  }

  /**
   * AICompanyIntelligence without action
   */
  export type AICompanyIntelligenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICompanyIntelligence
     */
    select?: AICompanyIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICompanyIntelligence
     */
    omit?: AICompanyIntelligenceOmit<ExtArgs> | null
  }


  /**
   * Model AIStrategyPerformance
   */

  export type AggregateAIStrategyPerformance = {
    _count: AIStrategyPerformanceCountAggregateOutputType | null
    _avg: AIStrategyPerformanceAvgAggregateOutputType | null
    _sum: AIStrategyPerformanceSumAggregateOutputType | null
    _min: AIStrategyPerformanceMinAggregateOutputType | null
    _max: AIStrategyPerformanceMaxAggregateOutputType | null
  }

  export type AIStrategyPerformanceAvgAggregateOutputType = {
    timesUsed: number | null
    avgEffectiveness: number | null
    conversionRate: number | null
    avgEngagement: number | null
  }

  export type AIStrategyPerformanceSumAggregateOutputType = {
    timesUsed: number | null
    avgEffectiveness: number | null
    conversionRate: number | null
    avgEngagement: number | null
  }

  export type AIStrategyPerformanceMinAggregateOutputType = {
    id: string | null
    strategy: string | null
    industry: string | null
    companySize: $Enums.CompanySize | null
    clientType: string | null
    timesUsed: number | null
    avgEffectiveness: number | null
    conversionRate: number | null
    avgEngagement: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIStrategyPerformanceMaxAggregateOutputType = {
    id: string | null
    strategy: string | null
    industry: string | null
    companySize: $Enums.CompanySize | null
    clientType: string | null
    timesUsed: number | null
    avgEffectiveness: number | null
    conversionRate: number | null
    avgEngagement: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIStrategyPerformanceCountAggregateOutputType = {
    id: number
    strategy: number
    industry: number
    companySize: number
    clientType: number
    timesUsed: number
    avgEffectiveness: number
    conversionRate: number
    avgEngagement: number
    successFactors: number
    failureReasons: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIStrategyPerformanceAvgAggregateInputType = {
    timesUsed?: true
    avgEffectiveness?: true
    conversionRate?: true
    avgEngagement?: true
  }

  export type AIStrategyPerformanceSumAggregateInputType = {
    timesUsed?: true
    avgEffectiveness?: true
    conversionRate?: true
    avgEngagement?: true
  }

  export type AIStrategyPerformanceMinAggregateInputType = {
    id?: true
    strategy?: true
    industry?: true
    companySize?: true
    clientType?: true
    timesUsed?: true
    avgEffectiveness?: true
    conversionRate?: true
    avgEngagement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIStrategyPerformanceMaxAggregateInputType = {
    id?: true
    strategy?: true
    industry?: true
    companySize?: true
    clientType?: true
    timesUsed?: true
    avgEffectiveness?: true
    conversionRate?: true
    avgEngagement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIStrategyPerformanceCountAggregateInputType = {
    id?: true
    strategy?: true
    industry?: true
    companySize?: true
    clientType?: true
    timesUsed?: true
    avgEffectiveness?: true
    conversionRate?: true
    avgEngagement?: true
    successFactors?: true
    failureReasons?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIStrategyPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIStrategyPerformance to aggregate.
     */
    where?: AIStrategyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIStrategyPerformances to fetch.
     */
    orderBy?: AIStrategyPerformanceOrderByWithRelationInput | AIStrategyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIStrategyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIStrategyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIStrategyPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIStrategyPerformances
    **/
    _count?: true | AIStrategyPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIStrategyPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIStrategyPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIStrategyPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIStrategyPerformanceMaxAggregateInputType
  }

  export type GetAIStrategyPerformanceAggregateType<T extends AIStrategyPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAIStrategyPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIStrategyPerformance[P]>
      : GetScalarType<T[P], AggregateAIStrategyPerformance[P]>
  }




  export type AIStrategyPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIStrategyPerformanceWhereInput
    orderBy?: AIStrategyPerformanceOrderByWithAggregationInput | AIStrategyPerformanceOrderByWithAggregationInput[]
    by: AIStrategyPerformanceScalarFieldEnum[] | AIStrategyPerformanceScalarFieldEnum
    having?: AIStrategyPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIStrategyPerformanceCountAggregateInputType | true
    _avg?: AIStrategyPerformanceAvgAggregateInputType
    _sum?: AIStrategyPerformanceSumAggregateInputType
    _min?: AIStrategyPerformanceMinAggregateInputType
    _max?: AIStrategyPerformanceMaxAggregateInputType
  }

  export type AIStrategyPerformanceGroupByOutputType = {
    id: string
    strategy: string
    industry: string | null
    companySize: $Enums.CompanySize | null
    clientType: string | null
    timesUsed: number
    avgEffectiveness: number
    conversionRate: number | null
    avgEngagement: number | null
    successFactors: JsonValue | null
    failureReasons: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AIStrategyPerformanceCountAggregateOutputType | null
    _avg: AIStrategyPerformanceAvgAggregateOutputType | null
    _sum: AIStrategyPerformanceSumAggregateOutputType | null
    _min: AIStrategyPerformanceMinAggregateOutputType | null
    _max: AIStrategyPerformanceMaxAggregateOutputType | null
  }

  type GetAIStrategyPerformanceGroupByPayload<T extends AIStrategyPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIStrategyPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIStrategyPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIStrategyPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], AIStrategyPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type AIStrategyPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategy?: boolean
    industry?: boolean
    companySize?: boolean
    clientType?: boolean
    timesUsed?: boolean
    avgEffectiveness?: boolean
    conversionRate?: boolean
    avgEngagement?: boolean
    successFactors?: boolean
    failureReasons?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIStrategyPerformance"]>

  export type AIStrategyPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategy?: boolean
    industry?: boolean
    companySize?: boolean
    clientType?: boolean
    timesUsed?: boolean
    avgEffectiveness?: boolean
    conversionRate?: boolean
    avgEngagement?: boolean
    successFactors?: boolean
    failureReasons?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIStrategyPerformance"]>


  export type AIStrategyPerformanceSelectScalar = {
    id?: boolean
    strategy?: boolean
    industry?: boolean
    companySize?: boolean
    clientType?: boolean
    timesUsed?: boolean
    avgEffectiveness?: boolean
    conversionRate?: boolean
    avgEngagement?: boolean
    successFactors?: boolean
    failureReasons?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIStrategyPerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "strategy" | "industry" | "companySize" | "clientType" | "timesUsed" | "avgEffectiveness" | "conversionRate" | "avgEngagement" | "successFactors" | "failureReasons" | "createdAt" | "updatedAt", ExtArgs["result"]["aIStrategyPerformance"]>

  export type $AIStrategyPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIStrategyPerformance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategy: string
      industry: string | null
      companySize: $Enums.CompanySize | null
      clientType: string | null
      timesUsed: number
      avgEffectiveness: number
      conversionRate: number | null
      avgEngagement: number | null
      successFactors: Prisma.JsonValue | null
      failureReasons: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIStrategyPerformance"]>
    composites: {}
  }

  type AIStrategyPerformanceGetPayload<S extends boolean | null | undefined | AIStrategyPerformanceDefaultArgs> = $Result.GetResult<Prisma.$AIStrategyPerformancePayload, S>

  type AIStrategyPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIStrategyPerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIStrategyPerformanceCountAggregateInputType | true
    }

  export interface AIStrategyPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIStrategyPerformance'], meta: { name: 'AIStrategyPerformance' } }
    /**
     * Find zero or one AIStrategyPerformance that matches the filter.
     * @param {AIStrategyPerformanceFindUniqueArgs} args - Arguments to find a AIStrategyPerformance
     * @example
     * // Get one AIStrategyPerformance
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIStrategyPerformanceFindUniqueArgs>(args: SelectSubset<T, AIStrategyPerformanceFindUniqueArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIStrategyPerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIStrategyPerformanceFindUniqueOrThrowArgs} args - Arguments to find a AIStrategyPerformance
     * @example
     * // Get one AIStrategyPerformance
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIStrategyPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AIStrategyPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIStrategyPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIStrategyPerformanceFindFirstArgs} args - Arguments to find a AIStrategyPerformance
     * @example
     * // Get one AIStrategyPerformance
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIStrategyPerformanceFindFirstArgs>(args?: SelectSubset<T, AIStrategyPerformanceFindFirstArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIStrategyPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIStrategyPerformanceFindFirstOrThrowArgs} args - Arguments to find a AIStrategyPerformance
     * @example
     * // Get one AIStrategyPerformance
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIStrategyPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AIStrategyPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIStrategyPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIStrategyPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIStrategyPerformances
     * const aIStrategyPerformances = await prisma.aIStrategyPerformance.findMany()
     * 
     * // Get first 10 AIStrategyPerformances
     * const aIStrategyPerformances = await prisma.aIStrategyPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIStrategyPerformanceWithIdOnly = await prisma.aIStrategyPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIStrategyPerformanceFindManyArgs>(args?: SelectSubset<T, AIStrategyPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIStrategyPerformance.
     * @param {AIStrategyPerformanceCreateArgs} args - Arguments to create a AIStrategyPerformance.
     * @example
     * // Create one AIStrategyPerformance
     * const AIStrategyPerformance = await prisma.aIStrategyPerformance.create({
     *   data: {
     *     // ... data to create a AIStrategyPerformance
     *   }
     * })
     * 
     */
    create<T extends AIStrategyPerformanceCreateArgs>(args: SelectSubset<T, AIStrategyPerformanceCreateArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIStrategyPerformances.
     * @param {AIStrategyPerformanceCreateManyArgs} args - Arguments to create many AIStrategyPerformances.
     * @example
     * // Create many AIStrategyPerformances
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIStrategyPerformanceCreateManyArgs>(args?: SelectSubset<T, AIStrategyPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIStrategyPerformances and returns the data saved in the database.
     * @param {AIStrategyPerformanceCreateManyAndReturnArgs} args - Arguments to create many AIStrategyPerformances.
     * @example
     * // Create many AIStrategyPerformances
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIStrategyPerformances and only return the `id`
     * const aIStrategyPerformanceWithIdOnly = await prisma.aIStrategyPerformance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIStrategyPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AIStrategyPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIStrategyPerformance.
     * @param {AIStrategyPerformanceDeleteArgs} args - Arguments to delete one AIStrategyPerformance.
     * @example
     * // Delete one AIStrategyPerformance
     * const AIStrategyPerformance = await prisma.aIStrategyPerformance.delete({
     *   where: {
     *     // ... filter to delete one AIStrategyPerformance
     *   }
     * })
     * 
     */
    delete<T extends AIStrategyPerformanceDeleteArgs>(args: SelectSubset<T, AIStrategyPerformanceDeleteArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIStrategyPerformance.
     * @param {AIStrategyPerformanceUpdateArgs} args - Arguments to update one AIStrategyPerformance.
     * @example
     * // Update one AIStrategyPerformance
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIStrategyPerformanceUpdateArgs>(args: SelectSubset<T, AIStrategyPerformanceUpdateArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIStrategyPerformances.
     * @param {AIStrategyPerformanceDeleteManyArgs} args - Arguments to filter AIStrategyPerformances to delete.
     * @example
     * // Delete a few AIStrategyPerformances
     * const { count } = await prisma.aIStrategyPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIStrategyPerformanceDeleteManyArgs>(args?: SelectSubset<T, AIStrategyPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIStrategyPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIStrategyPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIStrategyPerformances
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIStrategyPerformanceUpdateManyArgs>(args: SelectSubset<T, AIStrategyPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIStrategyPerformance.
     * @param {AIStrategyPerformanceUpsertArgs} args - Arguments to update or create a AIStrategyPerformance.
     * @example
     * // Update or create a AIStrategyPerformance
     * const aIStrategyPerformance = await prisma.aIStrategyPerformance.upsert({
     *   create: {
     *     // ... data to create a AIStrategyPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIStrategyPerformance we want to update
     *   }
     * })
     */
    upsert<T extends AIStrategyPerformanceUpsertArgs>(args: SelectSubset<T, AIStrategyPerformanceUpsertArgs<ExtArgs>>): Prisma__AIStrategyPerformanceClient<$Result.GetResult<Prisma.$AIStrategyPerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIStrategyPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIStrategyPerformanceCountArgs} args - Arguments to filter AIStrategyPerformances to count.
     * @example
     * // Count the number of AIStrategyPerformances
     * const count = await prisma.aIStrategyPerformance.count({
     *   where: {
     *     // ... the filter for the AIStrategyPerformances we want to count
     *   }
     * })
    **/
    count<T extends AIStrategyPerformanceCountArgs>(
      args?: Subset<T, AIStrategyPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIStrategyPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIStrategyPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIStrategyPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIStrategyPerformanceAggregateArgs>(args: Subset<T, AIStrategyPerformanceAggregateArgs>): Prisma.PrismaPromise<GetAIStrategyPerformanceAggregateType<T>>

    /**
     * Group by AIStrategyPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIStrategyPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIStrategyPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIStrategyPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: AIStrategyPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIStrategyPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIStrategyPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIStrategyPerformance model
   */
  readonly fields: AIStrategyPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIStrategyPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIStrategyPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIStrategyPerformance model
   */
  interface AIStrategyPerformanceFieldRefs {
    readonly id: FieldRef<"AIStrategyPerformance", 'String'>
    readonly strategy: FieldRef<"AIStrategyPerformance", 'String'>
    readonly industry: FieldRef<"AIStrategyPerformance", 'String'>
    readonly companySize: FieldRef<"AIStrategyPerformance", 'CompanySize'>
    readonly clientType: FieldRef<"AIStrategyPerformance", 'String'>
    readonly timesUsed: FieldRef<"AIStrategyPerformance", 'Int'>
    readonly avgEffectiveness: FieldRef<"AIStrategyPerformance", 'Float'>
    readonly conversionRate: FieldRef<"AIStrategyPerformance", 'Float'>
    readonly avgEngagement: FieldRef<"AIStrategyPerformance", 'Float'>
    readonly successFactors: FieldRef<"AIStrategyPerformance", 'Json'>
    readonly failureReasons: FieldRef<"AIStrategyPerformance", 'Json'>
    readonly createdAt: FieldRef<"AIStrategyPerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"AIStrategyPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIStrategyPerformance findUnique
   */
  export type AIStrategyPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AIStrategyPerformance to fetch.
     */
    where: AIStrategyPerformanceWhereUniqueInput
  }

  /**
   * AIStrategyPerformance findUniqueOrThrow
   */
  export type AIStrategyPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AIStrategyPerformance to fetch.
     */
    where: AIStrategyPerformanceWhereUniqueInput
  }

  /**
   * AIStrategyPerformance findFirst
   */
  export type AIStrategyPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AIStrategyPerformance to fetch.
     */
    where?: AIStrategyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIStrategyPerformances to fetch.
     */
    orderBy?: AIStrategyPerformanceOrderByWithRelationInput | AIStrategyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIStrategyPerformances.
     */
    cursor?: AIStrategyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIStrategyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIStrategyPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIStrategyPerformances.
     */
    distinct?: AIStrategyPerformanceScalarFieldEnum | AIStrategyPerformanceScalarFieldEnum[]
  }

  /**
   * AIStrategyPerformance findFirstOrThrow
   */
  export type AIStrategyPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AIStrategyPerformance to fetch.
     */
    where?: AIStrategyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIStrategyPerformances to fetch.
     */
    orderBy?: AIStrategyPerformanceOrderByWithRelationInput | AIStrategyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIStrategyPerformances.
     */
    cursor?: AIStrategyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIStrategyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIStrategyPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIStrategyPerformances.
     */
    distinct?: AIStrategyPerformanceScalarFieldEnum | AIStrategyPerformanceScalarFieldEnum[]
  }

  /**
   * AIStrategyPerformance findMany
   */
  export type AIStrategyPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AIStrategyPerformances to fetch.
     */
    where?: AIStrategyPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIStrategyPerformances to fetch.
     */
    orderBy?: AIStrategyPerformanceOrderByWithRelationInput | AIStrategyPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIStrategyPerformances.
     */
    cursor?: AIStrategyPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIStrategyPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIStrategyPerformances.
     */
    skip?: number
    distinct?: AIStrategyPerformanceScalarFieldEnum | AIStrategyPerformanceScalarFieldEnum[]
  }

  /**
   * AIStrategyPerformance create
   */
  export type AIStrategyPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * The data needed to create a AIStrategyPerformance.
     */
    data: XOR<AIStrategyPerformanceCreateInput, AIStrategyPerformanceUncheckedCreateInput>
  }

  /**
   * AIStrategyPerformance createMany
   */
  export type AIStrategyPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIStrategyPerformances.
     */
    data: AIStrategyPerformanceCreateManyInput | AIStrategyPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIStrategyPerformance createManyAndReturn
   */
  export type AIStrategyPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many AIStrategyPerformances.
     */
    data: AIStrategyPerformanceCreateManyInput | AIStrategyPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIStrategyPerformance update
   */
  export type AIStrategyPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * The data needed to update a AIStrategyPerformance.
     */
    data: XOR<AIStrategyPerformanceUpdateInput, AIStrategyPerformanceUncheckedUpdateInput>
    /**
     * Choose, which AIStrategyPerformance to update.
     */
    where: AIStrategyPerformanceWhereUniqueInput
  }

  /**
   * AIStrategyPerformance updateMany
   */
  export type AIStrategyPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIStrategyPerformances.
     */
    data: XOR<AIStrategyPerformanceUpdateManyMutationInput, AIStrategyPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which AIStrategyPerformances to update
     */
    where?: AIStrategyPerformanceWhereInput
  }

  /**
   * AIStrategyPerformance upsert
   */
  export type AIStrategyPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * The filter to search for the AIStrategyPerformance to update in case it exists.
     */
    where: AIStrategyPerformanceWhereUniqueInput
    /**
     * In case the AIStrategyPerformance found by the `where` argument doesn't exist, create a new AIStrategyPerformance with this data.
     */
    create: XOR<AIStrategyPerformanceCreateInput, AIStrategyPerformanceUncheckedCreateInput>
    /**
     * In case the AIStrategyPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIStrategyPerformanceUpdateInput, AIStrategyPerformanceUncheckedUpdateInput>
  }

  /**
   * AIStrategyPerformance delete
   */
  export type AIStrategyPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
    /**
     * Filter which AIStrategyPerformance to delete.
     */
    where: AIStrategyPerformanceWhereUniqueInput
  }

  /**
   * AIStrategyPerformance deleteMany
   */
  export type AIStrategyPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIStrategyPerformances to delete
     */
    where?: AIStrategyPerformanceWhereInput
  }

  /**
   * AIStrategyPerformance without action
   */
  export type AIStrategyPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIStrategyPerformance
     */
    select?: AIStrategyPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIStrategyPerformance
     */
    omit?: AIStrategyPerformanceOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    companyName: 'companyName',
    phone: 'phone',
    role: 'role',
    bcCustomerId: 'bcCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProductDocAssetScalarFieldEnum: {
    id: 'id',
    bcProductId: 'bcProductId',
    sku: 'sku',
    docType: 'docType',
    title: 'title',
    url: 'url',
    version: 'version',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductDocAssetScalarFieldEnum = (typeof ProductDocAssetScalarFieldEnum)[keyof typeof ProductDocAssetScalarFieldEnum]


  export const CaseScalarFieldEnum: {
    id: 'id',
    caseNumber: 'caseNumber',
    type: 'type',
    status: 'status',
    priority: 'priority',
    slaDueAt: 'slaDueAt',
    slaBreached: 'slaBreached',
    customerId: 'customerId',
    contactEmail: 'contactEmail',
    companyName: 'companyName',
    subject: 'subject',
    customerMessage: 'customerMessage',
    internalNotes: 'internalNotes',
    relatedSkus: 'relatedSkus',
    relatedOrderIds: 'relatedOrderIds',
    assignedToId: 'assignedToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    closedAt: 'closedAt'
  };

  export type CaseScalarFieldEnum = (typeof CaseScalarFieldEnum)[keyof typeof CaseScalarFieldEnum]


  export const CaseAttachmentScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    filename: 'filename',
    url: 'url',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt'
  };

  export type CaseAttachmentScalarFieldEnum = (typeof CaseAttachmentScalarFieldEnum)[keyof typeof CaseAttachmentScalarFieldEnum]


  export const CaseMessageScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    senderId: 'senderId',
    senderName: 'senderName',
    senderRole: 'senderRole',
    message: 'message',
    isInternal: 'isInternal',
    createdAt: 'createdAt'
  };

  export type CaseMessageScalarFieldEnum = (typeof CaseMessageScalarFieldEnum)[keyof typeof CaseMessageScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    quoteNumber: 'quoteNumber',
    version: 'version',
    customerId: 'customerId',
    caseId: 'caseId',
    projectId: 'projectId',
    status: 'status',
    validUntil: 'validUntil',
    items: 'items',
    subtotal: 'subtotal',
    discountAmount: 'discountAmount',
    discountPercent: 'discountPercent',
    shippingAmount: 'shippingAmount',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    shippingTerms: 'shippingTerms',
    leadTimeTerms: 'leadTimeTerms',
    paymentTerms: 'paymentTerms',
    exceptions: 'exceptions',
    acceptedAt: 'acceptedAt',
    acceptedBy: 'acceptedBy',
    bcOrderId: 'bcOrderId',
    createdById: 'createdById',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    projectName: 'projectName',
    customerId: 'customerId',
    siteAddress: 'siteAddress',
    savedSkus: 'savedSkus',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const SpecPackageScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    skus: 'skus',
    zipUrl: 'zipUrl',
    generatedAt: 'generatedAt',
    createdAt: 'createdAt'
  };

  export type SpecPackageScalarFieldEnum = (typeof SpecPackageScalarFieldEnum)[keyof typeof SpecPackageScalarFieldEnum]


  export const TaxExemptDocumentScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    state: 'state',
    documentUrl: 'documentUrl',
    documentType: 'documentType',
    status: 'status',
    expiresAt: 'expiresAt',
    reviewedById: 'reviewedById',
    reviewedAt: 'reviewedAt',
    rejectionReason: 'rejectionReason',
    auditLog: 'auditLog',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxExemptDocumentScalarFieldEnum = (typeof TaxExemptDocumentScalarFieldEnum)[keyof typeof TaxExemptDocumentScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    partnerType: 'partnerType',
    companyName: 'companyName',
    status: 'status',
    referralCode: 'referralCode',
    commissionRate: 'commissionRate',
    approvedAt: 'approvedAt',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const PartnerAttributionScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    bcOrderId: 'bcOrderId',
    orderTotal: 'orderTotal',
    commission: 'commission',
    paidAt: 'paidAt',
    createdAt: 'createdAt'
  };

  export type PartnerAttributionScalarFieldEnum = (typeof PartnerAttributionScalarFieldEnum)[keyof typeof PartnerAttributionScalarFieldEnum]


  export const QboSyncLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    sourceId: 'sourceId',
    qboId: 'qboId',
    status: 'status',
    attempts: 'attempts',
    lastError: 'lastError',
    lastAttemptAt: 'lastAttemptAt',
    payload: 'payload',
    response: 'response',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QboSyncLogScalarFieldEnum = (typeof QboSyncLogScalarFieldEnum)[keyof typeof QboSyncLogScalarFieldEnum]


  export const ShippingSyncLogScalarFieldEnum: {
    id: 'id',
    bcOrderId: 'bcOrderId',
    shipmentId: 'shipmentId',
    carrier: 'carrier',
    trackingNumber: 'trackingNumber',
    status: 'status',
    attempts: 'attempts',
    lastError: 'lastError',
    lastAttemptAt: 'lastAttemptAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingSyncLogScalarFieldEnum = (typeof ShippingSyncLogScalarFieldEnum)[keyof typeof ShippingSyncLogScalarFieldEnum]


  export const KnowledgeBaseEntryScalarFieldEnum: {
    id: 'id',
    category: 'category',
    title: 'title',
    content: 'content',
    sourceUrl: 'sourceUrl',
    embedding: 'embedding',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeBaseEntryScalarFieldEnum = (typeof KnowledgeBaseEntryScalarFieldEnum)[keyof typeof KnowledgeBaseEntryScalarFieldEnum]


  export const AIChatLogScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    userMessage: 'userMessage',
    aiResponse: 'aiResponse',
    sourcesUsed: 'sourcesUsed',
    handoffCaseId: 'handoffCaseId',
    feedbackRating: 'feedbackRating',
    createdAt: 'createdAt'
  };

  export type AIChatLogScalarFieldEnum = (typeof AIChatLogScalarFieldEnum)[keyof typeof AIChatLogScalarFieldEnum]


  export const CaseStudyScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    category: 'category',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    highlights: 'highlights',
    product: 'product',
    productSlug: 'productSlug',
    clients: 'clients',
    location: 'location',
    images: 'images',
    youtubeId: 'youtubeId',
    stats: 'stats',
    sortOrder: 'sortOrder',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CaseStudyScalarFieldEnum = (typeof CaseStudyScalarFieldEnum)[keyof typeof CaseStudyScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    eventName: 'eventName',
    userId: 'userId',
    sessionId: 'sessionId',
    properties: 'properties',
    createdAt: 'createdAt'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const AIClientProfileScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    website: 'website',
    position: 'position',
    industry: 'industry',
    companySize: 'companySize',
    communicationStyle: 'communicationStyle',
    decisionSpeed: 'decisionSpeed',
    techLevel: 'techLevel',
    priceSensitivity: 'priceSensitivity',
    avgResponseTime: 'avgResponseTime',
    messageLength: 'messageLength',
    interestLevel: 'interestLevel',
    painPoints: 'painPoints',
    budget: 'budget',
    timeline: 'timeline',
    competitors: 'competitors',
    conversationSummary: 'conversationSummary',
    totalMessages: 'totalMessages',
    avgSentiment: 'avgSentiment',
    avgEngagement: 'avgEngagement',
    strategyEffectiveness: 'strategyEffectiveness',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastActiveAt: 'lastActiveAt'
  };

  export type AIClientProfileScalarFieldEnum = (typeof AIClientProfileScalarFieldEnum)[keyof typeof AIClientProfileScalarFieldEnum]


  export const AIConversationScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    profileId: 'profileId',
    role: 'role',
    content: 'content',
    messageType: 'messageType',
    attachments: 'attachments',
    sentiment: 'sentiment',
    engagement: 'engagement',
    intent: 'intent',
    urgency: 'urgency',
    strategy: 'strategy',
    effectiveness: 'effectiveness',
    createdAt: 'createdAt'
  };

  export type AIConversationScalarFieldEnum = (typeof AIConversationScalarFieldEnum)[keyof typeof AIConversationScalarFieldEnum]


  export const AILeadDataScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    leadScore: 'leadScore',
    leadStatus: 'leadStatus',
    estimatedValue: 'estimatedValue',
    salesStage: 'salesStage',
    nextAction: 'nextAction',
    notes: 'notes',
    assignedTo: 'assignedTo',
    followUpAt: 'followUpAt',
    convertedAt: 'convertedAt',
    conversionValue: 'conversionValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AILeadDataScalarFieldEnum = (typeof AILeadDataScalarFieldEnum)[keyof typeof AILeadDataScalarFieldEnum]


  export const AICompanyIntelligenceScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    website: 'website',
    industry: 'industry',
    size: 'size',
    description: 'description',
    painPoints: 'painPoints',
    budgetEstimate: 'budgetEstimate',
    decisionMakers: 'decisionMakers',
    competitors: 'competitors',
    recentNews: 'recentNews',
    marketTrends: 'marketTrends',
    phone: 'phone',
    email: 'email',
    address: 'address',
    timesAnalyzed: 'timesAnalyzed',
    lastAnalyzed: 'lastAnalyzed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AICompanyIntelligenceScalarFieldEnum = (typeof AICompanyIntelligenceScalarFieldEnum)[keyof typeof AICompanyIntelligenceScalarFieldEnum]


  export const AIStrategyPerformanceScalarFieldEnum: {
    id: 'id',
    strategy: 'strategy',
    industry: 'industry',
    companySize: 'companySize',
    clientType: 'clientType',
    timesUsed: 'timesUsed',
    avgEffectiveness: 'avgEffectiveness',
    conversionRate: 'conversionRate',
    avgEngagement: 'avgEngagement',
    successFactors: 'successFactors',
    failureReasons: 'failureReasons',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIStrategyPerformanceScalarFieldEnum = (typeof AIStrategyPerformanceScalarFieldEnum)[keyof typeof AIStrategyPerformanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DocType'
   */
  export type EnumDocTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocType'>
    


  /**
   * Reference to a field of type 'DocType[]'
   */
  export type ListEnumDocTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CaseType'
   */
  export type EnumCaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseType'>
    


  /**
   * Reference to a field of type 'CaseType[]'
   */
  export type ListEnumCaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseType[]'>
    


  /**
   * Reference to a field of type 'CaseStatus'
   */
  export type EnumCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseStatus'>
    


  /**
   * Reference to a field of type 'CaseStatus[]'
   */
  export type ListEnumCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseStatus[]'>
    


  /**
   * Reference to a field of type 'CasePriority'
   */
  export type EnumCasePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CasePriority'>
    


  /**
   * Reference to a field of type 'CasePriority[]'
   */
  export type ListEnumCasePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CasePriority[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'QuoteStatus'
   */
  export type EnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus'>
    


  /**
   * Reference to a field of type 'QuoteStatus[]'
   */
  export type ListEnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TaxExemptStatus'
   */
  export type EnumTaxExemptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxExemptStatus'>
    


  /**
   * Reference to a field of type 'TaxExemptStatus[]'
   */
  export type ListEnumTaxExemptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxExemptStatus[]'>
    


  /**
   * Reference to a field of type 'PartnerType'
   */
  export type EnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType'>
    


  /**
   * Reference to a field of type 'PartnerType[]'
   */
  export type ListEnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType[]'>
    


  /**
   * Reference to a field of type 'PartnerStatus'
   */
  export type EnumPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerStatus'>
    


  /**
   * Reference to a field of type 'PartnerStatus[]'
   */
  export type ListEnumPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerStatus[]'>
    


  /**
   * Reference to a field of type 'SyncStatus'
   */
  export type EnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus'>
    


  /**
   * Reference to a field of type 'SyncStatus[]'
   */
  export type ListEnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'CompanySize'
   */
  export type EnumCompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySize'>
    


  /**
   * Reference to a field of type 'CompanySize[]'
   */
  export type ListEnumCompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySize[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'SalesStage'
   */
  export type EnumSalesStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalesStage'>
    


  /**
   * Reference to a field of type 'SalesStage[]'
   */
  export type ListEnumSalesStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalesStage[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    companyName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    bcCustomerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cases?: CaseListRelationFilter
    quotes?: QuoteListRelationFilter
    projects?: ProjectListRelationFilter
    taxExemptDocuments?: TaxExemptDocumentListRelationFilter
    assignedCases?: CaseListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    bcCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cases?: CaseOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    taxExemptDocuments?: TaxExemptDocumentOrderByRelationAggregateInput
    assignedCases?: CaseOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    bcCustomerId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    companyName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cases?: CaseListRelationFilter
    quotes?: QuoteListRelationFilter
    projects?: ProjectListRelationFilter
    taxExemptDocuments?: TaxExemptDocumentListRelationFilter
    assignedCases?: CaseListRelationFilter
  }, "id" | "email" | "bcCustomerId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    bcCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    bcCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProductDocAssetWhereInput = {
    AND?: ProductDocAssetWhereInput | ProductDocAssetWhereInput[]
    OR?: ProductDocAssetWhereInput[]
    NOT?: ProductDocAssetWhereInput | ProductDocAssetWhereInput[]
    id?: StringFilter<"ProductDocAsset"> | string
    bcProductId?: StringFilter<"ProductDocAsset"> | string
    sku?: StringFilter<"ProductDocAsset"> | string
    docType?: EnumDocTypeFilter<"ProductDocAsset"> | $Enums.DocType
    title?: StringFilter<"ProductDocAsset"> | string
    url?: StringFilter<"ProductDocAsset"> | string
    version?: StringNullableFilter<"ProductDocAsset"> | string | null
    fileSize?: IntNullableFilter<"ProductDocAsset"> | number | null
    mimeType?: StringNullableFilter<"ProductDocAsset"> | string | null
    createdAt?: DateTimeFilter<"ProductDocAsset"> | Date | string
    updatedAt?: DateTimeFilter<"ProductDocAsset"> | Date | string
  }

  export type ProductDocAssetOrderByWithRelationInput = {
    id?: SortOrder
    bcProductId?: SortOrder
    sku?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductDocAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bcProductId_docType_version?: ProductDocAssetBcProductIdDocTypeVersionCompoundUniqueInput
    AND?: ProductDocAssetWhereInput | ProductDocAssetWhereInput[]
    OR?: ProductDocAssetWhereInput[]
    NOT?: ProductDocAssetWhereInput | ProductDocAssetWhereInput[]
    bcProductId?: StringFilter<"ProductDocAsset"> | string
    sku?: StringFilter<"ProductDocAsset"> | string
    docType?: EnumDocTypeFilter<"ProductDocAsset"> | $Enums.DocType
    title?: StringFilter<"ProductDocAsset"> | string
    url?: StringFilter<"ProductDocAsset"> | string
    version?: StringNullableFilter<"ProductDocAsset"> | string | null
    fileSize?: IntNullableFilter<"ProductDocAsset"> | number | null
    mimeType?: StringNullableFilter<"ProductDocAsset"> | string | null
    createdAt?: DateTimeFilter<"ProductDocAsset"> | Date | string
    updatedAt?: DateTimeFilter<"ProductDocAsset"> | Date | string
  }, "id" | "bcProductId_docType_version">

  export type ProductDocAssetOrderByWithAggregationInput = {
    id?: SortOrder
    bcProductId?: SortOrder
    sku?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductDocAssetCountOrderByAggregateInput
    _avg?: ProductDocAssetAvgOrderByAggregateInput
    _max?: ProductDocAssetMaxOrderByAggregateInput
    _min?: ProductDocAssetMinOrderByAggregateInput
    _sum?: ProductDocAssetSumOrderByAggregateInput
  }

  export type ProductDocAssetScalarWhereWithAggregatesInput = {
    AND?: ProductDocAssetScalarWhereWithAggregatesInput | ProductDocAssetScalarWhereWithAggregatesInput[]
    OR?: ProductDocAssetScalarWhereWithAggregatesInput[]
    NOT?: ProductDocAssetScalarWhereWithAggregatesInput | ProductDocAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductDocAsset"> | string
    bcProductId?: StringWithAggregatesFilter<"ProductDocAsset"> | string
    sku?: StringWithAggregatesFilter<"ProductDocAsset"> | string
    docType?: EnumDocTypeWithAggregatesFilter<"ProductDocAsset"> | $Enums.DocType
    title?: StringWithAggregatesFilter<"ProductDocAsset"> | string
    url?: StringWithAggregatesFilter<"ProductDocAsset"> | string
    version?: StringNullableWithAggregatesFilter<"ProductDocAsset"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"ProductDocAsset"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"ProductDocAsset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductDocAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductDocAsset"> | Date | string
  }

  export type CaseWhereInput = {
    AND?: CaseWhereInput | CaseWhereInput[]
    OR?: CaseWhereInput[]
    NOT?: CaseWhereInput | CaseWhereInput[]
    id?: StringFilter<"Case"> | string
    caseNumber?: StringFilter<"Case"> | string
    type?: EnumCaseTypeFilter<"Case"> | $Enums.CaseType
    status?: EnumCaseStatusFilter<"Case"> | $Enums.CaseStatus
    priority?: EnumCasePriorityFilter<"Case"> | $Enums.CasePriority
    slaDueAt?: DateTimeFilter<"Case"> | Date | string
    slaBreached?: BoolFilter<"Case"> | boolean
    customerId?: StringFilter<"Case"> | string
    contactEmail?: StringFilter<"Case"> | string
    companyName?: StringNullableFilter<"Case"> | string | null
    subject?: StringFilter<"Case"> | string
    customerMessage?: StringFilter<"Case"> | string
    internalNotes?: StringNullableFilter<"Case"> | string | null
    relatedSkus?: StringNullableListFilter<"Case">
    relatedOrderIds?: StringNullableListFilter<"Case">
    assignedToId?: StringNullableFilter<"Case"> | string | null
    createdAt?: DateTimeFilter<"Case"> | Date | string
    updatedAt?: DateTimeFilter<"Case"> | Date | string
    closedAt?: DateTimeNullableFilter<"Case"> | Date | string | null
    customer?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    attachments?: CaseAttachmentListRelationFilter
    messages?: CaseMessageListRelationFilter
    quotes?: QuoteListRelationFilter
  }

  export type CaseOrderByWithRelationInput = {
    id?: SortOrder
    caseNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDueAt?: SortOrder
    slaBreached?: SortOrder
    customerId?: SortOrder
    contactEmail?: SortOrder
    companyName?: SortOrderInput | SortOrder
    subject?: SortOrder
    customerMessage?: SortOrder
    internalNotes?: SortOrderInput | SortOrder
    relatedSkus?: SortOrder
    relatedOrderIds?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    customer?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    attachments?: CaseAttachmentOrderByRelationAggregateInput
    messages?: CaseMessageOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
  }

  export type CaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    caseNumber?: string
    AND?: CaseWhereInput | CaseWhereInput[]
    OR?: CaseWhereInput[]
    NOT?: CaseWhereInput | CaseWhereInput[]
    type?: EnumCaseTypeFilter<"Case"> | $Enums.CaseType
    status?: EnumCaseStatusFilter<"Case"> | $Enums.CaseStatus
    priority?: EnumCasePriorityFilter<"Case"> | $Enums.CasePriority
    slaDueAt?: DateTimeFilter<"Case"> | Date | string
    slaBreached?: BoolFilter<"Case"> | boolean
    customerId?: StringFilter<"Case"> | string
    contactEmail?: StringFilter<"Case"> | string
    companyName?: StringNullableFilter<"Case"> | string | null
    subject?: StringFilter<"Case"> | string
    customerMessage?: StringFilter<"Case"> | string
    internalNotes?: StringNullableFilter<"Case"> | string | null
    relatedSkus?: StringNullableListFilter<"Case">
    relatedOrderIds?: StringNullableListFilter<"Case">
    assignedToId?: StringNullableFilter<"Case"> | string | null
    createdAt?: DateTimeFilter<"Case"> | Date | string
    updatedAt?: DateTimeFilter<"Case"> | Date | string
    closedAt?: DateTimeNullableFilter<"Case"> | Date | string | null
    customer?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    attachments?: CaseAttachmentListRelationFilter
    messages?: CaseMessageListRelationFilter
    quotes?: QuoteListRelationFilter
  }, "id" | "caseNumber">

  export type CaseOrderByWithAggregationInput = {
    id?: SortOrder
    caseNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDueAt?: SortOrder
    slaBreached?: SortOrder
    customerId?: SortOrder
    contactEmail?: SortOrder
    companyName?: SortOrderInput | SortOrder
    subject?: SortOrder
    customerMessage?: SortOrder
    internalNotes?: SortOrderInput | SortOrder
    relatedSkus?: SortOrder
    relatedOrderIds?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    _count?: CaseCountOrderByAggregateInput
    _max?: CaseMaxOrderByAggregateInput
    _min?: CaseMinOrderByAggregateInput
  }

  export type CaseScalarWhereWithAggregatesInput = {
    AND?: CaseScalarWhereWithAggregatesInput | CaseScalarWhereWithAggregatesInput[]
    OR?: CaseScalarWhereWithAggregatesInput[]
    NOT?: CaseScalarWhereWithAggregatesInput | CaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Case"> | string
    caseNumber?: StringWithAggregatesFilter<"Case"> | string
    type?: EnumCaseTypeWithAggregatesFilter<"Case"> | $Enums.CaseType
    status?: EnumCaseStatusWithAggregatesFilter<"Case"> | $Enums.CaseStatus
    priority?: EnumCasePriorityWithAggregatesFilter<"Case"> | $Enums.CasePriority
    slaDueAt?: DateTimeWithAggregatesFilter<"Case"> | Date | string
    slaBreached?: BoolWithAggregatesFilter<"Case"> | boolean
    customerId?: StringWithAggregatesFilter<"Case"> | string
    contactEmail?: StringWithAggregatesFilter<"Case"> | string
    companyName?: StringNullableWithAggregatesFilter<"Case"> | string | null
    subject?: StringWithAggregatesFilter<"Case"> | string
    customerMessage?: StringWithAggregatesFilter<"Case"> | string
    internalNotes?: StringNullableWithAggregatesFilter<"Case"> | string | null
    relatedSkus?: StringNullableListFilter<"Case">
    relatedOrderIds?: StringNullableListFilter<"Case">
    assignedToId?: StringNullableWithAggregatesFilter<"Case"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Case"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Case"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Case"> | Date | string | null
  }

  export type CaseAttachmentWhereInput = {
    AND?: CaseAttachmentWhereInput | CaseAttachmentWhereInput[]
    OR?: CaseAttachmentWhereInput[]
    NOT?: CaseAttachmentWhereInput | CaseAttachmentWhereInput[]
    id?: StringFilter<"CaseAttachment"> | string
    caseId?: StringFilter<"CaseAttachment"> | string
    filename?: StringFilter<"CaseAttachment"> | string
    url?: StringFilter<"CaseAttachment"> | string
    mimeType?: StringNullableFilter<"CaseAttachment"> | string | null
    fileSize?: IntNullableFilter<"CaseAttachment"> | number | null
    uploadedBy?: StringFilter<"CaseAttachment"> | string
    createdAt?: DateTimeFilter<"CaseAttachment"> | Date | string
    case?: XOR<CaseRelationFilter, CaseWhereInput>
  }

  export type CaseAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    case?: CaseOrderByWithRelationInput
  }

  export type CaseAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CaseAttachmentWhereInput | CaseAttachmentWhereInput[]
    OR?: CaseAttachmentWhereInput[]
    NOT?: CaseAttachmentWhereInput | CaseAttachmentWhereInput[]
    caseId?: StringFilter<"CaseAttachment"> | string
    filename?: StringFilter<"CaseAttachment"> | string
    url?: StringFilter<"CaseAttachment"> | string
    mimeType?: StringNullableFilter<"CaseAttachment"> | string | null
    fileSize?: IntNullableFilter<"CaseAttachment"> | number | null
    uploadedBy?: StringFilter<"CaseAttachment"> | string
    createdAt?: DateTimeFilter<"CaseAttachment"> | Date | string
    case?: XOR<CaseRelationFilter, CaseWhereInput>
  }, "id">

  export type CaseAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    _count?: CaseAttachmentCountOrderByAggregateInput
    _avg?: CaseAttachmentAvgOrderByAggregateInput
    _max?: CaseAttachmentMaxOrderByAggregateInput
    _min?: CaseAttachmentMinOrderByAggregateInput
    _sum?: CaseAttachmentSumOrderByAggregateInput
  }

  export type CaseAttachmentScalarWhereWithAggregatesInput = {
    AND?: CaseAttachmentScalarWhereWithAggregatesInput | CaseAttachmentScalarWhereWithAggregatesInput[]
    OR?: CaseAttachmentScalarWhereWithAggregatesInput[]
    NOT?: CaseAttachmentScalarWhereWithAggregatesInput | CaseAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseAttachment"> | string
    caseId?: StringWithAggregatesFilter<"CaseAttachment"> | string
    filename?: StringWithAggregatesFilter<"CaseAttachment"> | string
    url?: StringWithAggregatesFilter<"CaseAttachment"> | string
    mimeType?: StringNullableWithAggregatesFilter<"CaseAttachment"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"CaseAttachment"> | number | null
    uploadedBy?: StringWithAggregatesFilter<"CaseAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CaseAttachment"> | Date | string
  }

  export type CaseMessageWhereInput = {
    AND?: CaseMessageWhereInput | CaseMessageWhereInput[]
    OR?: CaseMessageWhereInput[]
    NOT?: CaseMessageWhereInput | CaseMessageWhereInput[]
    id?: StringFilter<"CaseMessage"> | string
    caseId?: StringFilter<"CaseMessage"> | string
    senderId?: StringFilter<"CaseMessage"> | string
    senderName?: StringFilter<"CaseMessage"> | string
    senderRole?: EnumUserRoleFilter<"CaseMessage"> | $Enums.UserRole
    message?: StringFilter<"CaseMessage"> | string
    isInternal?: BoolFilter<"CaseMessage"> | boolean
    createdAt?: DateTimeFilter<"CaseMessage"> | Date | string
    case?: XOR<CaseRelationFilter, CaseWhereInput>
  }

  export type CaseMessageOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    case?: CaseOrderByWithRelationInput
  }

  export type CaseMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CaseMessageWhereInput | CaseMessageWhereInput[]
    OR?: CaseMessageWhereInput[]
    NOT?: CaseMessageWhereInput | CaseMessageWhereInput[]
    caseId?: StringFilter<"CaseMessage"> | string
    senderId?: StringFilter<"CaseMessage"> | string
    senderName?: StringFilter<"CaseMessage"> | string
    senderRole?: EnumUserRoleFilter<"CaseMessage"> | $Enums.UserRole
    message?: StringFilter<"CaseMessage"> | string
    isInternal?: BoolFilter<"CaseMessage"> | boolean
    createdAt?: DateTimeFilter<"CaseMessage"> | Date | string
    case?: XOR<CaseRelationFilter, CaseWhereInput>
  }, "id">

  export type CaseMessageOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    _count?: CaseMessageCountOrderByAggregateInput
    _max?: CaseMessageMaxOrderByAggregateInput
    _min?: CaseMessageMinOrderByAggregateInput
  }

  export type CaseMessageScalarWhereWithAggregatesInput = {
    AND?: CaseMessageScalarWhereWithAggregatesInput | CaseMessageScalarWhereWithAggregatesInput[]
    OR?: CaseMessageScalarWhereWithAggregatesInput[]
    NOT?: CaseMessageScalarWhereWithAggregatesInput | CaseMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseMessage"> | string
    caseId?: StringWithAggregatesFilter<"CaseMessage"> | string
    senderId?: StringWithAggregatesFilter<"CaseMessage"> | string
    senderName?: StringWithAggregatesFilter<"CaseMessage"> | string
    senderRole?: EnumUserRoleWithAggregatesFilter<"CaseMessage"> | $Enums.UserRole
    message?: StringWithAggregatesFilter<"CaseMessage"> | string
    isInternal?: BoolWithAggregatesFilter<"CaseMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CaseMessage"> | Date | string
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: StringFilter<"Quote"> | string
    quoteNumber?: StringFilter<"Quote"> | string
    version?: IntFilter<"Quote"> | number
    customerId?: StringFilter<"Quote"> | string
    caseId?: StringNullableFilter<"Quote"> | string | null
    projectId?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    items?: JsonFilter<"Quote">
    subtotal?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountPercent?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    taxAmount?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    shippingTerms?: StringNullableFilter<"Quote"> | string | null
    leadTimeTerms?: StringNullableFilter<"Quote"> | string | null
    paymentTerms?: StringNullableFilter<"Quote"> | string | null
    exceptions?: StringNullableFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    acceptedBy?: StringNullableFilter<"Quote"> | string | null
    bcOrderId?: StringNullableFilter<"Quote"> | string | null
    createdById?: StringFilter<"Quote"> | string
    notes?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    case?: XOR<CaseNullableRelationFilter, CaseWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    customerId?: SortOrder
    caseId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountPercent?: SortOrderInput | SortOrder
    shippingAmount?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    shippingTerms?: SortOrderInput | SortOrder
    leadTimeTerms?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    exceptions?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    acceptedBy?: SortOrderInput | SortOrder
    bcOrderId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    case?: CaseOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quoteNumber?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    version?: IntFilter<"Quote"> | number
    customerId?: StringFilter<"Quote"> | string
    caseId?: StringNullableFilter<"Quote"> | string | null
    projectId?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    items?: JsonFilter<"Quote">
    subtotal?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountPercent?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    taxAmount?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    shippingTerms?: StringNullableFilter<"Quote"> | string | null
    leadTimeTerms?: StringNullableFilter<"Quote"> | string | null
    paymentTerms?: StringNullableFilter<"Quote"> | string | null
    exceptions?: StringNullableFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    acceptedBy?: StringNullableFilter<"Quote"> | string | null
    bcOrderId?: StringNullableFilter<"Quote"> | string | null
    createdById?: StringFilter<"Quote"> | string
    notes?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    case?: XOR<CaseNullableRelationFilter, CaseWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id" | "quoteNumber">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    customerId?: SortOrder
    caseId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountPercent?: SortOrderInput | SortOrder
    shippingAmount?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    shippingTerms?: SortOrderInput | SortOrder
    leadTimeTerms?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    exceptions?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    acceptedBy?: SortOrderInput | SortOrder
    bcOrderId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quote"> | string
    quoteNumber?: StringWithAggregatesFilter<"Quote"> | string
    version?: IntWithAggregatesFilter<"Quote"> | number
    customerId?: StringWithAggregatesFilter<"Quote"> | string
    caseId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    status?: EnumQuoteStatusWithAggregatesFilter<"Quote"> | $Enums.QuoteStatus
    validUntil?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    items?: JsonWithAggregatesFilter<"Quote">
    subtotal?: DecimalWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountPercent?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    taxAmount?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    shippingTerms?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    leadTimeTerms?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    exceptions?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    acceptedBy?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    bcOrderId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    createdById?: StringWithAggregatesFilter<"Quote"> | string
    notes?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    projectName?: StringFilter<"Project"> | string
    customerId?: StringFilter<"Project"> | string
    siteAddress?: StringNullableFilter<"Project"> | string | null
    savedSkus?: StringNullableListFilter<"Project">
    notes?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    quotes?: QuoteListRelationFilter
    specPackages?: SpecPackageListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    projectName?: SortOrder
    customerId?: SortOrder
    siteAddress?: SortOrderInput | SortOrder
    savedSkus?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    quotes?: QuoteOrderByRelationAggregateInput
    specPackages?: SpecPackageOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    projectName?: StringFilter<"Project"> | string
    customerId?: StringFilter<"Project"> | string
    siteAddress?: StringNullableFilter<"Project"> | string | null
    savedSkus?: StringNullableListFilter<"Project">
    notes?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    quotes?: QuoteListRelationFilter
    specPackages?: SpecPackageListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    projectName?: SortOrder
    customerId?: SortOrder
    siteAddress?: SortOrderInput | SortOrder
    savedSkus?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    projectName?: StringWithAggregatesFilter<"Project"> | string
    customerId?: StringWithAggregatesFilter<"Project"> | string
    siteAddress?: StringNullableWithAggregatesFilter<"Project"> | string | null
    savedSkus?: StringNullableListFilter<"Project">
    notes?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type SpecPackageWhereInput = {
    AND?: SpecPackageWhereInput | SpecPackageWhereInput[]
    OR?: SpecPackageWhereInput[]
    NOT?: SpecPackageWhereInput | SpecPackageWhereInput[]
    id?: StringFilter<"SpecPackage"> | string
    projectId?: StringFilter<"SpecPackage"> | string
    name?: StringFilter<"SpecPackage"> | string
    skus?: StringNullableListFilter<"SpecPackage">
    zipUrl?: StringNullableFilter<"SpecPackage"> | string | null
    generatedAt?: DateTimeNullableFilter<"SpecPackage"> | Date | string | null
    createdAt?: DateTimeFilter<"SpecPackage"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type SpecPackageOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    skus?: SortOrder
    zipUrl?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type SpecPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpecPackageWhereInput | SpecPackageWhereInput[]
    OR?: SpecPackageWhereInput[]
    NOT?: SpecPackageWhereInput | SpecPackageWhereInput[]
    projectId?: StringFilter<"SpecPackage"> | string
    name?: StringFilter<"SpecPackage"> | string
    skus?: StringNullableListFilter<"SpecPackage">
    zipUrl?: StringNullableFilter<"SpecPackage"> | string | null
    generatedAt?: DateTimeNullableFilter<"SpecPackage"> | Date | string | null
    createdAt?: DateTimeFilter<"SpecPackage"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type SpecPackageOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    skus?: SortOrder
    zipUrl?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SpecPackageCountOrderByAggregateInput
    _max?: SpecPackageMaxOrderByAggregateInput
    _min?: SpecPackageMinOrderByAggregateInput
  }

  export type SpecPackageScalarWhereWithAggregatesInput = {
    AND?: SpecPackageScalarWhereWithAggregatesInput | SpecPackageScalarWhereWithAggregatesInput[]
    OR?: SpecPackageScalarWhereWithAggregatesInput[]
    NOT?: SpecPackageScalarWhereWithAggregatesInput | SpecPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpecPackage"> | string
    projectId?: StringWithAggregatesFilter<"SpecPackage"> | string
    name?: StringWithAggregatesFilter<"SpecPackage"> | string
    skus?: StringNullableListFilter<"SpecPackage">
    zipUrl?: StringNullableWithAggregatesFilter<"SpecPackage"> | string | null
    generatedAt?: DateTimeNullableWithAggregatesFilter<"SpecPackage"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SpecPackage"> | Date | string
  }

  export type TaxExemptDocumentWhereInput = {
    AND?: TaxExemptDocumentWhereInput | TaxExemptDocumentWhereInput[]
    OR?: TaxExemptDocumentWhereInput[]
    NOT?: TaxExemptDocumentWhereInput | TaxExemptDocumentWhereInput[]
    id?: StringFilter<"TaxExemptDocument"> | string
    customerId?: StringFilter<"TaxExemptDocument"> | string
    state?: StringFilter<"TaxExemptDocument"> | string
    documentUrl?: StringFilter<"TaxExemptDocument"> | string
    documentType?: StringNullableFilter<"TaxExemptDocument"> | string | null
    status?: EnumTaxExemptStatusFilter<"TaxExemptDocument"> | $Enums.TaxExemptStatus
    expiresAt?: DateTimeNullableFilter<"TaxExemptDocument"> | Date | string | null
    reviewedById?: StringNullableFilter<"TaxExemptDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"TaxExemptDocument"> | Date | string | null
    rejectionReason?: StringNullableFilter<"TaxExemptDocument"> | string | null
    auditLog?: JsonNullableFilter<"TaxExemptDocument">
    createdAt?: DateTimeFilter<"TaxExemptDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TaxExemptDocument"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TaxExemptDocumentOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    state?: SortOrder
    documentUrl?: SortOrder
    documentType?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    auditLog?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
  }

  export type TaxExemptDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxExemptDocumentWhereInput | TaxExemptDocumentWhereInput[]
    OR?: TaxExemptDocumentWhereInput[]
    NOT?: TaxExemptDocumentWhereInput | TaxExemptDocumentWhereInput[]
    customerId?: StringFilter<"TaxExemptDocument"> | string
    state?: StringFilter<"TaxExemptDocument"> | string
    documentUrl?: StringFilter<"TaxExemptDocument"> | string
    documentType?: StringNullableFilter<"TaxExemptDocument"> | string | null
    status?: EnumTaxExemptStatusFilter<"TaxExemptDocument"> | $Enums.TaxExemptStatus
    expiresAt?: DateTimeNullableFilter<"TaxExemptDocument"> | Date | string | null
    reviewedById?: StringNullableFilter<"TaxExemptDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"TaxExemptDocument"> | Date | string | null
    rejectionReason?: StringNullableFilter<"TaxExemptDocument"> | string | null
    auditLog?: JsonNullableFilter<"TaxExemptDocument">
    createdAt?: DateTimeFilter<"TaxExemptDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TaxExemptDocument"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TaxExemptDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    state?: SortOrder
    documentUrl?: SortOrder
    documentType?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    auditLog?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxExemptDocumentCountOrderByAggregateInput
    _max?: TaxExemptDocumentMaxOrderByAggregateInput
    _min?: TaxExemptDocumentMinOrderByAggregateInput
  }

  export type TaxExemptDocumentScalarWhereWithAggregatesInput = {
    AND?: TaxExemptDocumentScalarWhereWithAggregatesInput | TaxExemptDocumentScalarWhereWithAggregatesInput[]
    OR?: TaxExemptDocumentScalarWhereWithAggregatesInput[]
    NOT?: TaxExemptDocumentScalarWhereWithAggregatesInput | TaxExemptDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxExemptDocument"> | string
    customerId?: StringWithAggregatesFilter<"TaxExemptDocument"> | string
    state?: StringWithAggregatesFilter<"TaxExemptDocument"> | string
    documentUrl?: StringWithAggregatesFilter<"TaxExemptDocument"> | string
    documentType?: StringNullableWithAggregatesFilter<"TaxExemptDocument"> | string | null
    status?: EnumTaxExemptStatusWithAggregatesFilter<"TaxExemptDocument"> | $Enums.TaxExemptStatus
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TaxExemptDocument"> | Date | string | null
    reviewedById?: StringNullableWithAggregatesFilter<"TaxExemptDocument"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"TaxExemptDocument"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"TaxExemptDocument"> | string | null
    auditLog?: JsonNullableWithAggregatesFilter<"TaxExemptDocument">
    createdAt?: DateTimeWithAggregatesFilter<"TaxExemptDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxExemptDocument"> | Date | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    userId?: StringFilter<"Partner"> | string
    partnerType?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    companyName?: StringFilter<"Partner"> | string
    status?: EnumPartnerStatusFilter<"Partner"> | $Enums.PartnerStatus
    referralCode?: StringFilter<"Partner"> | string
    commissionRate?: DecimalNullableFilter<"Partner"> | Decimal | DecimalJsLike | number | string | null
    approvedAt?: DateTimeNullableFilter<"Partner"> | Date | string | null
    approvedById?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    attributions?: PartnerAttributionListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerType?: SortOrder
    companyName?: SortOrder
    status?: SortOrder
    referralCode?: SortOrder
    commissionRate?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attributions?: PartnerAttributionOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    referralCode?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    partnerType?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    companyName?: StringFilter<"Partner"> | string
    status?: EnumPartnerStatusFilter<"Partner"> | $Enums.PartnerStatus
    commissionRate?: DecimalNullableFilter<"Partner"> | Decimal | DecimalJsLike | number | string | null
    approvedAt?: DateTimeNullableFilter<"Partner"> | Date | string | null
    approvedById?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    attributions?: PartnerAttributionListRelationFilter
  }, "id" | "userId" | "referralCode">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerType?: SortOrder
    companyName?: SortOrder
    status?: SortOrder
    referralCode?: SortOrder
    commissionRate?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _avg?: PartnerAvgOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
    _sum?: PartnerSumOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    userId?: StringWithAggregatesFilter<"Partner"> | string
    partnerType?: EnumPartnerTypeWithAggregatesFilter<"Partner"> | $Enums.PartnerType
    companyName?: StringWithAggregatesFilter<"Partner"> | string
    status?: EnumPartnerStatusWithAggregatesFilter<"Partner"> | $Enums.PartnerStatus
    referralCode?: StringWithAggregatesFilter<"Partner"> | string
    commissionRate?: DecimalNullableWithAggregatesFilter<"Partner"> | Decimal | DecimalJsLike | number | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Partner"> | Date | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
  }

  export type PartnerAttributionWhereInput = {
    AND?: PartnerAttributionWhereInput | PartnerAttributionWhereInput[]
    OR?: PartnerAttributionWhereInput[]
    NOT?: PartnerAttributionWhereInput | PartnerAttributionWhereInput[]
    id?: StringFilter<"PartnerAttribution"> | string
    partnerId?: StringFilter<"PartnerAttribution"> | string
    bcOrderId?: StringFilter<"PartnerAttribution"> | string
    orderTotal?: DecimalFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"PartnerAttribution"> | Date | string | null
    createdAt?: DateTimeFilter<"PartnerAttribution"> | Date | string
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }

  export type PartnerAttributionOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    bcOrderId?: SortOrder
    orderTotal?: SortOrder
    commission?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    partner?: PartnerOrderByWithRelationInput
  }

  export type PartnerAttributionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerAttributionWhereInput | PartnerAttributionWhereInput[]
    OR?: PartnerAttributionWhereInput[]
    NOT?: PartnerAttributionWhereInput | PartnerAttributionWhereInput[]
    partnerId?: StringFilter<"PartnerAttribution"> | string
    bcOrderId?: StringFilter<"PartnerAttribution"> | string
    orderTotal?: DecimalFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"PartnerAttribution"> | Date | string | null
    createdAt?: DateTimeFilter<"PartnerAttribution"> | Date | string
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }, "id">

  export type PartnerAttributionOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    bcOrderId?: SortOrder
    orderTotal?: SortOrder
    commission?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PartnerAttributionCountOrderByAggregateInput
    _avg?: PartnerAttributionAvgOrderByAggregateInput
    _max?: PartnerAttributionMaxOrderByAggregateInput
    _min?: PartnerAttributionMinOrderByAggregateInput
    _sum?: PartnerAttributionSumOrderByAggregateInput
  }

  export type PartnerAttributionScalarWhereWithAggregatesInput = {
    AND?: PartnerAttributionScalarWhereWithAggregatesInput | PartnerAttributionScalarWhereWithAggregatesInput[]
    OR?: PartnerAttributionScalarWhereWithAggregatesInput[]
    NOT?: PartnerAttributionScalarWhereWithAggregatesInput | PartnerAttributionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerAttribution"> | string
    partnerId?: StringWithAggregatesFilter<"PartnerAttribution"> | string
    bcOrderId?: StringWithAggregatesFilter<"PartnerAttribution"> | string
    orderTotal?: DecimalWithAggregatesFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalWithAggregatesFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"PartnerAttribution"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PartnerAttribution"> | Date | string
  }

  export type QboSyncLogWhereInput = {
    AND?: QboSyncLogWhereInput | QboSyncLogWhereInput[]
    OR?: QboSyncLogWhereInput[]
    NOT?: QboSyncLogWhereInput | QboSyncLogWhereInput[]
    id?: StringFilter<"QboSyncLog"> | string
    entityType?: StringFilter<"QboSyncLog"> | string
    sourceId?: StringFilter<"QboSyncLog"> | string
    qboId?: StringNullableFilter<"QboSyncLog"> | string | null
    status?: EnumSyncStatusFilter<"QboSyncLog"> | $Enums.SyncStatus
    attempts?: IntFilter<"QboSyncLog"> | number
    lastError?: StringNullableFilter<"QboSyncLog"> | string | null
    lastAttemptAt?: DateTimeNullableFilter<"QboSyncLog"> | Date | string | null
    payload?: JsonNullableFilter<"QboSyncLog">
    response?: JsonNullableFilter<"QboSyncLog">
    createdAt?: DateTimeFilter<"QboSyncLog"> | Date | string
    updatedAt?: DateTimeFilter<"QboSyncLog"> | Date | string
  }

  export type QboSyncLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    sourceId?: SortOrder
    qboId?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QboSyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QboSyncLogWhereInput | QboSyncLogWhereInput[]
    OR?: QboSyncLogWhereInput[]
    NOT?: QboSyncLogWhereInput | QboSyncLogWhereInput[]
    entityType?: StringFilter<"QboSyncLog"> | string
    sourceId?: StringFilter<"QboSyncLog"> | string
    qboId?: StringNullableFilter<"QboSyncLog"> | string | null
    status?: EnumSyncStatusFilter<"QboSyncLog"> | $Enums.SyncStatus
    attempts?: IntFilter<"QboSyncLog"> | number
    lastError?: StringNullableFilter<"QboSyncLog"> | string | null
    lastAttemptAt?: DateTimeNullableFilter<"QboSyncLog"> | Date | string | null
    payload?: JsonNullableFilter<"QboSyncLog">
    response?: JsonNullableFilter<"QboSyncLog">
    createdAt?: DateTimeFilter<"QboSyncLog"> | Date | string
    updatedAt?: DateTimeFilter<"QboSyncLog"> | Date | string
  }, "id">

  export type QboSyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    sourceId?: SortOrder
    qboId?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QboSyncLogCountOrderByAggregateInput
    _avg?: QboSyncLogAvgOrderByAggregateInput
    _max?: QboSyncLogMaxOrderByAggregateInput
    _min?: QboSyncLogMinOrderByAggregateInput
    _sum?: QboSyncLogSumOrderByAggregateInput
  }

  export type QboSyncLogScalarWhereWithAggregatesInput = {
    AND?: QboSyncLogScalarWhereWithAggregatesInput | QboSyncLogScalarWhereWithAggregatesInput[]
    OR?: QboSyncLogScalarWhereWithAggregatesInput[]
    NOT?: QboSyncLogScalarWhereWithAggregatesInput | QboSyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QboSyncLog"> | string
    entityType?: StringWithAggregatesFilter<"QboSyncLog"> | string
    sourceId?: StringWithAggregatesFilter<"QboSyncLog"> | string
    qboId?: StringNullableWithAggregatesFilter<"QboSyncLog"> | string | null
    status?: EnumSyncStatusWithAggregatesFilter<"QboSyncLog"> | $Enums.SyncStatus
    attempts?: IntWithAggregatesFilter<"QboSyncLog"> | number
    lastError?: StringNullableWithAggregatesFilter<"QboSyncLog"> | string | null
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"QboSyncLog"> | Date | string | null
    payload?: JsonNullableWithAggregatesFilter<"QboSyncLog">
    response?: JsonNullableWithAggregatesFilter<"QboSyncLog">
    createdAt?: DateTimeWithAggregatesFilter<"QboSyncLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QboSyncLog"> | Date | string
  }

  export type ShippingSyncLogWhereInput = {
    AND?: ShippingSyncLogWhereInput | ShippingSyncLogWhereInput[]
    OR?: ShippingSyncLogWhereInput[]
    NOT?: ShippingSyncLogWhereInput | ShippingSyncLogWhereInput[]
    id?: StringFilter<"ShippingSyncLog"> | string
    bcOrderId?: StringFilter<"ShippingSyncLog"> | string
    shipmentId?: StringNullableFilter<"ShippingSyncLog"> | string | null
    carrier?: StringNullableFilter<"ShippingSyncLog"> | string | null
    trackingNumber?: StringNullableFilter<"ShippingSyncLog"> | string | null
    status?: EnumSyncStatusFilter<"ShippingSyncLog"> | $Enums.SyncStatus
    attempts?: IntFilter<"ShippingSyncLog"> | number
    lastError?: StringNullableFilter<"ShippingSyncLog"> | string | null
    lastAttemptAt?: DateTimeNullableFilter<"ShippingSyncLog"> | Date | string | null
    createdAt?: DateTimeFilter<"ShippingSyncLog"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingSyncLog"> | Date | string
  }

  export type ShippingSyncLogOrderByWithRelationInput = {
    id?: SortOrder
    bcOrderId?: SortOrder
    shipmentId?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingSyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShippingSyncLogWhereInput | ShippingSyncLogWhereInput[]
    OR?: ShippingSyncLogWhereInput[]
    NOT?: ShippingSyncLogWhereInput | ShippingSyncLogWhereInput[]
    bcOrderId?: StringFilter<"ShippingSyncLog"> | string
    shipmentId?: StringNullableFilter<"ShippingSyncLog"> | string | null
    carrier?: StringNullableFilter<"ShippingSyncLog"> | string | null
    trackingNumber?: StringNullableFilter<"ShippingSyncLog"> | string | null
    status?: EnumSyncStatusFilter<"ShippingSyncLog"> | $Enums.SyncStatus
    attempts?: IntFilter<"ShippingSyncLog"> | number
    lastError?: StringNullableFilter<"ShippingSyncLog"> | string | null
    lastAttemptAt?: DateTimeNullableFilter<"ShippingSyncLog"> | Date | string | null
    createdAt?: DateTimeFilter<"ShippingSyncLog"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingSyncLog"> | Date | string
  }, "id">

  export type ShippingSyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    bcOrderId?: SortOrder
    shipmentId?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingSyncLogCountOrderByAggregateInput
    _avg?: ShippingSyncLogAvgOrderByAggregateInput
    _max?: ShippingSyncLogMaxOrderByAggregateInput
    _min?: ShippingSyncLogMinOrderByAggregateInput
    _sum?: ShippingSyncLogSumOrderByAggregateInput
  }

  export type ShippingSyncLogScalarWhereWithAggregatesInput = {
    AND?: ShippingSyncLogScalarWhereWithAggregatesInput | ShippingSyncLogScalarWhereWithAggregatesInput[]
    OR?: ShippingSyncLogScalarWhereWithAggregatesInput[]
    NOT?: ShippingSyncLogScalarWhereWithAggregatesInput | ShippingSyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShippingSyncLog"> | string
    bcOrderId?: StringWithAggregatesFilter<"ShippingSyncLog"> | string
    shipmentId?: StringNullableWithAggregatesFilter<"ShippingSyncLog"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"ShippingSyncLog"> | string | null
    trackingNumber?: StringNullableWithAggregatesFilter<"ShippingSyncLog"> | string | null
    status?: EnumSyncStatusWithAggregatesFilter<"ShippingSyncLog"> | $Enums.SyncStatus
    attempts?: IntWithAggregatesFilter<"ShippingSyncLog"> | number
    lastError?: StringNullableWithAggregatesFilter<"ShippingSyncLog"> | string | null
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"ShippingSyncLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShippingSyncLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingSyncLog"> | Date | string
  }

  export type KnowledgeBaseEntryWhereInput = {
    AND?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    OR?: KnowledgeBaseEntryWhereInput[]
    NOT?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    id?: StringFilter<"KnowledgeBaseEntry"> | string
    category?: StringFilter<"KnowledgeBaseEntry"> | string
    title?: StringFilter<"KnowledgeBaseEntry"> | string
    content?: StringFilter<"KnowledgeBaseEntry"> | string
    sourceUrl?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    embedding?: BytesNullableFilter<"KnowledgeBaseEntry"> | Bytes | null
    isActive?: BoolFilter<"KnowledgeBaseEntry"> | boolean
    createdAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
  }

  export type KnowledgeBaseEntryOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    OR?: KnowledgeBaseEntryWhereInput[]
    NOT?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    category?: StringFilter<"KnowledgeBaseEntry"> | string
    title?: StringFilter<"KnowledgeBaseEntry"> | string
    content?: StringFilter<"KnowledgeBaseEntry"> | string
    sourceUrl?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    embedding?: BytesNullableFilter<"KnowledgeBaseEntry"> | Bytes | null
    isActive?: BoolFilter<"KnowledgeBaseEntry"> | boolean
    createdAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
  }, "id">

  export type KnowledgeBaseEntryOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeBaseEntryCountOrderByAggregateInput
    _max?: KnowledgeBaseEntryMaxOrderByAggregateInput
    _min?: KnowledgeBaseEntryMinOrderByAggregateInput
  }

  export type KnowledgeBaseEntryScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseEntryScalarWhereWithAggregatesInput | KnowledgeBaseEntryScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseEntryScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseEntryScalarWhereWithAggregatesInput | KnowledgeBaseEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    category?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    title?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    content?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    sourceUrl?: StringNullableWithAggregatesFilter<"KnowledgeBaseEntry"> | string | null
    embedding?: BytesNullableWithAggregatesFilter<"KnowledgeBaseEntry"> | Bytes | null
    isActive?: BoolWithAggregatesFilter<"KnowledgeBaseEntry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseEntry"> | Date | string
  }

  export type AIChatLogWhereInput = {
    AND?: AIChatLogWhereInput | AIChatLogWhereInput[]
    OR?: AIChatLogWhereInput[]
    NOT?: AIChatLogWhereInput | AIChatLogWhereInput[]
    id?: StringFilter<"AIChatLog"> | string
    sessionId?: StringFilter<"AIChatLog"> | string
    userId?: StringNullableFilter<"AIChatLog"> | string | null
    userMessage?: StringFilter<"AIChatLog"> | string
    aiResponse?: StringFilter<"AIChatLog"> | string
    sourcesUsed?: StringNullableListFilter<"AIChatLog">
    handoffCaseId?: StringNullableFilter<"AIChatLog"> | string | null
    feedbackRating?: IntNullableFilter<"AIChatLog"> | number | null
    createdAt?: DateTimeFilter<"AIChatLog"> | Date | string
  }

  export type AIChatLogOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    userMessage?: SortOrder
    aiResponse?: SortOrder
    sourcesUsed?: SortOrder
    handoffCaseId?: SortOrderInput | SortOrder
    feedbackRating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AIChatLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIChatLogWhereInput | AIChatLogWhereInput[]
    OR?: AIChatLogWhereInput[]
    NOT?: AIChatLogWhereInput | AIChatLogWhereInput[]
    sessionId?: StringFilter<"AIChatLog"> | string
    userId?: StringNullableFilter<"AIChatLog"> | string | null
    userMessage?: StringFilter<"AIChatLog"> | string
    aiResponse?: StringFilter<"AIChatLog"> | string
    sourcesUsed?: StringNullableListFilter<"AIChatLog">
    handoffCaseId?: StringNullableFilter<"AIChatLog"> | string | null
    feedbackRating?: IntNullableFilter<"AIChatLog"> | number | null
    createdAt?: DateTimeFilter<"AIChatLog"> | Date | string
  }, "id">

  export type AIChatLogOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    userMessage?: SortOrder
    aiResponse?: SortOrder
    sourcesUsed?: SortOrder
    handoffCaseId?: SortOrderInput | SortOrder
    feedbackRating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIChatLogCountOrderByAggregateInput
    _avg?: AIChatLogAvgOrderByAggregateInput
    _max?: AIChatLogMaxOrderByAggregateInput
    _min?: AIChatLogMinOrderByAggregateInput
    _sum?: AIChatLogSumOrderByAggregateInput
  }

  export type AIChatLogScalarWhereWithAggregatesInput = {
    AND?: AIChatLogScalarWhereWithAggregatesInput | AIChatLogScalarWhereWithAggregatesInput[]
    OR?: AIChatLogScalarWhereWithAggregatesInput[]
    NOT?: AIChatLogScalarWhereWithAggregatesInput | AIChatLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIChatLog"> | string
    sessionId?: StringWithAggregatesFilter<"AIChatLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AIChatLog"> | string | null
    userMessage?: StringWithAggregatesFilter<"AIChatLog"> | string
    aiResponse?: StringWithAggregatesFilter<"AIChatLog"> | string
    sourcesUsed?: StringNullableListFilter<"AIChatLog">
    handoffCaseId?: StringNullableWithAggregatesFilter<"AIChatLog"> | string | null
    feedbackRating?: IntNullableWithAggregatesFilter<"AIChatLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AIChatLog"> | Date | string
  }

  export type CaseStudyWhereInput = {
    AND?: CaseStudyWhereInput | CaseStudyWhereInput[]
    OR?: CaseStudyWhereInput[]
    NOT?: CaseStudyWhereInput | CaseStudyWhereInput[]
    id?: StringFilter<"CaseStudy"> | string
    slug?: StringFilter<"CaseStudy"> | string
    category?: StringFilter<"CaseStudy"> | string
    title?: StringFilter<"CaseStudy"> | string
    subtitle?: StringNullableFilter<"CaseStudy"> | string | null
    description?: StringFilter<"CaseStudy"> | string
    highlights?: StringNullableListFilter<"CaseStudy">
    product?: StringNullableFilter<"CaseStudy"> | string | null
    productSlug?: StringNullableFilter<"CaseStudy"> | string | null
    clients?: StringNullableListFilter<"CaseStudy">
    location?: StringNullableFilter<"CaseStudy"> | string | null
    images?: StringNullableListFilter<"CaseStudy">
    youtubeId?: StringNullableFilter<"CaseStudy"> | string | null
    stats?: JsonNullableFilter<"CaseStudy">
    sortOrder?: IntFilter<"CaseStudy"> | number
    isPublished?: BoolFilter<"CaseStudy"> | boolean
    createdAt?: DateTimeFilter<"CaseStudy"> | Date | string
    updatedAt?: DateTimeFilter<"CaseStudy"> | Date | string
  }

  export type CaseStudyOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrder
    highlights?: SortOrder
    product?: SortOrderInput | SortOrder
    productSlug?: SortOrderInput | SortOrder
    clients?: SortOrder
    location?: SortOrderInput | SortOrder
    images?: SortOrder
    youtubeId?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseStudyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CaseStudyWhereInput | CaseStudyWhereInput[]
    OR?: CaseStudyWhereInput[]
    NOT?: CaseStudyWhereInput | CaseStudyWhereInput[]
    category?: StringFilter<"CaseStudy"> | string
    title?: StringFilter<"CaseStudy"> | string
    subtitle?: StringNullableFilter<"CaseStudy"> | string | null
    description?: StringFilter<"CaseStudy"> | string
    highlights?: StringNullableListFilter<"CaseStudy">
    product?: StringNullableFilter<"CaseStudy"> | string | null
    productSlug?: StringNullableFilter<"CaseStudy"> | string | null
    clients?: StringNullableListFilter<"CaseStudy">
    location?: StringNullableFilter<"CaseStudy"> | string | null
    images?: StringNullableListFilter<"CaseStudy">
    youtubeId?: StringNullableFilter<"CaseStudy"> | string | null
    stats?: JsonNullableFilter<"CaseStudy">
    sortOrder?: IntFilter<"CaseStudy"> | number
    isPublished?: BoolFilter<"CaseStudy"> | boolean
    createdAt?: DateTimeFilter<"CaseStudy"> | Date | string
    updatedAt?: DateTimeFilter<"CaseStudy"> | Date | string
  }, "id" | "slug">

  export type CaseStudyOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrder
    highlights?: SortOrder
    product?: SortOrderInput | SortOrder
    productSlug?: SortOrderInput | SortOrder
    clients?: SortOrder
    location?: SortOrderInput | SortOrder
    images?: SortOrder
    youtubeId?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CaseStudyCountOrderByAggregateInput
    _avg?: CaseStudyAvgOrderByAggregateInput
    _max?: CaseStudyMaxOrderByAggregateInput
    _min?: CaseStudyMinOrderByAggregateInput
    _sum?: CaseStudySumOrderByAggregateInput
  }

  export type CaseStudyScalarWhereWithAggregatesInput = {
    AND?: CaseStudyScalarWhereWithAggregatesInput | CaseStudyScalarWhereWithAggregatesInput[]
    OR?: CaseStudyScalarWhereWithAggregatesInput[]
    NOT?: CaseStudyScalarWhereWithAggregatesInput | CaseStudyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseStudy"> | string
    slug?: StringWithAggregatesFilter<"CaseStudy"> | string
    category?: StringWithAggregatesFilter<"CaseStudy"> | string
    title?: StringWithAggregatesFilter<"CaseStudy"> | string
    subtitle?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    description?: StringWithAggregatesFilter<"CaseStudy"> | string
    highlights?: StringNullableListFilter<"CaseStudy">
    product?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    productSlug?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    clients?: StringNullableListFilter<"CaseStudy">
    location?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    images?: StringNullableListFilter<"CaseStudy">
    youtubeId?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    stats?: JsonNullableWithAggregatesFilter<"CaseStudy">
    sortOrder?: IntWithAggregatesFilter<"CaseStudy"> | number
    isPublished?: BoolWithAggregatesFilter<"CaseStudy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CaseStudy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CaseStudy"> | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    eventName?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    sessionId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    properties?: JsonNullableFilter<"AnalyticsEvent">
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    eventName?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    properties?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    eventName?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    sessionId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    properties?: JsonNullableFilter<"AnalyticsEvent">
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }, "id">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventName?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    properties?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventName?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    properties?: JsonNullableWithAggregatesFilter<"AnalyticsEvent">
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
  }

  export type AIClientProfileWhereInput = {
    AND?: AIClientProfileWhereInput | AIClientProfileWhereInput[]
    OR?: AIClientProfileWhereInput[]
    NOT?: AIClientProfileWhereInput | AIClientProfileWhereInput[]
    id?: StringFilter<"AIClientProfile"> | string
    sessionId?: StringFilter<"AIClientProfile"> | string
    name?: StringNullableFilter<"AIClientProfile"> | string | null
    email?: StringNullableFilter<"AIClientProfile"> | string | null
    phone?: StringNullableFilter<"AIClientProfile"> | string | null
    company?: StringNullableFilter<"AIClientProfile"> | string | null
    website?: StringNullableFilter<"AIClientProfile"> | string | null
    position?: StringNullableFilter<"AIClientProfile"> | string | null
    industry?: StringNullableFilter<"AIClientProfile"> | string | null
    companySize?: EnumCompanySizeNullableFilter<"AIClientProfile"> | $Enums.CompanySize | null
    communicationStyle?: StringNullableFilter<"AIClientProfile"> | string | null
    decisionSpeed?: StringNullableFilter<"AIClientProfile"> | string | null
    techLevel?: StringNullableFilter<"AIClientProfile"> | string | null
    priceSensitivity?: StringNullableFilter<"AIClientProfile"> | string | null
    avgResponseTime?: IntNullableFilter<"AIClientProfile"> | number | null
    messageLength?: StringNullableFilter<"AIClientProfile"> | string | null
    interestLevel?: StringNullableFilter<"AIClientProfile"> | string | null
    painPoints?: StringNullableListFilter<"AIClientProfile">
    budget?: StringNullableFilter<"AIClientProfile"> | string | null
    timeline?: StringNullableFilter<"AIClientProfile"> | string | null
    competitors?: StringNullableListFilter<"AIClientProfile">
    conversationSummary?: StringNullableFilter<"AIClientProfile"> | string | null
    totalMessages?: IntFilter<"AIClientProfile"> | number
    avgSentiment?: FloatNullableFilter<"AIClientProfile"> | number | null
    avgEngagement?: FloatNullableFilter<"AIClientProfile"> | number | null
    strategyEffectiveness?: JsonNullableFilter<"AIClientProfile">
    createdAt?: DateTimeFilter<"AIClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AIClientProfile"> | Date | string
    lastActiveAt?: DateTimeFilter<"AIClientProfile"> | Date | string
    conversations?: AIConversationListRelationFilter
    leadData?: XOR<AILeadDataNullableRelationFilter, AILeadDataWhereInput> | null
  }

  export type AIClientProfileOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    communicationStyle?: SortOrderInput | SortOrder
    decisionSpeed?: SortOrderInput | SortOrder
    techLevel?: SortOrderInput | SortOrder
    priceSensitivity?: SortOrderInput | SortOrder
    avgResponseTime?: SortOrderInput | SortOrder
    messageLength?: SortOrderInput | SortOrder
    interestLevel?: SortOrderInput | SortOrder
    painPoints?: SortOrder
    budget?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    competitors?: SortOrder
    conversationSummary?: SortOrderInput | SortOrder
    totalMessages?: SortOrder
    avgSentiment?: SortOrderInput | SortOrder
    avgEngagement?: SortOrderInput | SortOrder
    strategyEffectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
    conversations?: AIConversationOrderByRelationAggregateInput
    leadData?: AILeadDataOrderByWithRelationInput
  }

  export type AIClientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: AIClientProfileWhereInput | AIClientProfileWhereInput[]
    OR?: AIClientProfileWhereInput[]
    NOT?: AIClientProfileWhereInput | AIClientProfileWhereInput[]
    name?: StringNullableFilter<"AIClientProfile"> | string | null
    email?: StringNullableFilter<"AIClientProfile"> | string | null
    phone?: StringNullableFilter<"AIClientProfile"> | string | null
    company?: StringNullableFilter<"AIClientProfile"> | string | null
    website?: StringNullableFilter<"AIClientProfile"> | string | null
    position?: StringNullableFilter<"AIClientProfile"> | string | null
    industry?: StringNullableFilter<"AIClientProfile"> | string | null
    companySize?: EnumCompanySizeNullableFilter<"AIClientProfile"> | $Enums.CompanySize | null
    communicationStyle?: StringNullableFilter<"AIClientProfile"> | string | null
    decisionSpeed?: StringNullableFilter<"AIClientProfile"> | string | null
    techLevel?: StringNullableFilter<"AIClientProfile"> | string | null
    priceSensitivity?: StringNullableFilter<"AIClientProfile"> | string | null
    avgResponseTime?: IntNullableFilter<"AIClientProfile"> | number | null
    messageLength?: StringNullableFilter<"AIClientProfile"> | string | null
    interestLevel?: StringNullableFilter<"AIClientProfile"> | string | null
    painPoints?: StringNullableListFilter<"AIClientProfile">
    budget?: StringNullableFilter<"AIClientProfile"> | string | null
    timeline?: StringNullableFilter<"AIClientProfile"> | string | null
    competitors?: StringNullableListFilter<"AIClientProfile">
    conversationSummary?: StringNullableFilter<"AIClientProfile"> | string | null
    totalMessages?: IntFilter<"AIClientProfile"> | number
    avgSentiment?: FloatNullableFilter<"AIClientProfile"> | number | null
    avgEngagement?: FloatNullableFilter<"AIClientProfile"> | number | null
    strategyEffectiveness?: JsonNullableFilter<"AIClientProfile">
    createdAt?: DateTimeFilter<"AIClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AIClientProfile"> | Date | string
    lastActiveAt?: DateTimeFilter<"AIClientProfile"> | Date | string
    conversations?: AIConversationListRelationFilter
    leadData?: XOR<AILeadDataNullableRelationFilter, AILeadDataWhereInput> | null
  }, "id" | "sessionId">

  export type AIClientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    communicationStyle?: SortOrderInput | SortOrder
    decisionSpeed?: SortOrderInput | SortOrder
    techLevel?: SortOrderInput | SortOrder
    priceSensitivity?: SortOrderInput | SortOrder
    avgResponseTime?: SortOrderInput | SortOrder
    messageLength?: SortOrderInput | SortOrder
    interestLevel?: SortOrderInput | SortOrder
    painPoints?: SortOrder
    budget?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    competitors?: SortOrder
    conversationSummary?: SortOrderInput | SortOrder
    totalMessages?: SortOrder
    avgSentiment?: SortOrderInput | SortOrder
    avgEngagement?: SortOrderInput | SortOrder
    strategyEffectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
    _count?: AIClientProfileCountOrderByAggregateInput
    _avg?: AIClientProfileAvgOrderByAggregateInput
    _max?: AIClientProfileMaxOrderByAggregateInput
    _min?: AIClientProfileMinOrderByAggregateInput
    _sum?: AIClientProfileSumOrderByAggregateInput
  }

  export type AIClientProfileScalarWhereWithAggregatesInput = {
    AND?: AIClientProfileScalarWhereWithAggregatesInput | AIClientProfileScalarWhereWithAggregatesInput[]
    OR?: AIClientProfileScalarWhereWithAggregatesInput[]
    NOT?: AIClientProfileScalarWhereWithAggregatesInput | AIClientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIClientProfile"> | string
    sessionId?: StringWithAggregatesFilter<"AIClientProfile"> | string
    name?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    email?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    company?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    website?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    position?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    industry?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    companySize?: EnumCompanySizeNullableWithAggregatesFilter<"AIClientProfile"> | $Enums.CompanySize | null
    communicationStyle?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    decisionSpeed?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    techLevel?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    priceSensitivity?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    avgResponseTime?: IntNullableWithAggregatesFilter<"AIClientProfile"> | number | null
    messageLength?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    interestLevel?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    painPoints?: StringNullableListFilter<"AIClientProfile">
    budget?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    timeline?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    competitors?: StringNullableListFilter<"AIClientProfile">
    conversationSummary?: StringNullableWithAggregatesFilter<"AIClientProfile"> | string | null
    totalMessages?: IntWithAggregatesFilter<"AIClientProfile"> | number
    avgSentiment?: FloatNullableWithAggregatesFilter<"AIClientProfile"> | number | null
    avgEngagement?: FloatNullableWithAggregatesFilter<"AIClientProfile"> | number | null
    strategyEffectiveness?: JsonNullableWithAggregatesFilter<"AIClientProfile">
    createdAt?: DateTimeWithAggregatesFilter<"AIClientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIClientProfile"> | Date | string
    lastActiveAt?: DateTimeWithAggregatesFilter<"AIClientProfile"> | Date | string
  }

  export type AIConversationWhereInput = {
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    id?: StringFilter<"AIConversation"> | string
    sessionId?: StringFilter<"AIConversation"> | string
    profileId?: StringFilter<"AIConversation"> | string
    role?: StringFilter<"AIConversation"> | string
    content?: StringFilter<"AIConversation"> | string
    messageType?: StringNullableFilter<"AIConversation"> | string | null
    attachments?: JsonNullableFilter<"AIConversation">
    sentiment?: FloatNullableFilter<"AIConversation"> | number | null
    engagement?: FloatNullableFilter<"AIConversation"> | number | null
    intent?: StringNullableListFilter<"AIConversation">
    urgency?: StringNullableFilter<"AIConversation"> | string | null
    strategy?: StringNullableFilter<"AIConversation"> | string | null
    effectiveness?: FloatNullableFilter<"AIConversation"> | number | null
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
    profile?: XOR<AIClientProfileRelationFilter, AIClientProfileWhereInput>
  }

  export type AIConversationOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageType?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    intent?: SortOrder
    urgency?: SortOrderInput | SortOrder
    strategy?: SortOrderInput | SortOrder
    effectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profile?: AIClientProfileOrderByWithRelationInput
  }

  export type AIConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    sessionId?: StringFilter<"AIConversation"> | string
    profileId?: StringFilter<"AIConversation"> | string
    role?: StringFilter<"AIConversation"> | string
    content?: StringFilter<"AIConversation"> | string
    messageType?: StringNullableFilter<"AIConversation"> | string | null
    attachments?: JsonNullableFilter<"AIConversation">
    sentiment?: FloatNullableFilter<"AIConversation"> | number | null
    engagement?: FloatNullableFilter<"AIConversation"> | number | null
    intent?: StringNullableListFilter<"AIConversation">
    urgency?: StringNullableFilter<"AIConversation"> | string | null
    strategy?: StringNullableFilter<"AIConversation"> | string | null
    effectiveness?: FloatNullableFilter<"AIConversation"> | number | null
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
    profile?: XOR<AIClientProfileRelationFilter, AIClientProfileWhereInput>
  }, "id">

  export type AIConversationOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageType?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    intent?: SortOrder
    urgency?: SortOrderInput | SortOrder
    strategy?: SortOrderInput | SortOrder
    effectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIConversationCountOrderByAggregateInput
    _avg?: AIConversationAvgOrderByAggregateInput
    _max?: AIConversationMaxOrderByAggregateInput
    _min?: AIConversationMinOrderByAggregateInput
    _sum?: AIConversationSumOrderByAggregateInput
  }

  export type AIConversationScalarWhereWithAggregatesInput = {
    AND?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    OR?: AIConversationScalarWhereWithAggregatesInput[]
    NOT?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIConversation"> | string
    sessionId?: StringWithAggregatesFilter<"AIConversation"> | string
    profileId?: StringWithAggregatesFilter<"AIConversation"> | string
    role?: StringWithAggregatesFilter<"AIConversation"> | string
    content?: StringWithAggregatesFilter<"AIConversation"> | string
    messageType?: StringNullableWithAggregatesFilter<"AIConversation"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"AIConversation">
    sentiment?: FloatNullableWithAggregatesFilter<"AIConversation"> | number | null
    engagement?: FloatNullableWithAggregatesFilter<"AIConversation"> | number | null
    intent?: StringNullableListFilter<"AIConversation">
    urgency?: StringNullableWithAggregatesFilter<"AIConversation"> | string | null
    strategy?: StringNullableWithAggregatesFilter<"AIConversation"> | string | null
    effectiveness?: FloatNullableWithAggregatesFilter<"AIConversation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AIConversation"> | Date | string
  }

  export type AILeadDataWhereInput = {
    AND?: AILeadDataWhereInput | AILeadDataWhereInput[]
    OR?: AILeadDataWhereInput[]
    NOT?: AILeadDataWhereInput | AILeadDataWhereInput[]
    id?: StringFilter<"AILeadData"> | string
    profileId?: StringFilter<"AILeadData"> | string
    leadScore?: IntFilter<"AILeadData"> | number
    leadStatus?: EnumLeadStatusFilter<"AILeadData"> | $Enums.LeadStatus
    estimatedValue?: StringNullableFilter<"AILeadData"> | string | null
    salesStage?: EnumSalesStageFilter<"AILeadData"> | $Enums.SalesStage
    nextAction?: StringNullableFilter<"AILeadData"> | string | null
    notes?: StringNullableFilter<"AILeadData"> | string | null
    assignedTo?: StringNullableFilter<"AILeadData"> | string | null
    followUpAt?: DateTimeNullableFilter<"AILeadData"> | Date | string | null
    convertedAt?: DateTimeNullableFilter<"AILeadData"> | Date | string | null
    conversionValue?: FloatNullableFilter<"AILeadData"> | number | null
    createdAt?: DateTimeFilter<"AILeadData"> | Date | string
    updatedAt?: DateTimeFilter<"AILeadData"> | Date | string
    profile?: XOR<AIClientProfileRelationFilter, AIClientProfileWhereInput>
  }

  export type AILeadDataOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    leadScore?: SortOrder
    leadStatus?: SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    salesStage?: SortOrder
    nextAction?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    followUpAt?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: AIClientProfileOrderByWithRelationInput
  }

  export type AILeadDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId?: string
    AND?: AILeadDataWhereInput | AILeadDataWhereInput[]
    OR?: AILeadDataWhereInput[]
    NOT?: AILeadDataWhereInput | AILeadDataWhereInput[]
    leadScore?: IntFilter<"AILeadData"> | number
    leadStatus?: EnumLeadStatusFilter<"AILeadData"> | $Enums.LeadStatus
    estimatedValue?: StringNullableFilter<"AILeadData"> | string | null
    salesStage?: EnumSalesStageFilter<"AILeadData"> | $Enums.SalesStage
    nextAction?: StringNullableFilter<"AILeadData"> | string | null
    notes?: StringNullableFilter<"AILeadData"> | string | null
    assignedTo?: StringNullableFilter<"AILeadData"> | string | null
    followUpAt?: DateTimeNullableFilter<"AILeadData"> | Date | string | null
    convertedAt?: DateTimeNullableFilter<"AILeadData"> | Date | string | null
    conversionValue?: FloatNullableFilter<"AILeadData"> | number | null
    createdAt?: DateTimeFilter<"AILeadData"> | Date | string
    updatedAt?: DateTimeFilter<"AILeadData"> | Date | string
    profile?: XOR<AIClientProfileRelationFilter, AIClientProfileWhereInput>
  }, "id" | "profileId">

  export type AILeadDataOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    leadScore?: SortOrder
    leadStatus?: SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    salesStage?: SortOrder
    nextAction?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    followUpAt?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AILeadDataCountOrderByAggregateInput
    _avg?: AILeadDataAvgOrderByAggregateInput
    _max?: AILeadDataMaxOrderByAggregateInput
    _min?: AILeadDataMinOrderByAggregateInput
    _sum?: AILeadDataSumOrderByAggregateInput
  }

  export type AILeadDataScalarWhereWithAggregatesInput = {
    AND?: AILeadDataScalarWhereWithAggregatesInput | AILeadDataScalarWhereWithAggregatesInput[]
    OR?: AILeadDataScalarWhereWithAggregatesInput[]
    NOT?: AILeadDataScalarWhereWithAggregatesInput | AILeadDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AILeadData"> | string
    profileId?: StringWithAggregatesFilter<"AILeadData"> | string
    leadScore?: IntWithAggregatesFilter<"AILeadData"> | number
    leadStatus?: EnumLeadStatusWithAggregatesFilter<"AILeadData"> | $Enums.LeadStatus
    estimatedValue?: StringNullableWithAggregatesFilter<"AILeadData"> | string | null
    salesStage?: EnumSalesStageWithAggregatesFilter<"AILeadData"> | $Enums.SalesStage
    nextAction?: StringNullableWithAggregatesFilter<"AILeadData"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AILeadData"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"AILeadData"> | string | null
    followUpAt?: DateTimeNullableWithAggregatesFilter<"AILeadData"> | Date | string | null
    convertedAt?: DateTimeNullableWithAggregatesFilter<"AILeadData"> | Date | string | null
    conversionValue?: FloatNullableWithAggregatesFilter<"AILeadData"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AILeadData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AILeadData"> | Date | string
  }

  export type AICompanyIntelligenceWhereInput = {
    AND?: AICompanyIntelligenceWhereInput | AICompanyIntelligenceWhereInput[]
    OR?: AICompanyIntelligenceWhereInput[]
    NOT?: AICompanyIntelligenceWhereInput | AICompanyIntelligenceWhereInput[]
    id?: StringFilter<"AICompanyIntelligence"> | string
    companyName?: StringFilter<"AICompanyIntelligence"> | string
    website?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    industry?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    size?: EnumCompanySizeNullableFilter<"AICompanyIntelligence"> | $Enums.CompanySize | null
    description?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    painPoints?: StringNullableListFilter<"AICompanyIntelligence">
    budgetEstimate?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    decisionMakers?: StringNullableListFilter<"AICompanyIntelligence">
    competitors?: StringNullableListFilter<"AICompanyIntelligence">
    recentNews?: JsonNullableFilter<"AICompanyIntelligence">
    marketTrends?: JsonNullableFilter<"AICompanyIntelligence">
    phone?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    email?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    address?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    timesAnalyzed?: IntFilter<"AICompanyIntelligence"> | number
    lastAnalyzed?: DateTimeFilter<"AICompanyIntelligence"> | Date | string
    createdAt?: DateTimeFilter<"AICompanyIntelligence"> | Date | string
    updatedAt?: DateTimeFilter<"AICompanyIntelligence"> | Date | string
  }

  export type AICompanyIntelligenceOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    painPoints?: SortOrder
    budgetEstimate?: SortOrderInput | SortOrder
    decisionMakers?: SortOrder
    competitors?: SortOrder
    recentNews?: SortOrderInput | SortOrder
    marketTrends?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    timesAnalyzed?: SortOrder
    lastAnalyzed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AICompanyIntelligenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyName?: string
    AND?: AICompanyIntelligenceWhereInput | AICompanyIntelligenceWhereInput[]
    OR?: AICompanyIntelligenceWhereInput[]
    NOT?: AICompanyIntelligenceWhereInput | AICompanyIntelligenceWhereInput[]
    website?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    industry?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    size?: EnumCompanySizeNullableFilter<"AICompanyIntelligence"> | $Enums.CompanySize | null
    description?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    painPoints?: StringNullableListFilter<"AICompanyIntelligence">
    budgetEstimate?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    decisionMakers?: StringNullableListFilter<"AICompanyIntelligence">
    competitors?: StringNullableListFilter<"AICompanyIntelligence">
    recentNews?: JsonNullableFilter<"AICompanyIntelligence">
    marketTrends?: JsonNullableFilter<"AICompanyIntelligence">
    phone?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    email?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    address?: StringNullableFilter<"AICompanyIntelligence"> | string | null
    timesAnalyzed?: IntFilter<"AICompanyIntelligence"> | number
    lastAnalyzed?: DateTimeFilter<"AICompanyIntelligence"> | Date | string
    createdAt?: DateTimeFilter<"AICompanyIntelligence"> | Date | string
    updatedAt?: DateTimeFilter<"AICompanyIntelligence"> | Date | string
  }, "id" | "companyName">

  export type AICompanyIntelligenceOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    painPoints?: SortOrder
    budgetEstimate?: SortOrderInput | SortOrder
    decisionMakers?: SortOrder
    competitors?: SortOrder
    recentNews?: SortOrderInput | SortOrder
    marketTrends?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    timesAnalyzed?: SortOrder
    lastAnalyzed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AICompanyIntelligenceCountOrderByAggregateInput
    _avg?: AICompanyIntelligenceAvgOrderByAggregateInput
    _max?: AICompanyIntelligenceMaxOrderByAggregateInput
    _min?: AICompanyIntelligenceMinOrderByAggregateInput
    _sum?: AICompanyIntelligenceSumOrderByAggregateInput
  }

  export type AICompanyIntelligenceScalarWhereWithAggregatesInput = {
    AND?: AICompanyIntelligenceScalarWhereWithAggregatesInput | AICompanyIntelligenceScalarWhereWithAggregatesInput[]
    OR?: AICompanyIntelligenceScalarWhereWithAggregatesInput[]
    NOT?: AICompanyIntelligenceScalarWhereWithAggregatesInput | AICompanyIntelligenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AICompanyIntelligence"> | string
    companyName?: StringWithAggregatesFilter<"AICompanyIntelligence"> | string
    website?: StringNullableWithAggregatesFilter<"AICompanyIntelligence"> | string | null
    industry?: StringNullableWithAggregatesFilter<"AICompanyIntelligence"> | string | null
    size?: EnumCompanySizeNullableWithAggregatesFilter<"AICompanyIntelligence"> | $Enums.CompanySize | null
    description?: StringNullableWithAggregatesFilter<"AICompanyIntelligence"> | string | null
    painPoints?: StringNullableListFilter<"AICompanyIntelligence">
    budgetEstimate?: StringNullableWithAggregatesFilter<"AICompanyIntelligence"> | string | null
    decisionMakers?: StringNullableListFilter<"AICompanyIntelligence">
    competitors?: StringNullableListFilter<"AICompanyIntelligence">
    recentNews?: JsonNullableWithAggregatesFilter<"AICompanyIntelligence">
    marketTrends?: JsonNullableWithAggregatesFilter<"AICompanyIntelligence">
    phone?: StringNullableWithAggregatesFilter<"AICompanyIntelligence"> | string | null
    email?: StringNullableWithAggregatesFilter<"AICompanyIntelligence"> | string | null
    address?: StringNullableWithAggregatesFilter<"AICompanyIntelligence"> | string | null
    timesAnalyzed?: IntWithAggregatesFilter<"AICompanyIntelligence"> | number
    lastAnalyzed?: DateTimeWithAggregatesFilter<"AICompanyIntelligence"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AICompanyIntelligence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AICompanyIntelligence"> | Date | string
  }

  export type AIStrategyPerformanceWhereInput = {
    AND?: AIStrategyPerformanceWhereInput | AIStrategyPerformanceWhereInput[]
    OR?: AIStrategyPerformanceWhereInput[]
    NOT?: AIStrategyPerformanceWhereInput | AIStrategyPerformanceWhereInput[]
    id?: StringFilter<"AIStrategyPerformance"> | string
    strategy?: StringFilter<"AIStrategyPerformance"> | string
    industry?: StringNullableFilter<"AIStrategyPerformance"> | string | null
    companySize?: EnumCompanySizeNullableFilter<"AIStrategyPerformance"> | $Enums.CompanySize | null
    clientType?: StringNullableFilter<"AIStrategyPerformance"> | string | null
    timesUsed?: IntFilter<"AIStrategyPerformance"> | number
    avgEffectiveness?: FloatFilter<"AIStrategyPerformance"> | number
    conversionRate?: FloatNullableFilter<"AIStrategyPerformance"> | number | null
    avgEngagement?: FloatNullableFilter<"AIStrategyPerformance"> | number | null
    successFactors?: JsonNullableFilter<"AIStrategyPerformance">
    failureReasons?: JsonNullableFilter<"AIStrategyPerformance">
    createdAt?: DateTimeFilter<"AIStrategyPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"AIStrategyPerformance"> | Date | string
  }

  export type AIStrategyPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    strategy?: SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    clientType?: SortOrderInput | SortOrder
    timesUsed?: SortOrder
    avgEffectiveness?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    avgEngagement?: SortOrderInput | SortOrder
    successFactors?: SortOrderInput | SortOrder
    failureReasons?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIStrategyPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    strategy_industry_companySize_clientType?: AIStrategyPerformanceStrategyIndustryCompanySizeClientTypeCompoundUniqueInput
    AND?: AIStrategyPerformanceWhereInput | AIStrategyPerformanceWhereInput[]
    OR?: AIStrategyPerformanceWhereInput[]
    NOT?: AIStrategyPerformanceWhereInput | AIStrategyPerformanceWhereInput[]
    strategy?: StringFilter<"AIStrategyPerformance"> | string
    industry?: StringNullableFilter<"AIStrategyPerformance"> | string | null
    companySize?: EnumCompanySizeNullableFilter<"AIStrategyPerformance"> | $Enums.CompanySize | null
    clientType?: StringNullableFilter<"AIStrategyPerformance"> | string | null
    timesUsed?: IntFilter<"AIStrategyPerformance"> | number
    avgEffectiveness?: FloatFilter<"AIStrategyPerformance"> | number
    conversionRate?: FloatNullableFilter<"AIStrategyPerformance"> | number | null
    avgEngagement?: FloatNullableFilter<"AIStrategyPerformance"> | number | null
    successFactors?: JsonNullableFilter<"AIStrategyPerformance">
    failureReasons?: JsonNullableFilter<"AIStrategyPerformance">
    createdAt?: DateTimeFilter<"AIStrategyPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"AIStrategyPerformance"> | Date | string
  }, "id" | "strategy_industry_companySize_clientType">

  export type AIStrategyPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    strategy?: SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    clientType?: SortOrderInput | SortOrder
    timesUsed?: SortOrder
    avgEffectiveness?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    avgEngagement?: SortOrderInput | SortOrder
    successFactors?: SortOrderInput | SortOrder
    failureReasons?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIStrategyPerformanceCountOrderByAggregateInput
    _avg?: AIStrategyPerformanceAvgOrderByAggregateInput
    _max?: AIStrategyPerformanceMaxOrderByAggregateInput
    _min?: AIStrategyPerformanceMinOrderByAggregateInput
    _sum?: AIStrategyPerformanceSumOrderByAggregateInput
  }

  export type AIStrategyPerformanceScalarWhereWithAggregatesInput = {
    AND?: AIStrategyPerformanceScalarWhereWithAggregatesInput | AIStrategyPerformanceScalarWhereWithAggregatesInput[]
    OR?: AIStrategyPerformanceScalarWhereWithAggregatesInput[]
    NOT?: AIStrategyPerformanceScalarWhereWithAggregatesInput | AIStrategyPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIStrategyPerformance"> | string
    strategy?: StringWithAggregatesFilter<"AIStrategyPerformance"> | string
    industry?: StringNullableWithAggregatesFilter<"AIStrategyPerformance"> | string | null
    companySize?: EnumCompanySizeNullableWithAggregatesFilter<"AIStrategyPerformance"> | $Enums.CompanySize | null
    clientType?: StringNullableWithAggregatesFilter<"AIStrategyPerformance"> | string | null
    timesUsed?: IntWithAggregatesFilter<"AIStrategyPerformance"> | number
    avgEffectiveness?: FloatWithAggregatesFilter<"AIStrategyPerformance"> | number
    conversionRate?: FloatNullableWithAggregatesFilter<"AIStrategyPerformance"> | number | null
    avgEngagement?: FloatNullableWithAggregatesFilter<"AIStrategyPerformance"> | number | null
    successFactors?: JsonNullableWithAggregatesFilter<"AIStrategyPerformance">
    failureReasons?: JsonNullableWithAggregatesFilter<"AIStrategyPerformance">
    createdAt?: DateTimeWithAggregatesFilter<"AIStrategyPerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIStrategyPerformance"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDocAssetCreateInput = {
    id?: string
    bcProductId: string
    sku: string
    docType: $Enums.DocType
    title: string
    url: string
    version?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductDocAssetUncheckedCreateInput = {
    id?: string
    bcProductId: string
    sku: string
    docType: $Enums.DocType
    title: string
    url: string
    version?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductDocAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcProductId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDocAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcProductId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDocAssetCreateManyInput = {
    id?: string
    bcProductId: string
    sku: string
    docType: $Enums.DocType
    title: string
    url: string
    version?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductDocAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcProductId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDocAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcProductId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseCreateInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    customer: UserCreateNestedOneWithoutCasesInput
    assignedTo?: UserCreateNestedOneWithoutAssignedCasesInput
    attachments?: CaseAttachmentCreateNestedManyWithoutCaseInput
    messages?: CaseMessageCreateNestedManyWithoutCaseInput
    quotes?: QuoteCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    customerId: string
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    attachments?: CaseAttachmentUncheckedCreateNestedManyWithoutCaseInput
    messages?: CaseMessageUncheckedCreateNestedManyWithoutCaseInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: UserUpdateOneRequiredWithoutCasesNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedCasesNestedInput
    attachments?: CaseAttachmentUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: CaseAttachmentUncheckedUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUncheckedUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseCreateManyInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    customerId: string
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type CaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaseAttachmentCreateInput = {
    id?: string
    filename: string
    url: string
    mimeType?: string | null
    fileSize?: number | null
    uploadedBy: string
    createdAt?: Date | string
    case: CaseCreateNestedOneWithoutAttachmentsInput
  }

  export type CaseAttachmentUncheckedCreateInput = {
    id?: string
    caseId: string
    filename: string
    url: string
    mimeType?: string | null
    fileSize?: number | null
    uploadedBy: string
    createdAt?: Date | string
  }

  export type CaseAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: CaseUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type CaseAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseAttachmentCreateManyInput = {
    id?: string
    caseId: string
    filename: string
    url: string
    mimeType?: string | null
    fileSize?: number | null
    uploadedBy: string
    createdAt?: Date | string
  }

  export type CaseAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseMessageCreateInput = {
    id?: string
    senderId: string
    senderName: string
    senderRole: $Enums.UserRole
    message: string
    isInternal?: boolean
    createdAt?: Date | string
    case: CaseCreateNestedOneWithoutMessagesInput
  }

  export type CaseMessageUncheckedCreateInput = {
    id?: string
    caseId: string
    senderId: string
    senderName: string
    senderRole: $Enums.UserRole
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type CaseMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: CaseUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type CaseMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseMessageCreateManyInput = {
    id?: string
    caseId: string
    senderId: string
    senderName: string
    senderRole: $Enums.UserRole
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type CaseMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateInput = {
    id?: string
    quoteNumber: string
    version?: number
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutQuotesInput
    case?: CaseCreateNestedOneWithoutQuotesInput
    project?: ProjectCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    quoteNumber: string
    version?: number
    customerId: string
    caseId?: string | null
    projectId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutQuotesNestedInput
    case?: CaseUpdateOneWithoutQuotesNestedInput
    project?: ProjectUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateManyInput = {
    id?: string
    quoteNumber: string
    version?: number
    customerId: string
    caseId?: string | null
    projectId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    projectName: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutProjectsInput
    quotes?: QuoteCreateNestedManyWithoutProjectInput
    specPackages?: SpecPackageCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    projectName: string
    customerId: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutProjectInput
    specPackages?: SpecPackageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutProjectsNestedInput
    quotes?: QuoteUpdateManyWithoutProjectNestedInput
    specPackages?: SpecPackageUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutProjectNestedInput
    specPackages?: SpecPackageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    projectName: string
    customerId: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecPackageCreateInput = {
    id?: string
    name: string
    skus?: SpecPackageCreateskusInput | string[]
    zipUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutSpecPackagesInput
  }

  export type SpecPackageUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    skus?: SpecPackageCreateskusInput | string[]
    zipUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SpecPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    skus?: SpecPackageUpdateskusInput | string[]
    zipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSpecPackagesNestedInput
  }

  export type SpecPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    skus?: SpecPackageUpdateskusInput | string[]
    zipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecPackageCreateManyInput = {
    id?: string
    projectId: string
    name: string
    skus?: SpecPackageCreateskusInput | string[]
    zipUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SpecPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    skus?: SpecPackageUpdateskusInput | string[]
    zipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    skus?: SpecPackageUpdateskusInput | string[]
    zipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxExemptDocumentCreateInput = {
    id?: string
    state: string
    documentUrl: string
    documentType?: string | null
    status?: $Enums.TaxExemptStatus
    expiresAt?: Date | string | null
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutTaxExemptDocumentsInput
  }

  export type TaxExemptDocumentUncheckedCreateInput = {
    id?: string
    customerId: string
    state: string
    documentUrl: string
    documentType?: string | null
    status?: $Enums.TaxExemptStatus
    expiresAt?: Date | string | null
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxExemptDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaxExemptStatusFieldUpdateOperationsInput | $Enums.TaxExemptStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutTaxExemptDocumentsNestedInput
  }

  export type TaxExemptDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaxExemptStatusFieldUpdateOperationsInput | $Enums.TaxExemptStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxExemptDocumentCreateManyInput = {
    id?: string
    customerId: string
    state: string
    documentUrl: string
    documentType?: string | null
    status?: $Enums.TaxExemptStatus
    expiresAt?: Date | string | null
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxExemptDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaxExemptStatusFieldUpdateOperationsInput | $Enums.TaxExemptStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxExemptDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaxExemptStatusFieldUpdateOperationsInput | $Enums.TaxExemptStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCreateInput = {
    id?: string
    userId: string
    partnerType: $Enums.PartnerType
    companyName: string
    status?: $Enums.PartnerStatus
    referralCode: string
    commissionRate?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attributions?: PartnerAttributionCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    userId: string
    partnerType: $Enums.PartnerType
    companyName: string
    status?: $Enums.PartnerStatus
    referralCode: string
    commissionRate?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attributions?: PartnerAttributionUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerType?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    companyName?: StringFieldUpdateOperationsInput | string
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    referralCode?: StringFieldUpdateOperationsInput | string
    commissionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributions?: PartnerAttributionUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerType?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    companyName?: StringFieldUpdateOperationsInput | string
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    referralCode?: StringFieldUpdateOperationsInput | string
    commissionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributions?: PartnerAttributionUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    userId: string
    partnerType: $Enums.PartnerType
    companyName: string
    status?: $Enums.PartnerStatus
    referralCode: string
    commissionRate?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerType?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    companyName?: StringFieldUpdateOperationsInput | string
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    referralCode?: StringFieldUpdateOperationsInput | string
    commissionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerType?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    companyName?: StringFieldUpdateOperationsInput | string
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    referralCode?: StringFieldUpdateOperationsInput | string
    commissionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerAttributionCreateInput = {
    id?: string
    bcOrderId: string
    orderTotal: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    partner: PartnerCreateNestedOneWithoutAttributionsInput
  }

  export type PartnerAttributionUncheckedCreateInput = {
    id?: string
    partnerId: string
    bcOrderId: string
    orderTotal: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PartnerAttributionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutAttributionsNestedInput
  }

  export type PartnerAttributionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerAttributionCreateManyInput = {
    id?: string
    partnerId: string
    bcOrderId: string
    orderTotal: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PartnerAttributionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerAttributionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QboSyncLogCreateInput = {
    id?: string
    entityType: string
    sourceId: string
    qboId?: string | null
    status?: $Enums.SyncStatus
    attempts?: number
    lastError?: string | null
    lastAttemptAt?: Date | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QboSyncLogUncheckedCreateInput = {
    id?: string
    entityType: string
    sourceId: string
    qboId?: string | null
    status?: $Enums.SyncStatus
    attempts?: number
    lastError?: string | null
    lastAttemptAt?: Date | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QboSyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    qboId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QboSyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    qboId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QboSyncLogCreateManyInput = {
    id?: string
    entityType: string
    sourceId: string
    qboId?: string | null
    status?: $Enums.SyncStatus
    attempts?: number
    lastError?: string | null
    lastAttemptAt?: Date | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QboSyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    qboId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QboSyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    qboId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingSyncLogCreateInput = {
    id?: string
    bcOrderId: string
    shipmentId?: string | null
    carrier?: string | null
    trackingNumber?: string | null
    status?: $Enums.SyncStatus
    attempts?: number
    lastError?: string | null
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingSyncLogUncheckedCreateInput = {
    id?: string
    bcOrderId: string
    shipmentId?: string | null
    carrier?: string | null
    trackingNumber?: string | null
    status?: $Enums.SyncStatus
    attempts?: number
    lastError?: string | null
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingSyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingSyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingSyncLogCreateManyInput = {
    id?: string
    bcOrderId: string
    shipmentId?: string | null
    carrier?: string | null
    trackingNumber?: string | null
    status?: $Enums.SyncStatus
    attempts?: number
    lastError?: string | null
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingSyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingSyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryCreateInput = {
    id?: string
    category: string
    title: string
    content: string
    sourceUrl?: string | null
    embedding?: Bytes | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseEntryUncheckedCreateInput = {
    id?: string
    category: string
    title: string
    content: string
    sourceUrl?: string | null
    embedding?: Bytes | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryCreateManyInput = {
    id?: string
    category: string
    title: string
    content: string
    sourceUrl?: string | null
    embedding?: Bytes | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatLogCreateInput = {
    id?: string
    sessionId: string
    userId?: string | null
    userMessage: string
    aiResponse: string
    sourcesUsed?: AIChatLogCreatesourcesUsedInput | string[]
    handoffCaseId?: string | null
    feedbackRating?: number | null
    createdAt?: Date | string
  }

  export type AIChatLogUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId?: string | null
    userMessage: string
    aiResponse: string
    sourcesUsed?: AIChatLogCreatesourcesUsedInput | string[]
    handoffCaseId?: string | null
    feedbackRating?: number | null
    createdAt?: Date | string
  }

  export type AIChatLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userMessage?: StringFieldUpdateOperationsInput | string
    aiResponse?: StringFieldUpdateOperationsInput | string
    sourcesUsed?: AIChatLogUpdatesourcesUsedInput | string[]
    handoffCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userMessage?: StringFieldUpdateOperationsInput | string
    aiResponse?: StringFieldUpdateOperationsInput | string
    sourcesUsed?: AIChatLogUpdatesourcesUsedInput | string[]
    handoffCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatLogCreateManyInput = {
    id?: string
    sessionId: string
    userId?: string | null
    userMessage: string
    aiResponse: string
    sourcesUsed?: AIChatLogCreatesourcesUsedInput | string[]
    handoffCaseId?: string | null
    feedbackRating?: number | null
    createdAt?: Date | string
  }

  export type AIChatLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userMessage?: StringFieldUpdateOperationsInput | string
    aiResponse?: StringFieldUpdateOperationsInput | string
    sourcesUsed?: AIChatLogUpdatesourcesUsedInput | string[]
    handoffCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userMessage?: StringFieldUpdateOperationsInput | string
    aiResponse?: StringFieldUpdateOperationsInput | string
    sourcesUsed?: AIChatLogUpdatesourcesUsedInput | string[]
    handoffCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyCreateInput = {
    id?: string
    slug: string
    category: string
    title: string
    subtitle?: string | null
    description: string
    highlights?: CaseStudyCreatehighlightsInput | string[]
    product?: string | null
    productSlug?: string | null
    clients?: CaseStudyCreateclientsInput | string[]
    location?: string | null
    images?: CaseStudyCreateimagesInput | string[]
    youtubeId?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaseStudyUncheckedCreateInput = {
    id?: string
    slug: string
    category: string
    title: string
    subtitle?: string | null
    description: string
    highlights?: CaseStudyCreatehighlightsInput | string[]
    product?: string | null
    productSlug?: string | null
    clients?: CaseStudyCreateclientsInput | string[]
    location?: string | null
    images?: CaseStudyCreateimagesInput | string[]
    youtubeId?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaseStudyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    highlights?: CaseStudyUpdatehighlightsInput | string[]
    product?: NullableStringFieldUpdateOperationsInput | string | null
    productSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: CaseStudyUpdateclientsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CaseStudyUpdateimagesInput | string[]
    youtubeId?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    highlights?: CaseStudyUpdatehighlightsInput | string[]
    product?: NullableStringFieldUpdateOperationsInput | string | null
    productSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: CaseStudyUpdateclientsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CaseStudyUpdateimagesInput | string[]
    youtubeId?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyCreateManyInput = {
    id?: string
    slug: string
    category: string
    title: string
    subtitle?: string | null
    description: string
    highlights?: CaseStudyCreatehighlightsInput | string[]
    product?: string | null
    productSlug?: string | null
    clients?: CaseStudyCreateclientsInput | string[]
    location?: string | null
    images?: CaseStudyCreateimagesInput | string[]
    youtubeId?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaseStudyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    highlights?: CaseStudyUpdatehighlightsInput | string[]
    product?: NullableStringFieldUpdateOperationsInput | string | null
    productSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: CaseStudyUpdateclientsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CaseStudyUpdateimagesInput | string[]
    youtubeId?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    highlights?: CaseStudyUpdatehighlightsInput | string[]
    product?: NullableStringFieldUpdateOperationsInput | string | null
    productSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: CaseStudyUpdateclientsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    images?: CaseStudyUpdateimagesInput | string[]
    youtubeId?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    eventName: string
    userId?: string | null
    sessionId?: string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    eventName: string
    userId?: string | null
    sessionId?: string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    eventName: string
    userId?: string | null
    sessionId?: string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIClientProfileCreateInput = {
    id?: string
    sessionId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    company?: string | null
    website?: string | null
    position?: string | null
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    communicationStyle?: string | null
    decisionSpeed?: string | null
    techLevel?: string | null
    priceSensitivity?: string | null
    avgResponseTime?: number | null
    messageLength?: string | null
    interestLevel?: string | null
    painPoints?: AIClientProfileCreatepainPointsInput | string[]
    budget?: string | null
    timeline?: string | null
    competitors?: AIClientProfileCreatecompetitorsInput | string[]
    conversationSummary?: string | null
    totalMessages?: number
    avgSentiment?: number | null
    avgEngagement?: number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    conversations?: AIConversationCreateNestedManyWithoutProfileInput
    leadData?: AILeadDataCreateNestedOneWithoutProfileInput
  }

  export type AIClientProfileUncheckedCreateInput = {
    id?: string
    sessionId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    company?: string | null
    website?: string | null
    position?: string | null
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    communicationStyle?: string | null
    decisionSpeed?: string | null
    techLevel?: string | null
    priceSensitivity?: string | null
    avgResponseTime?: number | null
    messageLength?: string | null
    interestLevel?: string | null
    painPoints?: AIClientProfileCreatepainPointsInput | string[]
    budget?: string | null
    timeline?: string | null
    competitors?: AIClientProfileCreatecompetitorsInput | string[]
    conversationSummary?: string | null
    totalMessages?: number
    avgSentiment?: number | null
    avgEngagement?: number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    conversations?: AIConversationUncheckedCreateNestedManyWithoutProfileInput
    leadData?: AILeadDataUncheckedCreateNestedOneWithoutProfileInput
  }

  export type AIClientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUpdateManyWithoutProfileNestedInput
    leadData?: AILeadDataUpdateOneWithoutProfileNestedInput
  }

  export type AIClientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUncheckedUpdateManyWithoutProfileNestedInput
    leadData?: AILeadDataUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type AIClientProfileCreateManyInput = {
    id?: string
    sessionId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    company?: string | null
    website?: string | null
    position?: string | null
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    communicationStyle?: string | null
    decisionSpeed?: string | null
    techLevel?: string | null
    priceSensitivity?: string | null
    avgResponseTime?: number | null
    messageLength?: string | null
    interestLevel?: string | null
    painPoints?: AIClientProfileCreatepainPointsInput | string[]
    budget?: string | null
    timeline?: string | null
    competitors?: AIClientProfileCreatecompetitorsInput | string[]
    conversationSummary?: string | null
    totalMessages?: number
    avgSentiment?: number | null
    avgEngagement?: number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type AIClientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIClientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    messageType?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    engagement?: number | null
    intent?: AIConversationCreateintentInput | string[]
    urgency?: string | null
    strategy?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
    profile: AIClientProfileCreateNestedOneWithoutConversationsInput
  }

  export type AIConversationUncheckedCreateInput = {
    id?: string
    sessionId: string
    profileId: string
    role: string
    content: string
    messageType?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    engagement?: number | null
    intent?: AIConversationCreateintentInput | string[]
    urgency?: string | null
    strategy?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type AIConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    intent?: AIConversationUpdateintentInput | string[]
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: AIClientProfileUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type AIConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    intent?: AIConversationUpdateintentInput | string[]
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateManyInput = {
    id?: string
    sessionId: string
    profileId: string
    role: string
    content: string
    messageType?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    engagement?: number | null
    intent?: AIConversationCreateintentInput | string[]
    urgency?: string | null
    strategy?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type AIConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    intent?: AIConversationUpdateintentInput | string[]
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    intent?: AIConversationUpdateintentInput | string[]
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILeadDataCreateInput = {
    id?: string
    leadScore?: number
    leadStatus?: $Enums.LeadStatus
    estimatedValue?: string | null
    salesStage?: $Enums.SalesStage
    nextAction?: string | null
    notes?: string | null
    assignedTo?: string | null
    followUpAt?: Date | string | null
    convertedAt?: Date | string | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: AIClientProfileCreateNestedOneWithoutLeadDataInput
  }

  export type AILeadDataUncheckedCreateInput = {
    id?: string
    profileId: string
    leadScore?: number
    leadStatus?: $Enums.LeadStatus
    estimatedValue?: string | null
    salesStage?: $Enums.SalesStage
    nextAction?: string | null
    notes?: string | null
    assignedTo?: string | null
    followUpAt?: Date | string | null
    convertedAt?: Date | string | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AILeadDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadScore?: IntFieldUpdateOperationsInput | number
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    estimatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    salesStage?: EnumSalesStageFieldUpdateOperationsInput | $Enums.SalesStage
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    followUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: AIClientProfileUpdateOneRequiredWithoutLeadDataNestedInput
  }

  export type AILeadDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    leadScore?: IntFieldUpdateOperationsInput | number
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    estimatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    salesStage?: EnumSalesStageFieldUpdateOperationsInput | $Enums.SalesStage
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    followUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILeadDataCreateManyInput = {
    id?: string
    profileId: string
    leadScore?: number
    leadStatus?: $Enums.LeadStatus
    estimatedValue?: string | null
    salesStage?: $Enums.SalesStage
    nextAction?: string | null
    notes?: string | null
    assignedTo?: string | null
    followUpAt?: Date | string | null
    convertedAt?: Date | string | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AILeadDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadScore?: IntFieldUpdateOperationsInput | number
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    estimatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    salesStage?: EnumSalesStageFieldUpdateOperationsInput | $Enums.SalesStage
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    followUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILeadDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    leadScore?: IntFieldUpdateOperationsInput | number
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    estimatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    salesStage?: EnumSalesStageFieldUpdateOperationsInput | $Enums.SalesStage
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    followUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICompanyIntelligenceCreateInput = {
    id?: string
    companyName: string
    website?: string | null
    industry?: string | null
    size?: $Enums.CompanySize | null
    description?: string | null
    painPoints?: AICompanyIntelligenceCreatepainPointsInput | string[]
    budgetEstimate?: string | null
    decisionMakers?: AICompanyIntelligenceCreatedecisionMakersInput | string[]
    competitors?: AICompanyIntelligenceCreatecompetitorsInput | string[]
    recentNews?: NullableJsonNullValueInput | InputJsonValue
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    address?: string | null
    timesAnalyzed?: number
    lastAnalyzed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AICompanyIntelligenceUncheckedCreateInput = {
    id?: string
    companyName: string
    website?: string | null
    industry?: string | null
    size?: $Enums.CompanySize | null
    description?: string | null
    painPoints?: AICompanyIntelligenceCreatepainPointsInput | string[]
    budgetEstimate?: string | null
    decisionMakers?: AICompanyIntelligenceCreatedecisionMakersInput | string[]
    competitors?: AICompanyIntelligenceCreatecompetitorsInput | string[]
    recentNews?: NullableJsonNullValueInput | InputJsonValue
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    address?: string | null
    timesAnalyzed?: number
    lastAnalyzed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AICompanyIntelligenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AICompanyIntelligenceUpdatepainPointsInput | string[]
    budgetEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMakers?: AICompanyIntelligenceUpdatedecisionMakersInput | string[]
    competitors?: AICompanyIntelligenceUpdatecompetitorsInput | string[]
    recentNews?: NullableJsonNullValueInput | InputJsonValue
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timesAnalyzed?: IntFieldUpdateOperationsInput | number
    lastAnalyzed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICompanyIntelligenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AICompanyIntelligenceUpdatepainPointsInput | string[]
    budgetEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMakers?: AICompanyIntelligenceUpdatedecisionMakersInput | string[]
    competitors?: AICompanyIntelligenceUpdatecompetitorsInput | string[]
    recentNews?: NullableJsonNullValueInput | InputJsonValue
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timesAnalyzed?: IntFieldUpdateOperationsInput | number
    lastAnalyzed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICompanyIntelligenceCreateManyInput = {
    id?: string
    companyName: string
    website?: string | null
    industry?: string | null
    size?: $Enums.CompanySize | null
    description?: string | null
    painPoints?: AICompanyIntelligenceCreatepainPointsInput | string[]
    budgetEstimate?: string | null
    decisionMakers?: AICompanyIntelligenceCreatedecisionMakersInput | string[]
    competitors?: AICompanyIntelligenceCreatecompetitorsInput | string[]
    recentNews?: NullableJsonNullValueInput | InputJsonValue
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    address?: string | null
    timesAnalyzed?: number
    lastAnalyzed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AICompanyIntelligenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AICompanyIntelligenceUpdatepainPointsInput | string[]
    budgetEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMakers?: AICompanyIntelligenceUpdatedecisionMakersInput | string[]
    competitors?: AICompanyIntelligenceUpdatecompetitorsInput | string[]
    recentNews?: NullableJsonNullValueInput | InputJsonValue
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timesAnalyzed?: IntFieldUpdateOperationsInput | number
    lastAnalyzed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICompanyIntelligenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AICompanyIntelligenceUpdatepainPointsInput | string[]
    budgetEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMakers?: AICompanyIntelligenceUpdatedecisionMakersInput | string[]
    competitors?: AICompanyIntelligenceUpdatecompetitorsInput | string[]
    recentNews?: NullableJsonNullValueInput | InputJsonValue
    marketTrends?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timesAnalyzed?: IntFieldUpdateOperationsInput | number
    lastAnalyzed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIStrategyPerformanceCreateInput = {
    id?: string
    strategy: string
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    clientType?: string | null
    timesUsed?: number
    avgEffectiveness?: number
    conversionRate?: number | null
    avgEngagement?: number | null
    successFactors?: NullableJsonNullValueInput | InputJsonValue
    failureReasons?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIStrategyPerformanceUncheckedCreateInput = {
    id?: string
    strategy: string
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    clientType?: string | null
    timesUsed?: number
    avgEffectiveness?: number
    conversionRate?: number | null
    avgEngagement?: number | null
    successFactors?: NullableJsonNullValueInput | InputJsonValue
    failureReasons?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIStrategyPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    clientType?: NullableStringFieldUpdateOperationsInput | string | null
    timesUsed?: IntFieldUpdateOperationsInput | number
    avgEffectiveness?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    successFactors?: NullableJsonNullValueInput | InputJsonValue
    failureReasons?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIStrategyPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    clientType?: NullableStringFieldUpdateOperationsInput | string | null
    timesUsed?: IntFieldUpdateOperationsInput | number
    avgEffectiveness?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    successFactors?: NullableJsonNullValueInput | InputJsonValue
    failureReasons?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIStrategyPerformanceCreateManyInput = {
    id?: string
    strategy: string
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    clientType?: string | null
    timesUsed?: number
    avgEffectiveness?: number
    conversionRate?: number | null
    avgEngagement?: number | null
    successFactors?: NullableJsonNullValueInput | InputJsonValue
    failureReasons?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIStrategyPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    clientType?: NullableStringFieldUpdateOperationsInput | string | null
    timesUsed?: IntFieldUpdateOperationsInput | number
    avgEffectiveness?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    successFactors?: NullableJsonNullValueInput | InputJsonValue
    failureReasons?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIStrategyPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    clientType?: NullableStringFieldUpdateOperationsInput | string | null
    timesUsed?: IntFieldUpdateOperationsInput | number
    avgEffectiveness?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    successFactors?: NullableJsonNullValueInput | InputJsonValue
    failureReasons?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CaseListRelationFilter = {
    every?: CaseWhereInput
    some?: CaseWhereInput
    none?: CaseWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TaxExemptDocumentListRelationFilter = {
    every?: TaxExemptDocumentWhereInput
    some?: TaxExemptDocumentWhereInput
    none?: TaxExemptDocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxExemptDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    bcCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    bcCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    bcCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDocTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocTypeFilter<$PrismaModel> | $Enums.DocType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductDocAssetBcProductIdDocTypeVersionCompoundUniqueInput = {
    bcProductId: string
    docType: $Enums.DocType
    version: string
  }

  export type ProductDocAssetCountOrderByAggregateInput = {
    id?: SortOrder
    bcProductId?: SortOrder
    sku?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductDocAssetAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ProductDocAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    bcProductId?: SortOrder
    sku?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductDocAssetMinOrderByAggregateInput = {
    id?: SortOrder
    bcProductId?: SortOrder
    sku?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    url?: SortOrder
    version?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductDocAssetSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocTypeFilter<$PrismaModel>
    _max?: NestedEnumDocTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumCaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseType | EnumCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeFilter<$PrismaModel> | $Enums.CaseType
  }

  export type EnumCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseStatus | EnumCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseStatusFilter<$PrismaModel> | $Enums.CaseStatus
  }

  export type EnumCasePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.CasePriority | EnumCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumCasePriorityFilter<$PrismaModel> | $Enums.CasePriority
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CaseAttachmentListRelationFilter = {
    every?: CaseAttachmentWhereInput
    some?: CaseAttachmentWhereInput
    none?: CaseAttachmentWhereInput
  }

  export type CaseMessageListRelationFilter = {
    every?: CaseMessageWhereInput
    some?: CaseMessageWhereInput
    none?: CaseMessageWhereInput
  }

  export type CaseAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseCountOrderByAggregateInput = {
    id?: SortOrder
    caseNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDueAt?: SortOrder
    slaBreached?: SortOrder
    customerId?: SortOrder
    contactEmail?: SortOrder
    companyName?: SortOrder
    subject?: SortOrder
    customerMessage?: SortOrder
    internalNotes?: SortOrder
    relatedSkus?: SortOrder
    relatedOrderIds?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type CaseMaxOrderByAggregateInput = {
    id?: SortOrder
    caseNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDueAt?: SortOrder
    slaBreached?: SortOrder
    customerId?: SortOrder
    contactEmail?: SortOrder
    companyName?: SortOrder
    subject?: SortOrder
    customerMessage?: SortOrder
    internalNotes?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type CaseMinOrderByAggregateInput = {
    id?: SortOrder
    caseNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDueAt?: SortOrder
    slaBreached?: SortOrder
    customerId?: SortOrder
    contactEmail?: SortOrder
    companyName?: SortOrder
    subject?: SortOrder
    customerMessage?: SortOrder
    internalNotes?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type EnumCaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseType | EnumCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseTypeFilter<$PrismaModel>
    _max?: NestedEnumCaseTypeFilter<$PrismaModel>
  }

  export type EnumCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseStatus | EnumCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCaseStatusFilter<$PrismaModel>
  }

  export type EnumCasePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CasePriority | EnumCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumCasePriorityWithAggregatesFilter<$PrismaModel> | $Enums.CasePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCasePriorityFilter<$PrismaModel>
    _max?: NestedEnumCasePriorityFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CaseRelationFilter = {
    is?: CaseWhereInput
    isNot?: CaseWhereInput
  }

  export type CaseAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type CaseAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type CaseMessageCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseMessageMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CaseNullableRelationFilter = {
    is?: CaseWhereInput | null
    isNot?: CaseWhereInput | null
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    customerId?: SortOrder
    caseId?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountPercent?: SortOrder
    shippingAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    shippingTerms?: SortOrder
    leadTimeTerms?: SortOrder
    paymentTerms?: SortOrder
    exceptions?: SortOrder
    acceptedAt?: SortOrder
    acceptedBy?: SortOrder
    bcOrderId?: SortOrder
    createdById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    version?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountPercent?: SortOrder
    shippingAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    customerId?: SortOrder
    caseId?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountPercent?: SortOrder
    shippingAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    shippingTerms?: SortOrder
    leadTimeTerms?: SortOrder
    paymentTerms?: SortOrder
    exceptions?: SortOrder
    acceptedAt?: SortOrder
    acceptedBy?: SortOrder
    bcOrderId?: SortOrder
    createdById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    customerId?: SortOrder
    caseId?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountPercent?: SortOrder
    shippingAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    shippingTerms?: SortOrder
    leadTimeTerms?: SortOrder
    paymentTerms?: SortOrder
    exceptions?: SortOrder
    acceptedAt?: SortOrder
    acceptedBy?: SortOrder
    bcOrderId?: SortOrder
    createdById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    version?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountPercent?: SortOrder
    shippingAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type SpecPackageListRelationFilter = {
    every?: SpecPackageWhereInput
    some?: SpecPackageWhereInput
    none?: SpecPackageWhereInput
  }

  export type SpecPackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    projectName?: SortOrder
    customerId?: SortOrder
    siteAddress?: SortOrder
    savedSkus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    projectName?: SortOrder
    customerId?: SortOrder
    siteAddress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    projectName?: SortOrder
    customerId?: SortOrder
    siteAddress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type SpecPackageCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    skus?: SortOrder
    zipUrl?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    zipUrl?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecPackageMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    zipUrl?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTaxExemptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxExemptStatus | EnumTaxExemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxExemptStatusFilter<$PrismaModel> | $Enums.TaxExemptStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TaxExemptDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    state?: SortOrder
    documentUrl?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    auditLog?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxExemptDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    state?: SortOrder
    documentUrl?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxExemptDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    state?: SortOrder
    documentUrl?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaxExemptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxExemptStatus | EnumTaxExemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxExemptStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaxExemptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxExemptStatusFilter<$PrismaModel>
    _max?: NestedEnumTaxExemptStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type EnumPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusFilter<$PrismaModel> | $Enums.PartnerStatus
  }

  export type PartnerAttributionListRelationFilter = {
    every?: PartnerAttributionWhereInput
    some?: PartnerAttributionWhereInput
    none?: PartnerAttributionWhereInput
  }

  export type PartnerAttributionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerType?: SortOrder
    companyName?: SortOrder
    status?: SortOrder
    referralCode?: SortOrder
    commissionRate?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerAvgOrderByAggregateInput = {
    commissionRate?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerType?: SortOrder
    companyName?: SortOrder
    status?: SortOrder
    referralCode?: SortOrder
    commissionRate?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    partnerType?: SortOrder
    companyName?: SortOrder
    status?: SortOrder
    referralCode?: SortOrder
    commissionRate?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerSumOrderByAggregateInput = {
    commissionRate?: SortOrder
  }

  export type EnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type EnumPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerStatusFilter<$PrismaModel>
  }

  export type PartnerRelationFilter = {
    is?: PartnerWhereInput
    isNot?: PartnerWhereInput
  }

  export type PartnerAttributionCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    bcOrderId?: SortOrder
    orderTotal?: SortOrder
    commission?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PartnerAttributionAvgOrderByAggregateInput = {
    orderTotal?: SortOrder
    commission?: SortOrder
  }

  export type PartnerAttributionMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    bcOrderId?: SortOrder
    orderTotal?: SortOrder
    commission?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PartnerAttributionMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    bcOrderId?: SortOrder
    orderTotal?: SortOrder
    commission?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PartnerAttributionSumOrderByAggregateInput = {
    orderTotal?: SortOrder
    commission?: SortOrder
  }

  export type EnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type QboSyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    sourceId?: SortOrder
    qboId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    lastAttemptAt?: SortOrder
    payload?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QboSyncLogAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type QboSyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    sourceId?: SortOrder
    qboId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QboSyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    sourceId?: SortOrder
    qboId?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QboSyncLogSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type EnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type ShippingSyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    bcOrderId?: SortOrder
    shipmentId?: SortOrder
    carrier?: SortOrder
    trackingNumber?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingSyncLogAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type ShippingSyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    bcOrderId?: SortOrder
    shipmentId?: SortOrder
    carrier?: SortOrder
    trackingNumber?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingSyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    bcOrderId?: SortOrder
    shipmentId?: SortOrder
    carrier?: SortOrder
    trackingNumber?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingSyncLogSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type KnowledgeBaseEntryCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    sourceUrl?: SortOrder
    embedding?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    sourceUrl?: SortOrder
    embedding?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseEntryMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    sourceUrl?: SortOrder
    embedding?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type AIChatLogCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    userMessage?: SortOrder
    aiResponse?: SortOrder
    sourcesUsed?: SortOrder
    handoffCaseId?: SortOrder
    feedbackRating?: SortOrder
    createdAt?: SortOrder
  }

  export type AIChatLogAvgOrderByAggregateInput = {
    feedbackRating?: SortOrder
  }

  export type AIChatLogMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    userMessage?: SortOrder
    aiResponse?: SortOrder
    handoffCaseId?: SortOrder
    feedbackRating?: SortOrder
    createdAt?: SortOrder
  }

  export type AIChatLogMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    userMessage?: SortOrder
    aiResponse?: SortOrder
    handoffCaseId?: SortOrder
    feedbackRating?: SortOrder
    createdAt?: SortOrder
  }

  export type AIChatLogSumOrderByAggregateInput = {
    feedbackRating?: SortOrder
  }

  export type CaseStudyCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    highlights?: SortOrder
    product?: SortOrder
    productSlug?: SortOrder
    clients?: SortOrder
    location?: SortOrder
    images?: SortOrder
    youtubeId?: SortOrder
    stats?: SortOrder
    sortOrder?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseStudyAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CaseStudyMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    product?: SortOrder
    productSlug?: SortOrder
    location?: SortOrder
    youtubeId?: SortOrder
    sortOrder?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseStudyMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    product?: SortOrder
    productSlug?: SortOrder
    location?: SortOrder
    youtubeId?: SortOrder
    sortOrder?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseStudySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventName?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    properties?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventName?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventName?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCompanySizeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanySizeNullableFilter<$PrismaModel> | $Enums.CompanySize | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AIConversationListRelationFilter = {
    every?: AIConversationWhereInput
    some?: AIConversationWhereInput
    none?: AIConversationWhereInput
  }

  export type AILeadDataNullableRelationFilter = {
    is?: AILeadDataWhereInput | null
    isNot?: AILeadDataWhereInput | null
  }

  export type AIConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIClientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    website?: SortOrder
    position?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    communicationStyle?: SortOrder
    decisionSpeed?: SortOrder
    techLevel?: SortOrder
    priceSensitivity?: SortOrder
    avgResponseTime?: SortOrder
    messageLength?: SortOrder
    interestLevel?: SortOrder
    painPoints?: SortOrder
    budget?: SortOrder
    timeline?: SortOrder
    competitors?: SortOrder
    conversationSummary?: SortOrder
    totalMessages?: SortOrder
    avgSentiment?: SortOrder
    avgEngagement?: SortOrder
    strategyEffectiveness?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type AIClientProfileAvgOrderByAggregateInput = {
    avgResponseTime?: SortOrder
    totalMessages?: SortOrder
    avgSentiment?: SortOrder
    avgEngagement?: SortOrder
  }

  export type AIClientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    website?: SortOrder
    position?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    communicationStyle?: SortOrder
    decisionSpeed?: SortOrder
    techLevel?: SortOrder
    priceSensitivity?: SortOrder
    avgResponseTime?: SortOrder
    messageLength?: SortOrder
    interestLevel?: SortOrder
    budget?: SortOrder
    timeline?: SortOrder
    conversationSummary?: SortOrder
    totalMessages?: SortOrder
    avgSentiment?: SortOrder
    avgEngagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type AIClientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    website?: SortOrder
    position?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    communicationStyle?: SortOrder
    decisionSpeed?: SortOrder
    techLevel?: SortOrder
    priceSensitivity?: SortOrder
    avgResponseTime?: SortOrder
    messageLength?: SortOrder
    interestLevel?: SortOrder
    budget?: SortOrder
    timeline?: SortOrder
    conversationSummary?: SortOrder
    totalMessages?: SortOrder
    avgSentiment?: SortOrder
    avgEngagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type AIClientProfileSumOrderByAggregateInput = {
    avgResponseTime?: SortOrder
    totalMessages?: SortOrder
    avgSentiment?: SortOrder
    avgEngagement?: SortOrder
  }

  export type EnumCompanySizeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanySizeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CompanySize | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCompanySizeNullableFilter<$PrismaModel>
    _max?: NestedEnumCompanySizeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AIClientProfileRelationFilter = {
    is?: AIClientProfileWhereInput
    isNot?: AIClientProfileWhereInput
  }

  export type AIConversationCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    attachments?: SortOrder
    sentiment?: SortOrder
    engagement?: SortOrder
    intent?: SortOrder
    urgency?: SortOrder
    strategy?: SortOrder
    effectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type AIConversationAvgOrderByAggregateInput = {
    sentiment?: SortOrder
    engagement?: SortOrder
    effectiveness?: SortOrder
  }

  export type AIConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    sentiment?: SortOrder
    engagement?: SortOrder
    urgency?: SortOrder
    strategy?: SortOrder
    effectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type AIConversationMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    sentiment?: SortOrder
    engagement?: SortOrder
    urgency?: SortOrder
    strategy?: SortOrder
    effectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type AIConversationSumOrderByAggregateInput = {
    sentiment?: SortOrder
    engagement?: SortOrder
    effectiveness?: SortOrder
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type EnumSalesStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SalesStage | EnumSalesStageFieldRefInput<$PrismaModel>
    in?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSalesStageFilter<$PrismaModel> | $Enums.SalesStage
  }

  export type AILeadDataCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    leadScore?: SortOrder
    leadStatus?: SortOrder
    estimatedValue?: SortOrder
    salesStage?: SortOrder
    nextAction?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    followUpAt?: SortOrder
    convertedAt?: SortOrder
    conversionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AILeadDataAvgOrderByAggregateInput = {
    leadScore?: SortOrder
    conversionValue?: SortOrder
  }

  export type AILeadDataMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    leadScore?: SortOrder
    leadStatus?: SortOrder
    estimatedValue?: SortOrder
    salesStage?: SortOrder
    nextAction?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    followUpAt?: SortOrder
    convertedAt?: SortOrder
    conversionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AILeadDataMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    leadScore?: SortOrder
    leadStatus?: SortOrder
    estimatedValue?: SortOrder
    salesStage?: SortOrder
    nextAction?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    followUpAt?: SortOrder
    convertedAt?: SortOrder
    conversionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AILeadDataSumOrderByAggregateInput = {
    leadScore?: SortOrder
    conversionValue?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type EnumSalesStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalesStage | EnumSalesStageFieldRefInput<$PrismaModel>
    in?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSalesStageWithAggregatesFilter<$PrismaModel> | $Enums.SalesStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalesStageFilter<$PrismaModel>
    _max?: NestedEnumSalesStageFilter<$PrismaModel>
  }

  export type AICompanyIntelligenceCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    description?: SortOrder
    painPoints?: SortOrder
    budgetEstimate?: SortOrder
    decisionMakers?: SortOrder
    competitors?: SortOrder
    recentNews?: SortOrder
    marketTrends?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    timesAnalyzed?: SortOrder
    lastAnalyzed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AICompanyIntelligenceAvgOrderByAggregateInput = {
    timesAnalyzed?: SortOrder
  }

  export type AICompanyIntelligenceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    description?: SortOrder
    budgetEstimate?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    timesAnalyzed?: SortOrder
    lastAnalyzed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AICompanyIntelligenceMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    description?: SortOrder
    budgetEstimate?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    timesAnalyzed?: SortOrder
    lastAnalyzed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AICompanyIntelligenceSumOrderByAggregateInput = {
    timesAnalyzed?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AIStrategyPerformanceStrategyIndustryCompanySizeClientTypeCompoundUniqueInput = {
    strategy: string
    industry: string
    companySize: $Enums.CompanySize
    clientType: string
  }

  export type AIStrategyPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    clientType?: SortOrder
    timesUsed?: SortOrder
    avgEffectiveness?: SortOrder
    conversionRate?: SortOrder
    avgEngagement?: SortOrder
    successFactors?: SortOrder
    failureReasons?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIStrategyPerformanceAvgOrderByAggregateInput = {
    timesUsed?: SortOrder
    avgEffectiveness?: SortOrder
    conversionRate?: SortOrder
    avgEngagement?: SortOrder
  }

  export type AIStrategyPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    clientType?: SortOrder
    timesUsed?: SortOrder
    avgEffectiveness?: SortOrder
    conversionRate?: SortOrder
    avgEngagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIStrategyPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    clientType?: SortOrder
    timesUsed?: SortOrder
    avgEffectiveness?: SortOrder
    conversionRate?: SortOrder
    avgEngagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIStrategyPerformanceSumOrderByAggregateInput = {
    timesUsed?: SortOrder
    avgEffectiveness?: SortOrder
    conversionRate?: SortOrder
    avgEngagement?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CaseCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CaseCreateWithoutCustomerInput, CaseUncheckedCreateWithoutCustomerInput> | CaseCreateWithoutCustomerInput[] | CaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutCustomerInput | CaseCreateOrConnectWithoutCustomerInput[]
    createMany?: CaseCreateManyCustomerInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutCustomerInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TaxExemptDocumentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TaxExemptDocumentCreateWithoutCustomerInput, TaxExemptDocumentUncheckedCreateWithoutCustomerInput> | TaxExemptDocumentCreateWithoutCustomerInput[] | TaxExemptDocumentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxExemptDocumentCreateOrConnectWithoutCustomerInput | TaxExemptDocumentCreateOrConnectWithoutCustomerInput[]
    createMany?: TaxExemptDocumentCreateManyCustomerInputEnvelope
    connect?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
  }

  export type CaseCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<CaseCreateWithoutAssignedToInput, CaseUncheckedCreateWithoutAssignedToInput> | CaseCreateWithoutAssignedToInput[] | CaseUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAssignedToInput | CaseCreateOrConnectWithoutAssignedToInput[]
    createMany?: CaseCreateManyAssignedToInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type CaseUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CaseCreateWithoutCustomerInput, CaseUncheckedCreateWithoutCustomerInput> | CaseCreateWithoutCustomerInput[] | CaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutCustomerInput | CaseCreateOrConnectWithoutCustomerInput[]
    createMany?: CaseCreateManyCustomerInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TaxExemptDocumentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TaxExemptDocumentCreateWithoutCustomerInput, TaxExemptDocumentUncheckedCreateWithoutCustomerInput> | TaxExemptDocumentCreateWithoutCustomerInput[] | TaxExemptDocumentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxExemptDocumentCreateOrConnectWithoutCustomerInput | TaxExemptDocumentCreateOrConnectWithoutCustomerInput[]
    createMany?: TaxExemptDocumentCreateManyCustomerInputEnvelope
    connect?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
  }

  export type CaseUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<CaseCreateWithoutAssignedToInput, CaseUncheckedCreateWithoutAssignedToInput> | CaseCreateWithoutAssignedToInput[] | CaseUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAssignedToInput | CaseCreateOrConnectWithoutAssignedToInput[]
    createMany?: CaseCreateManyAssignedToInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CaseUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CaseCreateWithoutCustomerInput, CaseUncheckedCreateWithoutCustomerInput> | CaseCreateWithoutCustomerInput[] | CaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutCustomerInput | CaseCreateOrConnectWithoutCustomerInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutCustomerInput | CaseUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CaseCreateManyCustomerInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutCustomerInput | CaseUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutCustomerInput | CaseUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerInput | QuoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerInput | QuoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerInput | QuoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCustomerInput | ProjectUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCustomerInput | ProjectUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCustomerInput | ProjectUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TaxExemptDocumentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TaxExemptDocumentCreateWithoutCustomerInput, TaxExemptDocumentUncheckedCreateWithoutCustomerInput> | TaxExemptDocumentCreateWithoutCustomerInput[] | TaxExemptDocumentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxExemptDocumentCreateOrConnectWithoutCustomerInput | TaxExemptDocumentCreateOrConnectWithoutCustomerInput[]
    upsert?: TaxExemptDocumentUpsertWithWhereUniqueWithoutCustomerInput | TaxExemptDocumentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TaxExemptDocumentCreateManyCustomerInputEnvelope
    set?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    disconnect?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    delete?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    connect?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    update?: TaxExemptDocumentUpdateWithWhereUniqueWithoutCustomerInput | TaxExemptDocumentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TaxExemptDocumentUpdateManyWithWhereWithoutCustomerInput | TaxExemptDocumentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TaxExemptDocumentScalarWhereInput | TaxExemptDocumentScalarWhereInput[]
  }

  export type CaseUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<CaseCreateWithoutAssignedToInput, CaseUncheckedCreateWithoutAssignedToInput> | CaseCreateWithoutAssignedToInput[] | CaseUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAssignedToInput | CaseCreateOrConnectWithoutAssignedToInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutAssignedToInput | CaseUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: CaseCreateManyAssignedToInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutAssignedToInput | CaseUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutAssignedToInput | CaseUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type CaseUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CaseCreateWithoutCustomerInput, CaseUncheckedCreateWithoutCustomerInput> | CaseCreateWithoutCustomerInput[] | CaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutCustomerInput | CaseCreateOrConnectWithoutCustomerInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutCustomerInput | CaseUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CaseCreateManyCustomerInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutCustomerInput | CaseUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutCustomerInput | CaseUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerInput | QuoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerInput | QuoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerInput | QuoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCustomerInput | ProjectUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCustomerInput | ProjectUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCustomerInput | ProjectUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TaxExemptDocumentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TaxExemptDocumentCreateWithoutCustomerInput, TaxExemptDocumentUncheckedCreateWithoutCustomerInput> | TaxExemptDocumentCreateWithoutCustomerInput[] | TaxExemptDocumentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TaxExemptDocumentCreateOrConnectWithoutCustomerInput | TaxExemptDocumentCreateOrConnectWithoutCustomerInput[]
    upsert?: TaxExemptDocumentUpsertWithWhereUniqueWithoutCustomerInput | TaxExemptDocumentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TaxExemptDocumentCreateManyCustomerInputEnvelope
    set?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    disconnect?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    delete?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    connect?: TaxExemptDocumentWhereUniqueInput | TaxExemptDocumentWhereUniqueInput[]
    update?: TaxExemptDocumentUpdateWithWhereUniqueWithoutCustomerInput | TaxExemptDocumentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TaxExemptDocumentUpdateManyWithWhereWithoutCustomerInput | TaxExemptDocumentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TaxExemptDocumentScalarWhereInput | TaxExemptDocumentScalarWhereInput[]
  }

  export type CaseUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<CaseCreateWithoutAssignedToInput, CaseUncheckedCreateWithoutAssignedToInput> | CaseCreateWithoutAssignedToInput[] | CaseUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAssignedToInput | CaseCreateOrConnectWithoutAssignedToInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutAssignedToInput | CaseUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: CaseCreateManyAssignedToInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutAssignedToInput | CaseUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutAssignedToInput | CaseUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type EnumDocTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CaseCreaterelatedSkusInput = {
    set: string[]
  }

  export type CaseCreaterelatedOrderIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCasesInput = {
    create?: XOR<UserCreateWithoutCasesInput, UserUncheckedCreateWithoutCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCasesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedCasesInput = {
    create?: XOR<UserCreateWithoutAssignedCasesInput, UserUncheckedCreateWithoutAssignedCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedCasesInput
    connect?: UserWhereUniqueInput
  }

  export type CaseAttachmentCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseAttachmentCreateWithoutCaseInput, CaseAttachmentUncheckedCreateWithoutCaseInput> | CaseAttachmentCreateWithoutCaseInput[] | CaseAttachmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseAttachmentCreateOrConnectWithoutCaseInput | CaseAttachmentCreateOrConnectWithoutCaseInput[]
    createMany?: CaseAttachmentCreateManyCaseInputEnvelope
    connect?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
  }

  export type CaseMessageCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseMessageCreateWithoutCaseInput, CaseMessageUncheckedCreateWithoutCaseInput> | CaseMessageCreateWithoutCaseInput[] | CaseMessageUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseMessageCreateOrConnectWithoutCaseInput | CaseMessageCreateOrConnectWithoutCaseInput[]
    createMany?: CaseMessageCreateManyCaseInputEnvelope
    connect?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutCaseInput = {
    create?: XOR<QuoteCreateWithoutCaseInput, QuoteUncheckedCreateWithoutCaseInput> | QuoteCreateWithoutCaseInput[] | QuoteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCaseInput | QuoteCreateOrConnectWithoutCaseInput[]
    createMany?: QuoteCreateManyCaseInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type CaseAttachmentUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseAttachmentCreateWithoutCaseInput, CaseAttachmentUncheckedCreateWithoutCaseInput> | CaseAttachmentCreateWithoutCaseInput[] | CaseAttachmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseAttachmentCreateOrConnectWithoutCaseInput | CaseAttachmentCreateOrConnectWithoutCaseInput[]
    createMany?: CaseAttachmentCreateManyCaseInputEnvelope
    connect?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
  }

  export type CaseMessageUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseMessageCreateWithoutCaseInput, CaseMessageUncheckedCreateWithoutCaseInput> | CaseMessageCreateWithoutCaseInput[] | CaseMessageUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseMessageCreateOrConnectWithoutCaseInput | CaseMessageCreateOrConnectWithoutCaseInput[]
    createMany?: CaseMessageCreateManyCaseInputEnvelope
    connect?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<QuoteCreateWithoutCaseInput, QuoteUncheckedCreateWithoutCaseInput> | QuoteCreateWithoutCaseInput[] | QuoteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCaseInput | QuoteCreateOrConnectWithoutCaseInput[]
    createMany?: QuoteCreateManyCaseInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type EnumCaseTypeFieldUpdateOperationsInput = {
    set?: $Enums.CaseType
  }

  export type EnumCaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CaseStatus
  }

  export type EnumCasePriorityFieldUpdateOperationsInput = {
    set?: $Enums.CasePriority
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CaseUpdaterelatedSkusInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CaseUpdaterelatedOrderIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCasesNestedInput = {
    create?: XOR<UserCreateWithoutCasesInput, UserUncheckedCreateWithoutCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCasesInput
    upsert?: UserUpsertWithoutCasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCasesInput, UserUpdateWithoutCasesInput>, UserUncheckedUpdateWithoutCasesInput>
  }

  export type UserUpdateOneWithoutAssignedCasesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedCasesInput, UserUncheckedCreateWithoutAssignedCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedCasesInput
    upsert?: UserUpsertWithoutAssignedCasesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedCasesInput, UserUpdateWithoutAssignedCasesInput>, UserUncheckedUpdateWithoutAssignedCasesInput>
  }

  export type CaseAttachmentUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseAttachmentCreateWithoutCaseInput, CaseAttachmentUncheckedCreateWithoutCaseInput> | CaseAttachmentCreateWithoutCaseInput[] | CaseAttachmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseAttachmentCreateOrConnectWithoutCaseInput | CaseAttachmentCreateOrConnectWithoutCaseInput[]
    upsert?: CaseAttachmentUpsertWithWhereUniqueWithoutCaseInput | CaseAttachmentUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseAttachmentCreateManyCaseInputEnvelope
    set?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    disconnect?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    delete?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    connect?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    update?: CaseAttachmentUpdateWithWhereUniqueWithoutCaseInput | CaseAttachmentUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseAttachmentUpdateManyWithWhereWithoutCaseInput | CaseAttachmentUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseAttachmentScalarWhereInput | CaseAttachmentScalarWhereInput[]
  }

  export type CaseMessageUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseMessageCreateWithoutCaseInput, CaseMessageUncheckedCreateWithoutCaseInput> | CaseMessageCreateWithoutCaseInput[] | CaseMessageUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseMessageCreateOrConnectWithoutCaseInput | CaseMessageCreateOrConnectWithoutCaseInput[]
    upsert?: CaseMessageUpsertWithWhereUniqueWithoutCaseInput | CaseMessageUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseMessageCreateManyCaseInputEnvelope
    set?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    disconnect?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    delete?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    connect?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    update?: CaseMessageUpdateWithWhereUniqueWithoutCaseInput | CaseMessageUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseMessageUpdateManyWithWhereWithoutCaseInput | CaseMessageUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseMessageScalarWhereInput | CaseMessageScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutCaseNestedInput = {
    create?: XOR<QuoteCreateWithoutCaseInput, QuoteUncheckedCreateWithoutCaseInput> | QuoteCreateWithoutCaseInput[] | QuoteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCaseInput | QuoteCreateOrConnectWithoutCaseInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCaseInput | QuoteUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: QuoteCreateManyCaseInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCaseInput | QuoteUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCaseInput | QuoteUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type CaseAttachmentUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseAttachmentCreateWithoutCaseInput, CaseAttachmentUncheckedCreateWithoutCaseInput> | CaseAttachmentCreateWithoutCaseInput[] | CaseAttachmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseAttachmentCreateOrConnectWithoutCaseInput | CaseAttachmentCreateOrConnectWithoutCaseInput[]
    upsert?: CaseAttachmentUpsertWithWhereUniqueWithoutCaseInput | CaseAttachmentUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseAttachmentCreateManyCaseInputEnvelope
    set?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    disconnect?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    delete?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    connect?: CaseAttachmentWhereUniqueInput | CaseAttachmentWhereUniqueInput[]
    update?: CaseAttachmentUpdateWithWhereUniqueWithoutCaseInput | CaseAttachmentUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseAttachmentUpdateManyWithWhereWithoutCaseInput | CaseAttachmentUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseAttachmentScalarWhereInput | CaseAttachmentScalarWhereInput[]
  }

  export type CaseMessageUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseMessageCreateWithoutCaseInput, CaseMessageUncheckedCreateWithoutCaseInput> | CaseMessageCreateWithoutCaseInput[] | CaseMessageUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseMessageCreateOrConnectWithoutCaseInput | CaseMessageCreateOrConnectWithoutCaseInput[]
    upsert?: CaseMessageUpsertWithWhereUniqueWithoutCaseInput | CaseMessageUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseMessageCreateManyCaseInputEnvelope
    set?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    disconnect?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    delete?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    connect?: CaseMessageWhereUniqueInput | CaseMessageWhereUniqueInput[]
    update?: CaseMessageUpdateWithWhereUniqueWithoutCaseInput | CaseMessageUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseMessageUpdateManyWithWhereWithoutCaseInput | CaseMessageUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseMessageScalarWhereInput | CaseMessageScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<QuoteCreateWithoutCaseInput, QuoteUncheckedCreateWithoutCaseInput> | QuoteCreateWithoutCaseInput[] | QuoteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCaseInput | QuoteCreateOrConnectWithoutCaseInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCaseInput | QuoteUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: QuoteCreateManyCaseInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCaseInput | QuoteUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCaseInput | QuoteUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type CaseCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CaseCreateWithoutAttachmentsInput, CaseUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CaseCreateOrConnectWithoutAttachmentsInput
    connect?: CaseWhereUniqueInput
  }

  export type CaseUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<CaseCreateWithoutAttachmentsInput, CaseUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CaseCreateOrConnectWithoutAttachmentsInput
    upsert?: CaseUpsertWithoutAttachmentsInput
    connect?: CaseWhereUniqueInput
    update?: XOR<XOR<CaseUpdateToOneWithWhereWithoutAttachmentsInput, CaseUpdateWithoutAttachmentsInput>, CaseUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CaseCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CaseCreateWithoutMessagesInput, CaseUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CaseCreateOrConnectWithoutMessagesInput
    connect?: CaseWhereUniqueInput
  }

  export type CaseUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CaseCreateWithoutMessagesInput, CaseUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CaseCreateOrConnectWithoutMessagesInput
    upsert?: CaseUpsertWithoutMessagesInput
    connect?: CaseWhereUniqueInput
    update?: XOR<XOR<CaseUpdateToOneWithWhereWithoutMessagesInput, CaseUpdateWithoutMessagesInput>, CaseUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutQuotesInput = {
    create?: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotesInput
    connect?: UserWhereUniqueInput
  }

  export type CaseCreateNestedOneWithoutQuotesInput = {
    create?: XOR<CaseCreateWithoutQuotesInput, CaseUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CaseCreateOrConnectWithoutQuotesInput
    connect?: CaseWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutQuotesInput = {
    create?: XOR<ProjectCreateWithoutQuotesInput, ProjectUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutQuotesInput
    connect?: ProjectWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumQuoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuoteStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotesInput
    upsert?: UserUpsertWithoutQuotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuotesInput, UserUpdateWithoutQuotesInput>, UserUncheckedUpdateWithoutQuotesInput>
  }

  export type CaseUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<CaseCreateWithoutQuotesInput, CaseUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CaseCreateOrConnectWithoutQuotesInput
    upsert?: CaseUpsertWithoutQuotesInput
    disconnect?: CaseWhereInput | boolean
    delete?: CaseWhereInput | boolean
    connect?: CaseWhereUniqueInput
    update?: XOR<XOR<CaseUpdateToOneWithWhereWithoutQuotesInput, CaseUpdateWithoutQuotesInput>, CaseUncheckedUpdateWithoutQuotesInput>
  }

  export type ProjectUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<ProjectCreateWithoutQuotesInput, ProjectUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutQuotesInput
    upsert?: ProjectUpsertWithoutQuotesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutQuotesInput, ProjectUpdateWithoutQuotesInput>, ProjectUncheckedUpdateWithoutQuotesInput>
  }

  export type ProjectCreatesavedSkusInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type QuoteCreateNestedManyWithoutProjectInput = {
    create?: XOR<QuoteCreateWithoutProjectInput, QuoteUncheckedCreateWithoutProjectInput> | QuoteCreateWithoutProjectInput[] | QuoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutProjectInput | QuoteCreateOrConnectWithoutProjectInput[]
    createMany?: QuoteCreateManyProjectInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type SpecPackageCreateNestedManyWithoutProjectInput = {
    create?: XOR<SpecPackageCreateWithoutProjectInput, SpecPackageUncheckedCreateWithoutProjectInput> | SpecPackageCreateWithoutProjectInput[] | SpecPackageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpecPackageCreateOrConnectWithoutProjectInput | SpecPackageCreateOrConnectWithoutProjectInput[]
    createMany?: SpecPackageCreateManyProjectInputEnvelope
    connect?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<QuoteCreateWithoutProjectInput, QuoteUncheckedCreateWithoutProjectInput> | QuoteCreateWithoutProjectInput[] | QuoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutProjectInput | QuoteCreateOrConnectWithoutProjectInput[]
    createMany?: QuoteCreateManyProjectInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type SpecPackageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SpecPackageCreateWithoutProjectInput, SpecPackageUncheckedCreateWithoutProjectInput> | SpecPackageCreateWithoutProjectInput[] | SpecPackageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpecPackageCreateOrConnectWithoutProjectInput | SpecPackageCreateOrConnectWithoutProjectInput[]
    createMany?: SpecPackageCreateManyProjectInputEnvelope
    connect?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
  }

  export type ProjectUpdatesavedSkusInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type QuoteUpdateManyWithoutProjectNestedInput = {
    create?: XOR<QuoteCreateWithoutProjectInput, QuoteUncheckedCreateWithoutProjectInput> | QuoteCreateWithoutProjectInput[] | QuoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutProjectInput | QuoteCreateOrConnectWithoutProjectInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutProjectInput | QuoteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: QuoteCreateManyProjectInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutProjectInput | QuoteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutProjectInput | QuoteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type SpecPackageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SpecPackageCreateWithoutProjectInput, SpecPackageUncheckedCreateWithoutProjectInput> | SpecPackageCreateWithoutProjectInput[] | SpecPackageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpecPackageCreateOrConnectWithoutProjectInput | SpecPackageCreateOrConnectWithoutProjectInput[]
    upsert?: SpecPackageUpsertWithWhereUniqueWithoutProjectInput | SpecPackageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SpecPackageCreateManyProjectInputEnvelope
    set?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    disconnect?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    delete?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    connect?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    update?: SpecPackageUpdateWithWhereUniqueWithoutProjectInput | SpecPackageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SpecPackageUpdateManyWithWhereWithoutProjectInput | SpecPackageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SpecPackageScalarWhereInput | SpecPackageScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<QuoteCreateWithoutProjectInput, QuoteUncheckedCreateWithoutProjectInput> | QuoteCreateWithoutProjectInput[] | QuoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutProjectInput | QuoteCreateOrConnectWithoutProjectInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutProjectInput | QuoteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: QuoteCreateManyProjectInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutProjectInput | QuoteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutProjectInput | QuoteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type SpecPackageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SpecPackageCreateWithoutProjectInput, SpecPackageUncheckedCreateWithoutProjectInput> | SpecPackageCreateWithoutProjectInput[] | SpecPackageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpecPackageCreateOrConnectWithoutProjectInput | SpecPackageCreateOrConnectWithoutProjectInput[]
    upsert?: SpecPackageUpsertWithWhereUniqueWithoutProjectInput | SpecPackageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SpecPackageCreateManyProjectInputEnvelope
    set?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    disconnect?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    delete?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    connect?: SpecPackageWhereUniqueInput | SpecPackageWhereUniqueInput[]
    update?: SpecPackageUpdateWithWhereUniqueWithoutProjectInput | SpecPackageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SpecPackageUpdateManyWithWhereWithoutProjectInput | SpecPackageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SpecPackageScalarWhereInput | SpecPackageScalarWhereInput[]
  }

  export type SpecPackageCreateskusInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutSpecPackagesInput = {
    create?: XOR<ProjectCreateWithoutSpecPackagesInput, ProjectUncheckedCreateWithoutSpecPackagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSpecPackagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type SpecPackageUpdateskusInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutSpecPackagesNestedInput = {
    create?: XOR<ProjectCreateWithoutSpecPackagesInput, ProjectUncheckedCreateWithoutSpecPackagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSpecPackagesInput
    upsert?: ProjectUpsertWithoutSpecPackagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSpecPackagesInput, ProjectUpdateWithoutSpecPackagesInput>, ProjectUncheckedUpdateWithoutSpecPackagesInput>
  }

  export type UserCreateNestedOneWithoutTaxExemptDocumentsInput = {
    create?: XOR<UserCreateWithoutTaxExemptDocumentsInput, UserUncheckedCreateWithoutTaxExemptDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxExemptDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaxExemptStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaxExemptStatus
  }

  export type UserUpdateOneRequiredWithoutTaxExemptDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutTaxExemptDocumentsInput, UserUncheckedCreateWithoutTaxExemptDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxExemptDocumentsInput
    upsert?: UserUpsertWithoutTaxExemptDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaxExemptDocumentsInput, UserUpdateWithoutTaxExemptDocumentsInput>, UserUncheckedUpdateWithoutTaxExemptDocumentsInput>
  }

  export type PartnerAttributionCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerAttributionCreateWithoutPartnerInput, PartnerAttributionUncheckedCreateWithoutPartnerInput> | PartnerAttributionCreateWithoutPartnerInput[] | PartnerAttributionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerAttributionCreateOrConnectWithoutPartnerInput | PartnerAttributionCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerAttributionCreateManyPartnerInputEnvelope
    connect?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
  }

  export type PartnerAttributionUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerAttributionCreateWithoutPartnerInput, PartnerAttributionUncheckedCreateWithoutPartnerInput> | PartnerAttributionCreateWithoutPartnerInput[] | PartnerAttributionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerAttributionCreateOrConnectWithoutPartnerInput | PartnerAttributionCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerAttributionCreateManyPartnerInputEnvelope
    connect?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
  }

  export type EnumPartnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.PartnerType
  }

  export type EnumPartnerStatusFieldUpdateOperationsInput = {
    set?: $Enums.PartnerStatus
  }

  export type PartnerAttributionUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerAttributionCreateWithoutPartnerInput, PartnerAttributionUncheckedCreateWithoutPartnerInput> | PartnerAttributionCreateWithoutPartnerInput[] | PartnerAttributionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerAttributionCreateOrConnectWithoutPartnerInput | PartnerAttributionCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerAttributionUpsertWithWhereUniqueWithoutPartnerInput | PartnerAttributionUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerAttributionCreateManyPartnerInputEnvelope
    set?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    disconnect?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    delete?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    connect?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    update?: PartnerAttributionUpdateWithWhereUniqueWithoutPartnerInput | PartnerAttributionUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerAttributionUpdateManyWithWhereWithoutPartnerInput | PartnerAttributionUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerAttributionScalarWhereInput | PartnerAttributionScalarWhereInput[]
  }

  export type PartnerAttributionUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerAttributionCreateWithoutPartnerInput, PartnerAttributionUncheckedCreateWithoutPartnerInput> | PartnerAttributionCreateWithoutPartnerInput[] | PartnerAttributionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerAttributionCreateOrConnectWithoutPartnerInput | PartnerAttributionCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerAttributionUpsertWithWhereUniqueWithoutPartnerInput | PartnerAttributionUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerAttributionCreateManyPartnerInputEnvelope
    set?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    disconnect?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    delete?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    connect?: PartnerAttributionWhereUniqueInput | PartnerAttributionWhereUniqueInput[]
    update?: PartnerAttributionUpdateWithWhereUniqueWithoutPartnerInput | PartnerAttributionUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerAttributionUpdateManyWithWhereWithoutPartnerInput | PartnerAttributionUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerAttributionScalarWhereInput | PartnerAttributionScalarWhereInput[]
  }

  export type PartnerCreateNestedOneWithoutAttributionsInput = {
    create?: XOR<PartnerCreateWithoutAttributionsInput, PartnerUncheckedCreateWithoutAttributionsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutAttributionsInput
    connect?: PartnerWhereUniqueInput
  }

  export type PartnerUpdateOneRequiredWithoutAttributionsNestedInput = {
    create?: XOR<PartnerCreateWithoutAttributionsInput, PartnerUncheckedCreateWithoutAttributionsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutAttributionsInput
    upsert?: PartnerUpsertWithoutAttributionsInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutAttributionsInput, PartnerUpdateWithoutAttributionsInput>, PartnerUncheckedUpdateWithoutAttributionsInput>
  }

  export type EnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type AIChatLogCreatesourcesUsedInput = {
    set: string[]
  }

  export type AIChatLogUpdatesourcesUsedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CaseStudyCreatehighlightsInput = {
    set: string[]
  }

  export type CaseStudyCreateclientsInput = {
    set: string[]
  }

  export type CaseStudyCreateimagesInput = {
    set: string[]
  }

  export type CaseStudyUpdatehighlightsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CaseStudyUpdateclientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CaseStudyUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AIClientProfileCreatepainPointsInput = {
    set: string[]
  }

  export type AIClientProfileCreatecompetitorsInput = {
    set: string[]
  }

  export type AIConversationCreateNestedManyWithoutProfileInput = {
    create?: XOR<AIConversationCreateWithoutProfileInput, AIConversationUncheckedCreateWithoutProfileInput> | AIConversationCreateWithoutProfileInput[] | AIConversationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutProfileInput | AIConversationCreateOrConnectWithoutProfileInput[]
    createMany?: AIConversationCreateManyProfileInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type AILeadDataCreateNestedOneWithoutProfileInput = {
    create?: XOR<AILeadDataCreateWithoutProfileInput, AILeadDataUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AILeadDataCreateOrConnectWithoutProfileInput
    connect?: AILeadDataWhereUniqueInput
  }

  export type AIConversationUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<AIConversationCreateWithoutProfileInput, AIConversationUncheckedCreateWithoutProfileInput> | AIConversationCreateWithoutProfileInput[] | AIConversationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutProfileInput | AIConversationCreateOrConnectWithoutProfileInput[]
    createMany?: AIConversationCreateManyProfileInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type AILeadDataUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<AILeadDataCreateWithoutProfileInput, AILeadDataUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AILeadDataCreateOrConnectWithoutProfileInput
    connect?: AILeadDataWhereUniqueInput
  }

  export type NullableEnumCompanySizeFieldUpdateOperationsInput = {
    set?: $Enums.CompanySize | null
  }

  export type AIClientProfileUpdatepainPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AIClientProfileUpdatecompetitorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AIConversationUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AIConversationCreateWithoutProfileInput, AIConversationUncheckedCreateWithoutProfileInput> | AIConversationCreateWithoutProfileInput[] | AIConversationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutProfileInput | AIConversationCreateOrConnectWithoutProfileInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutProfileInput | AIConversationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AIConversationCreateManyProfileInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutProfileInput | AIConversationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutProfileInput | AIConversationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type AILeadDataUpdateOneWithoutProfileNestedInput = {
    create?: XOR<AILeadDataCreateWithoutProfileInput, AILeadDataUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AILeadDataCreateOrConnectWithoutProfileInput
    upsert?: AILeadDataUpsertWithoutProfileInput
    disconnect?: AILeadDataWhereInput | boolean
    delete?: AILeadDataWhereInput | boolean
    connect?: AILeadDataWhereUniqueInput
    update?: XOR<XOR<AILeadDataUpdateToOneWithWhereWithoutProfileInput, AILeadDataUpdateWithoutProfileInput>, AILeadDataUncheckedUpdateWithoutProfileInput>
  }

  export type AIConversationUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AIConversationCreateWithoutProfileInput, AIConversationUncheckedCreateWithoutProfileInput> | AIConversationCreateWithoutProfileInput[] | AIConversationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutProfileInput | AIConversationCreateOrConnectWithoutProfileInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutProfileInput | AIConversationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AIConversationCreateManyProfileInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutProfileInput | AIConversationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutProfileInput | AIConversationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type AILeadDataUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<AILeadDataCreateWithoutProfileInput, AILeadDataUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AILeadDataCreateOrConnectWithoutProfileInput
    upsert?: AILeadDataUpsertWithoutProfileInput
    disconnect?: AILeadDataWhereInput | boolean
    delete?: AILeadDataWhereInput | boolean
    connect?: AILeadDataWhereUniqueInput
    update?: XOR<XOR<AILeadDataUpdateToOneWithWhereWithoutProfileInput, AILeadDataUpdateWithoutProfileInput>, AILeadDataUncheckedUpdateWithoutProfileInput>
  }

  export type AIConversationCreateintentInput = {
    set: string[]
  }

  export type AIClientProfileCreateNestedOneWithoutConversationsInput = {
    create?: XOR<AIClientProfileCreateWithoutConversationsInput, AIClientProfileUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AIClientProfileCreateOrConnectWithoutConversationsInput
    connect?: AIClientProfileWhereUniqueInput
  }

  export type AIConversationUpdateintentInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AIClientProfileUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<AIClientProfileCreateWithoutConversationsInput, AIClientProfileUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AIClientProfileCreateOrConnectWithoutConversationsInput
    upsert?: AIClientProfileUpsertWithoutConversationsInput
    connect?: AIClientProfileWhereUniqueInput
    update?: XOR<XOR<AIClientProfileUpdateToOneWithWhereWithoutConversationsInput, AIClientProfileUpdateWithoutConversationsInput>, AIClientProfileUncheckedUpdateWithoutConversationsInput>
  }

  export type AIClientProfileCreateNestedOneWithoutLeadDataInput = {
    create?: XOR<AIClientProfileCreateWithoutLeadDataInput, AIClientProfileUncheckedCreateWithoutLeadDataInput>
    connectOrCreate?: AIClientProfileCreateOrConnectWithoutLeadDataInput
    connect?: AIClientProfileWhereUniqueInput
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type EnumSalesStageFieldUpdateOperationsInput = {
    set?: $Enums.SalesStage
  }

  export type AIClientProfileUpdateOneRequiredWithoutLeadDataNestedInput = {
    create?: XOR<AIClientProfileCreateWithoutLeadDataInput, AIClientProfileUncheckedCreateWithoutLeadDataInput>
    connectOrCreate?: AIClientProfileCreateOrConnectWithoutLeadDataInput
    upsert?: AIClientProfileUpsertWithoutLeadDataInput
    connect?: AIClientProfileWhereUniqueInput
    update?: XOR<XOR<AIClientProfileUpdateToOneWithWhereWithoutLeadDataInput, AIClientProfileUpdateWithoutLeadDataInput>, AIClientProfileUncheckedUpdateWithoutLeadDataInput>
  }

  export type AICompanyIntelligenceCreatepainPointsInput = {
    set: string[]
  }

  export type AICompanyIntelligenceCreatedecisionMakersInput = {
    set: string[]
  }

  export type AICompanyIntelligenceCreatecompetitorsInput = {
    set: string[]
  }

  export type AICompanyIntelligenceUpdatepainPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AICompanyIntelligenceUpdatedecisionMakersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AICompanyIntelligenceUpdatecompetitorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDocTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocTypeFilter<$PrismaModel> | $Enums.DocType
  }

  export type NestedEnumDocTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocType[] | ListEnumDocTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocTypeFilter<$PrismaModel>
    _max?: NestedEnumDocTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseType | EnumCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeFilter<$PrismaModel> | $Enums.CaseType
  }

  export type NestedEnumCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseStatus | EnumCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseStatusFilter<$PrismaModel> | $Enums.CaseStatus
  }

  export type NestedEnumCasePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.CasePriority | EnumCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumCasePriorityFilter<$PrismaModel> | $Enums.CasePriority
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseType | EnumCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseType[] | ListEnumCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseTypeFilter<$PrismaModel>
    _max?: NestedEnumCaseTypeFilter<$PrismaModel>
  }

  export type NestedEnumCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseStatus | EnumCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseStatus[] | ListEnumCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumCasePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CasePriority | EnumCasePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.CasePriority[] | ListEnumCasePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumCasePriorityWithAggregatesFilter<$PrismaModel> | $Enums.CasePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCasePriorityFilter<$PrismaModel>
    _max?: NestedEnumCasePriorityFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaxExemptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxExemptStatus | EnumTaxExemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxExemptStatusFilter<$PrismaModel> | $Enums.TaxExemptStatus
  }

  export type NestedEnumTaxExemptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxExemptStatus | EnumTaxExemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxExemptStatus[] | ListEnumTaxExemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxExemptStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaxExemptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxExemptStatusFilter<$PrismaModel>
    _max?: NestedEnumTaxExemptStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type NestedEnumPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusFilter<$PrismaModel> | $Enums.PartnerStatus
  }

  export type NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedEnumCompanySizeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanySizeNullableFilter<$PrismaModel> | $Enums.CompanySize | null
  }

  export type NestedEnumCompanySizeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanySizeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CompanySize | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCompanySizeNullableFilter<$PrismaModel>
    _max?: NestedEnumCompanySizeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumSalesStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SalesStage | EnumSalesStageFieldRefInput<$PrismaModel>
    in?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSalesStageFilter<$PrismaModel> | $Enums.SalesStage
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumSalesStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalesStage | EnumSalesStageFieldRefInput<$PrismaModel>
    in?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalesStage[] | ListEnumSalesStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSalesStageWithAggregatesFilter<$PrismaModel> | $Enums.SalesStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalesStageFilter<$PrismaModel>
    _max?: NestedEnumSalesStageFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CaseCreateWithoutCustomerInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedCasesInput
    attachments?: CaseAttachmentCreateNestedManyWithoutCaseInput
    messages?: CaseMessageCreateNestedManyWithoutCaseInput
    quotes?: QuoteCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutCustomerInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    attachments?: CaseAttachmentUncheckedCreateNestedManyWithoutCaseInput
    messages?: CaseMessageUncheckedCreateNestedManyWithoutCaseInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseCreateOrConnectWithoutCustomerInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutCustomerInput, CaseUncheckedCreateWithoutCustomerInput>
  }

  export type CaseCreateManyCustomerInputEnvelope = {
    data: CaseCreateManyCustomerInput | CaseCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutCustomerInput = {
    id?: string
    quoteNumber: string
    version?: number
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case?: CaseCreateNestedOneWithoutQuotesInput
    project?: ProjectCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateWithoutCustomerInput = {
    id?: string
    quoteNumber: string
    version?: number
    caseId?: string | null
    projectId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateOrConnectWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput>
  }

  export type QuoteCreateManyCustomerInputEnvelope = {
    data: QuoteCreateManyCustomerInput | QuoteCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCustomerInput = {
    id?: string
    projectName: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteCreateNestedManyWithoutProjectInput
    specPackages?: SpecPackageCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCustomerInput = {
    id?: string
    projectName: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutProjectInput
    specPackages?: SpecPackageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput>
  }

  export type ProjectCreateManyCustomerInputEnvelope = {
    data: ProjectCreateManyCustomerInput | ProjectCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TaxExemptDocumentCreateWithoutCustomerInput = {
    id?: string
    state: string
    documentUrl: string
    documentType?: string | null
    status?: $Enums.TaxExemptStatus
    expiresAt?: Date | string | null
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxExemptDocumentUncheckedCreateWithoutCustomerInput = {
    id?: string
    state: string
    documentUrl: string
    documentType?: string | null
    status?: $Enums.TaxExemptStatus
    expiresAt?: Date | string | null
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxExemptDocumentCreateOrConnectWithoutCustomerInput = {
    where: TaxExemptDocumentWhereUniqueInput
    create: XOR<TaxExemptDocumentCreateWithoutCustomerInput, TaxExemptDocumentUncheckedCreateWithoutCustomerInput>
  }

  export type TaxExemptDocumentCreateManyCustomerInputEnvelope = {
    data: TaxExemptDocumentCreateManyCustomerInput | TaxExemptDocumentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CaseCreateWithoutAssignedToInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    customer: UserCreateNestedOneWithoutCasesInput
    attachments?: CaseAttachmentCreateNestedManyWithoutCaseInput
    messages?: CaseMessageCreateNestedManyWithoutCaseInput
    quotes?: QuoteCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutAssignedToInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    customerId: string
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    attachments?: CaseAttachmentUncheckedCreateNestedManyWithoutCaseInput
    messages?: CaseMessageUncheckedCreateNestedManyWithoutCaseInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseCreateOrConnectWithoutAssignedToInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutAssignedToInput, CaseUncheckedCreateWithoutAssignedToInput>
  }

  export type CaseCreateManyAssignedToInputEnvelope = {
    data: CaseCreateManyAssignedToInput | CaseCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type CaseUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CaseWhereUniqueInput
    update: XOR<CaseUpdateWithoutCustomerInput, CaseUncheckedUpdateWithoutCustomerInput>
    create: XOR<CaseCreateWithoutCustomerInput, CaseUncheckedCreateWithoutCustomerInput>
  }

  export type CaseUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CaseWhereUniqueInput
    data: XOR<CaseUpdateWithoutCustomerInput, CaseUncheckedUpdateWithoutCustomerInput>
  }

  export type CaseUpdateManyWithWhereWithoutCustomerInput = {
    where: CaseScalarWhereInput
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CaseScalarWhereInput = {
    AND?: CaseScalarWhereInput | CaseScalarWhereInput[]
    OR?: CaseScalarWhereInput[]
    NOT?: CaseScalarWhereInput | CaseScalarWhereInput[]
    id?: StringFilter<"Case"> | string
    caseNumber?: StringFilter<"Case"> | string
    type?: EnumCaseTypeFilter<"Case"> | $Enums.CaseType
    status?: EnumCaseStatusFilter<"Case"> | $Enums.CaseStatus
    priority?: EnumCasePriorityFilter<"Case"> | $Enums.CasePriority
    slaDueAt?: DateTimeFilter<"Case"> | Date | string
    slaBreached?: BoolFilter<"Case"> | boolean
    customerId?: StringFilter<"Case"> | string
    contactEmail?: StringFilter<"Case"> | string
    companyName?: StringNullableFilter<"Case"> | string | null
    subject?: StringFilter<"Case"> | string
    customerMessage?: StringFilter<"Case"> | string
    internalNotes?: StringNullableFilter<"Case"> | string | null
    relatedSkus?: StringNullableListFilter<"Case">
    relatedOrderIds?: StringNullableListFilter<"Case">
    assignedToId?: StringNullableFilter<"Case"> | string | null
    createdAt?: DateTimeFilter<"Case"> | Date | string
    updatedAt?: DateTimeFilter<"Case"> | Date | string
    closedAt?: DateTimeNullableFilter<"Case"> | Date | string | null
  }

  export type QuoteUpsertWithWhereUniqueWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutCustomerInput, QuoteUncheckedUpdateWithoutCustomerInput>
    create: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutCustomerInput, QuoteUncheckedUpdateWithoutCustomerInput>
  }

  export type QuoteUpdateManyWithWhereWithoutCustomerInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutCustomerInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: StringFilter<"Quote"> | string
    quoteNumber?: StringFilter<"Quote"> | string
    version?: IntFilter<"Quote"> | number
    customerId?: StringFilter<"Quote"> | string
    caseId?: StringNullableFilter<"Quote"> | string | null
    projectId?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    items?: JsonFilter<"Quote">
    subtotal?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    discountPercent?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    taxAmount?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFilter<"Quote"> | Decimal | DecimalJsLike | number | string
    shippingTerms?: StringNullableFilter<"Quote"> | string | null
    leadTimeTerms?: StringNullableFilter<"Quote"> | string | null
    paymentTerms?: StringNullableFilter<"Quote"> | string | null
    exceptions?: StringNullableFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    acceptedBy?: StringNullableFilter<"Quote"> | string | null
    bcOrderId?: StringNullableFilter<"Quote"> | string | null
    createdById?: StringFilter<"Quote"> | string
    notes?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCustomerInput, ProjectUncheckedUpdateWithoutCustomerInput>
    create: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCustomerInput, ProjectUncheckedUpdateWithoutCustomerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCustomerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    projectName?: StringFilter<"Project"> | string
    customerId?: StringFilter<"Project"> | string
    siteAddress?: StringNullableFilter<"Project"> | string | null
    savedSkus?: StringNullableListFilter<"Project">
    notes?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type TaxExemptDocumentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TaxExemptDocumentWhereUniqueInput
    update: XOR<TaxExemptDocumentUpdateWithoutCustomerInput, TaxExemptDocumentUncheckedUpdateWithoutCustomerInput>
    create: XOR<TaxExemptDocumentCreateWithoutCustomerInput, TaxExemptDocumentUncheckedCreateWithoutCustomerInput>
  }

  export type TaxExemptDocumentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TaxExemptDocumentWhereUniqueInput
    data: XOR<TaxExemptDocumentUpdateWithoutCustomerInput, TaxExemptDocumentUncheckedUpdateWithoutCustomerInput>
  }

  export type TaxExemptDocumentUpdateManyWithWhereWithoutCustomerInput = {
    where: TaxExemptDocumentScalarWhereInput
    data: XOR<TaxExemptDocumentUpdateManyMutationInput, TaxExemptDocumentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TaxExemptDocumentScalarWhereInput = {
    AND?: TaxExemptDocumentScalarWhereInput | TaxExemptDocumentScalarWhereInput[]
    OR?: TaxExemptDocumentScalarWhereInput[]
    NOT?: TaxExemptDocumentScalarWhereInput | TaxExemptDocumentScalarWhereInput[]
    id?: StringFilter<"TaxExemptDocument"> | string
    customerId?: StringFilter<"TaxExemptDocument"> | string
    state?: StringFilter<"TaxExemptDocument"> | string
    documentUrl?: StringFilter<"TaxExemptDocument"> | string
    documentType?: StringNullableFilter<"TaxExemptDocument"> | string | null
    status?: EnumTaxExemptStatusFilter<"TaxExemptDocument"> | $Enums.TaxExemptStatus
    expiresAt?: DateTimeNullableFilter<"TaxExemptDocument"> | Date | string | null
    reviewedById?: StringNullableFilter<"TaxExemptDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"TaxExemptDocument"> | Date | string | null
    rejectionReason?: StringNullableFilter<"TaxExemptDocument"> | string | null
    auditLog?: JsonNullableFilter<"TaxExemptDocument">
    createdAt?: DateTimeFilter<"TaxExemptDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TaxExemptDocument"> | Date | string
  }

  export type CaseUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: CaseWhereUniqueInput
    update: XOR<CaseUpdateWithoutAssignedToInput, CaseUncheckedUpdateWithoutAssignedToInput>
    create: XOR<CaseCreateWithoutAssignedToInput, CaseUncheckedCreateWithoutAssignedToInput>
  }

  export type CaseUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: CaseWhereUniqueInput
    data: XOR<CaseUpdateWithoutAssignedToInput, CaseUncheckedUpdateWithoutAssignedToInput>
  }

  export type CaseUpdateManyWithWhereWithoutAssignedToInput = {
    where: CaseScalarWhereInput
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type UserCreateWithoutCasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateWithoutCasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserCreateOrConnectWithoutCasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCasesInput, UserUncheckedCreateWithoutCasesInput>
  }

  export type UserCreateWithoutAssignedCasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentCreateNestedManyWithoutCustomerInput
  }

  export type UserUncheckedCreateWithoutAssignedCasesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserCreateOrConnectWithoutAssignedCasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedCasesInput, UserUncheckedCreateWithoutAssignedCasesInput>
  }

  export type CaseAttachmentCreateWithoutCaseInput = {
    id?: string
    filename: string
    url: string
    mimeType?: string | null
    fileSize?: number | null
    uploadedBy: string
    createdAt?: Date | string
  }

  export type CaseAttachmentUncheckedCreateWithoutCaseInput = {
    id?: string
    filename: string
    url: string
    mimeType?: string | null
    fileSize?: number | null
    uploadedBy: string
    createdAt?: Date | string
  }

  export type CaseAttachmentCreateOrConnectWithoutCaseInput = {
    where: CaseAttachmentWhereUniqueInput
    create: XOR<CaseAttachmentCreateWithoutCaseInput, CaseAttachmentUncheckedCreateWithoutCaseInput>
  }

  export type CaseAttachmentCreateManyCaseInputEnvelope = {
    data: CaseAttachmentCreateManyCaseInput | CaseAttachmentCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type CaseMessageCreateWithoutCaseInput = {
    id?: string
    senderId: string
    senderName: string
    senderRole: $Enums.UserRole
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type CaseMessageUncheckedCreateWithoutCaseInput = {
    id?: string
    senderId: string
    senderName: string
    senderRole: $Enums.UserRole
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type CaseMessageCreateOrConnectWithoutCaseInput = {
    where: CaseMessageWhereUniqueInput
    create: XOR<CaseMessageCreateWithoutCaseInput, CaseMessageUncheckedCreateWithoutCaseInput>
  }

  export type CaseMessageCreateManyCaseInputEnvelope = {
    data: CaseMessageCreateManyCaseInput | CaseMessageCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutCaseInput = {
    id?: string
    quoteNumber: string
    version?: number
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutQuotesInput
    project?: ProjectCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateWithoutCaseInput = {
    id?: string
    quoteNumber: string
    version?: number
    customerId: string
    projectId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateOrConnectWithoutCaseInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutCaseInput, QuoteUncheckedCreateWithoutCaseInput>
  }

  export type QuoteCreateManyCaseInputEnvelope = {
    data: QuoteCreateManyCaseInput | QuoteCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCasesInput = {
    update: XOR<UserUpdateWithoutCasesInput, UserUncheckedUpdateWithoutCasesInput>
    create: XOR<UserCreateWithoutCasesInput, UserUncheckedCreateWithoutCasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCasesInput, UserUncheckedUpdateWithoutCasesInput>
  }

  export type UserUpdateWithoutCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateWithoutCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUpsertWithoutAssignedCasesInput = {
    update: XOR<UserUpdateWithoutAssignedCasesInput, UserUncheckedUpdateWithoutAssignedCasesInput>
    create: XOR<UserCreateWithoutAssignedCasesInput, UserUncheckedCreateWithoutAssignedCasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedCasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedCasesInput, UserUncheckedUpdateWithoutAssignedCasesInput>
  }

  export type UserUpdateWithoutAssignedCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUpdateManyWithoutCustomerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CaseAttachmentUpsertWithWhereUniqueWithoutCaseInput = {
    where: CaseAttachmentWhereUniqueInput
    update: XOR<CaseAttachmentUpdateWithoutCaseInput, CaseAttachmentUncheckedUpdateWithoutCaseInput>
    create: XOR<CaseAttachmentCreateWithoutCaseInput, CaseAttachmentUncheckedCreateWithoutCaseInput>
  }

  export type CaseAttachmentUpdateWithWhereUniqueWithoutCaseInput = {
    where: CaseAttachmentWhereUniqueInput
    data: XOR<CaseAttachmentUpdateWithoutCaseInput, CaseAttachmentUncheckedUpdateWithoutCaseInput>
  }

  export type CaseAttachmentUpdateManyWithWhereWithoutCaseInput = {
    where: CaseAttachmentScalarWhereInput
    data: XOR<CaseAttachmentUpdateManyMutationInput, CaseAttachmentUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseAttachmentScalarWhereInput = {
    AND?: CaseAttachmentScalarWhereInput | CaseAttachmentScalarWhereInput[]
    OR?: CaseAttachmentScalarWhereInput[]
    NOT?: CaseAttachmentScalarWhereInput | CaseAttachmentScalarWhereInput[]
    id?: StringFilter<"CaseAttachment"> | string
    caseId?: StringFilter<"CaseAttachment"> | string
    filename?: StringFilter<"CaseAttachment"> | string
    url?: StringFilter<"CaseAttachment"> | string
    mimeType?: StringNullableFilter<"CaseAttachment"> | string | null
    fileSize?: IntNullableFilter<"CaseAttachment"> | number | null
    uploadedBy?: StringFilter<"CaseAttachment"> | string
    createdAt?: DateTimeFilter<"CaseAttachment"> | Date | string
  }

  export type CaseMessageUpsertWithWhereUniqueWithoutCaseInput = {
    where: CaseMessageWhereUniqueInput
    update: XOR<CaseMessageUpdateWithoutCaseInput, CaseMessageUncheckedUpdateWithoutCaseInput>
    create: XOR<CaseMessageCreateWithoutCaseInput, CaseMessageUncheckedCreateWithoutCaseInput>
  }

  export type CaseMessageUpdateWithWhereUniqueWithoutCaseInput = {
    where: CaseMessageWhereUniqueInput
    data: XOR<CaseMessageUpdateWithoutCaseInput, CaseMessageUncheckedUpdateWithoutCaseInput>
  }

  export type CaseMessageUpdateManyWithWhereWithoutCaseInput = {
    where: CaseMessageScalarWhereInput
    data: XOR<CaseMessageUpdateManyMutationInput, CaseMessageUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseMessageScalarWhereInput = {
    AND?: CaseMessageScalarWhereInput | CaseMessageScalarWhereInput[]
    OR?: CaseMessageScalarWhereInput[]
    NOT?: CaseMessageScalarWhereInput | CaseMessageScalarWhereInput[]
    id?: StringFilter<"CaseMessage"> | string
    caseId?: StringFilter<"CaseMessage"> | string
    senderId?: StringFilter<"CaseMessage"> | string
    senderName?: StringFilter<"CaseMessage"> | string
    senderRole?: EnumUserRoleFilter<"CaseMessage"> | $Enums.UserRole
    message?: StringFilter<"CaseMessage"> | string
    isInternal?: BoolFilter<"CaseMessage"> | boolean
    createdAt?: DateTimeFilter<"CaseMessage"> | Date | string
  }

  export type QuoteUpsertWithWhereUniqueWithoutCaseInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutCaseInput, QuoteUncheckedUpdateWithoutCaseInput>
    create: XOR<QuoteCreateWithoutCaseInput, QuoteUncheckedCreateWithoutCaseInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutCaseInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutCaseInput, QuoteUncheckedUpdateWithoutCaseInput>
  }

  export type QuoteUpdateManyWithWhereWithoutCaseInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseCreateWithoutAttachmentsInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    customer: UserCreateNestedOneWithoutCasesInput
    assignedTo?: UserCreateNestedOneWithoutAssignedCasesInput
    messages?: CaseMessageCreateNestedManyWithoutCaseInput
    quotes?: QuoteCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    customerId: string
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: CaseMessageUncheckedCreateNestedManyWithoutCaseInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseCreateOrConnectWithoutAttachmentsInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutAttachmentsInput, CaseUncheckedCreateWithoutAttachmentsInput>
  }

  export type CaseUpsertWithoutAttachmentsInput = {
    update: XOR<CaseUpdateWithoutAttachmentsInput, CaseUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CaseCreateWithoutAttachmentsInput, CaseUncheckedCreateWithoutAttachmentsInput>
    where?: CaseWhereInput
  }

  export type CaseUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CaseWhereInput
    data: XOR<CaseUpdateWithoutAttachmentsInput, CaseUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CaseUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: UserUpdateOneRequiredWithoutCasesNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedCasesNestedInput
    messages?: CaseMessageUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: CaseMessageUncheckedUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseCreateWithoutMessagesInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    customer: UserCreateNestedOneWithoutCasesInput
    assignedTo?: UserCreateNestedOneWithoutAssignedCasesInput
    attachments?: CaseAttachmentCreateNestedManyWithoutCaseInput
    quotes?: QuoteCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutMessagesInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    customerId: string
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    attachments?: CaseAttachmentUncheckedCreateNestedManyWithoutCaseInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseCreateOrConnectWithoutMessagesInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutMessagesInput, CaseUncheckedCreateWithoutMessagesInput>
  }

  export type CaseUpsertWithoutMessagesInput = {
    update: XOR<CaseUpdateWithoutMessagesInput, CaseUncheckedUpdateWithoutMessagesInput>
    create: XOR<CaseCreateWithoutMessagesInput, CaseUncheckedCreateWithoutMessagesInput>
    where?: CaseWhereInput
  }

  export type CaseUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CaseWhereInput
    data: XOR<CaseUpdateWithoutMessagesInput, CaseUncheckedUpdateWithoutMessagesInput>
  }

  export type CaseUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: UserUpdateOneRequiredWithoutCasesNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedCasesNestedInput
    attachments?: CaseAttachmentUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: CaseAttachmentUncheckedUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type UserCreateWithoutQuotesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateWithoutQuotesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserCreateOrConnectWithoutQuotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
  }

  export type CaseCreateWithoutQuotesInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    customer: UserCreateNestedOneWithoutCasesInput
    assignedTo?: UserCreateNestedOneWithoutAssignedCasesInput
    attachments?: CaseAttachmentCreateNestedManyWithoutCaseInput
    messages?: CaseMessageCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutQuotesInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    customerId: string
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    attachments?: CaseAttachmentUncheckedCreateNestedManyWithoutCaseInput
    messages?: CaseMessageUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseCreateOrConnectWithoutQuotesInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutQuotesInput, CaseUncheckedCreateWithoutQuotesInput>
  }

  export type ProjectCreateWithoutQuotesInput = {
    id?: string
    projectName: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutProjectsInput
    specPackages?: SpecPackageCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutQuotesInput = {
    id?: string
    projectName: string
    customerId: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specPackages?: SpecPackageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutQuotesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutQuotesInput, ProjectUncheckedCreateWithoutQuotesInput>
  }

  export type UserUpsertWithoutQuotesInput = {
    update: XOR<UserUpdateWithoutQuotesInput, UserUncheckedUpdateWithoutQuotesInput>
    create: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuotesInput, UserUncheckedUpdateWithoutQuotesInput>
  }

  export type UserUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type CaseUpsertWithoutQuotesInput = {
    update: XOR<CaseUpdateWithoutQuotesInput, CaseUncheckedUpdateWithoutQuotesInput>
    create: XOR<CaseCreateWithoutQuotesInput, CaseUncheckedCreateWithoutQuotesInput>
    where?: CaseWhereInput
  }

  export type CaseUpdateToOneWithWhereWithoutQuotesInput = {
    where?: CaseWhereInput
    data: XOR<CaseUpdateWithoutQuotesInput, CaseUncheckedUpdateWithoutQuotesInput>
  }

  export type CaseUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: UserUpdateOneRequiredWithoutCasesNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedCasesNestedInput
    attachments?: CaseAttachmentUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: CaseAttachmentUncheckedUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type ProjectUpsertWithoutQuotesInput = {
    update: XOR<ProjectUpdateWithoutQuotesInput, ProjectUncheckedUpdateWithoutQuotesInput>
    create: XOR<ProjectCreateWithoutQuotesInput, ProjectUncheckedCreateWithoutQuotesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutQuotesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutQuotesInput, ProjectUncheckedUpdateWithoutQuotesInput>
  }

  export type ProjectUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutProjectsNestedInput
    specPackages?: SpecPackageUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specPackages?: SpecPackageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type QuoteCreateWithoutProjectInput = {
    id?: string
    quoteNumber: string
    version?: number
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutQuotesInput
    case?: CaseCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateWithoutProjectInput = {
    id?: string
    quoteNumber: string
    version?: number
    customerId: string
    caseId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateOrConnectWithoutProjectInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutProjectInput, QuoteUncheckedCreateWithoutProjectInput>
  }

  export type QuoteCreateManyProjectInputEnvelope = {
    data: QuoteCreateManyProjectInput | QuoteCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SpecPackageCreateWithoutProjectInput = {
    id?: string
    name: string
    skus?: SpecPackageCreateskusInput | string[]
    zipUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SpecPackageUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    skus?: SpecPackageCreateskusInput | string[]
    zipUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SpecPackageCreateOrConnectWithoutProjectInput = {
    where: SpecPackageWhereUniqueInput
    create: XOR<SpecPackageCreateWithoutProjectInput, SpecPackageUncheckedCreateWithoutProjectInput>
  }

  export type SpecPackageCreateManyProjectInputEnvelope = {
    data: SpecPackageCreateManyProjectInput | SpecPackageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    taxExemptDocuments?: TaxExemptDocumentUncheckedUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type QuoteUpsertWithWhereUniqueWithoutProjectInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutProjectInput, QuoteUncheckedUpdateWithoutProjectInput>
    create: XOR<QuoteCreateWithoutProjectInput, QuoteUncheckedCreateWithoutProjectInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutProjectInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutProjectInput, QuoteUncheckedUpdateWithoutProjectInput>
  }

  export type QuoteUpdateManyWithWhereWithoutProjectInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutProjectInput>
  }

  export type SpecPackageUpsertWithWhereUniqueWithoutProjectInput = {
    where: SpecPackageWhereUniqueInput
    update: XOR<SpecPackageUpdateWithoutProjectInput, SpecPackageUncheckedUpdateWithoutProjectInput>
    create: XOR<SpecPackageCreateWithoutProjectInput, SpecPackageUncheckedCreateWithoutProjectInput>
  }

  export type SpecPackageUpdateWithWhereUniqueWithoutProjectInput = {
    where: SpecPackageWhereUniqueInput
    data: XOR<SpecPackageUpdateWithoutProjectInput, SpecPackageUncheckedUpdateWithoutProjectInput>
  }

  export type SpecPackageUpdateManyWithWhereWithoutProjectInput = {
    where: SpecPackageScalarWhereInput
    data: XOR<SpecPackageUpdateManyMutationInput, SpecPackageUncheckedUpdateManyWithoutProjectInput>
  }

  export type SpecPackageScalarWhereInput = {
    AND?: SpecPackageScalarWhereInput | SpecPackageScalarWhereInput[]
    OR?: SpecPackageScalarWhereInput[]
    NOT?: SpecPackageScalarWhereInput | SpecPackageScalarWhereInput[]
    id?: StringFilter<"SpecPackage"> | string
    projectId?: StringFilter<"SpecPackage"> | string
    name?: StringFilter<"SpecPackage"> | string
    skus?: StringNullableListFilter<"SpecPackage">
    zipUrl?: StringNullableFilter<"SpecPackage"> | string | null
    generatedAt?: DateTimeNullableFilter<"SpecPackage"> | Date | string | null
    createdAt?: DateTimeFilter<"SpecPackage"> | Date | string
  }

  export type ProjectCreateWithoutSpecPackagesInput = {
    id?: string
    projectName: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutProjectsInput
    quotes?: QuoteCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSpecPackagesInput = {
    id?: string
    projectName: string
    customerId: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSpecPackagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSpecPackagesInput, ProjectUncheckedCreateWithoutSpecPackagesInput>
  }

  export type ProjectUpsertWithoutSpecPackagesInput = {
    update: XOR<ProjectUpdateWithoutSpecPackagesInput, ProjectUncheckedUpdateWithoutSpecPackagesInput>
    create: XOR<ProjectCreateWithoutSpecPackagesInput, ProjectUncheckedCreateWithoutSpecPackagesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSpecPackagesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSpecPackagesInput, ProjectUncheckedUpdateWithoutSpecPackagesInput>
  }

  export type ProjectUpdateWithoutSpecPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutProjectsNestedInput
    quotes?: QuoteUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSpecPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutTaxExemptDocumentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateWithoutTaxExemptDocumentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name?: string | null
    companyName?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    bcCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cases?: CaseUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    assignedCases?: CaseUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserCreateOrConnectWithoutTaxExemptDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaxExemptDocumentsInput, UserUncheckedCreateWithoutTaxExemptDocumentsInput>
  }

  export type UserUpsertWithoutTaxExemptDocumentsInput = {
    update: XOR<UserUpdateWithoutTaxExemptDocumentsInput, UserUncheckedUpdateWithoutTaxExemptDocumentsInput>
    create: XOR<UserCreateWithoutTaxExemptDocumentsInput, UserUncheckedCreateWithoutTaxExemptDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaxExemptDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaxExemptDocumentsInput, UserUncheckedUpdateWithoutTaxExemptDocumentsInput>
  }

  export type UserUpdateWithoutTaxExemptDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateWithoutTaxExemptDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    bcCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cases?: CaseUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    assignedCases?: CaseUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type PartnerAttributionCreateWithoutPartnerInput = {
    id?: string
    bcOrderId: string
    orderTotal: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PartnerAttributionUncheckedCreateWithoutPartnerInput = {
    id?: string
    bcOrderId: string
    orderTotal: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PartnerAttributionCreateOrConnectWithoutPartnerInput = {
    where: PartnerAttributionWhereUniqueInput
    create: XOR<PartnerAttributionCreateWithoutPartnerInput, PartnerAttributionUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerAttributionCreateManyPartnerInputEnvelope = {
    data: PartnerAttributionCreateManyPartnerInput | PartnerAttributionCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type PartnerAttributionUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PartnerAttributionWhereUniqueInput
    update: XOR<PartnerAttributionUpdateWithoutPartnerInput, PartnerAttributionUncheckedUpdateWithoutPartnerInput>
    create: XOR<PartnerAttributionCreateWithoutPartnerInput, PartnerAttributionUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerAttributionUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PartnerAttributionWhereUniqueInput
    data: XOR<PartnerAttributionUpdateWithoutPartnerInput, PartnerAttributionUncheckedUpdateWithoutPartnerInput>
  }

  export type PartnerAttributionUpdateManyWithWhereWithoutPartnerInput = {
    where: PartnerAttributionScalarWhereInput
    data: XOR<PartnerAttributionUpdateManyMutationInput, PartnerAttributionUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerAttributionScalarWhereInput = {
    AND?: PartnerAttributionScalarWhereInput | PartnerAttributionScalarWhereInput[]
    OR?: PartnerAttributionScalarWhereInput[]
    NOT?: PartnerAttributionScalarWhereInput | PartnerAttributionScalarWhereInput[]
    id?: StringFilter<"PartnerAttribution"> | string
    partnerId?: StringFilter<"PartnerAttribution"> | string
    bcOrderId?: StringFilter<"PartnerAttribution"> | string
    orderTotal?: DecimalFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    commission?: DecimalFilter<"PartnerAttribution"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"PartnerAttribution"> | Date | string | null
    createdAt?: DateTimeFilter<"PartnerAttribution"> | Date | string
  }

  export type PartnerCreateWithoutAttributionsInput = {
    id?: string
    userId: string
    partnerType: $Enums.PartnerType
    companyName: string
    status?: $Enums.PartnerStatus
    referralCode: string
    commissionRate?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerUncheckedCreateWithoutAttributionsInput = {
    id?: string
    userId: string
    partnerType: $Enums.PartnerType
    companyName: string
    status?: $Enums.PartnerStatus
    referralCode: string
    commissionRate?: Decimal | DecimalJsLike | number | string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCreateOrConnectWithoutAttributionsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutAttributionsInput, PartnerUncheckedCreateWithoutAttributionsInput>
  }

  export type PartnerUpsertWithoutAttributionsInput = {
    update: XOR<PartnerUpdateWithoutAttributionsInput, PartnerUncheckedUpdateWithoutAttributionsInput>
    create: XOR<PartnerCreateWithoutAttributionsInput, PartnerUncheckedCreateWithoutAttributionsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutAttributionsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutAttributionsInput, PartnerUncheckedUpdateWithoutAttributionsInput>
  }

  export type PartnerUpdateWithoutAttributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerType?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    companyName?: StringFieldUpdateOperationsInput | string
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    referralCode?: StringFieldUpdateOperationsInput | string
    commissionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateWithoutAttributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    partnerType?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    companyName?: StringFieldUpdateOperationsInput | string
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    referralCode?: StringFieldUpdateOperationsInput | string
    commissionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateWithoutProfileInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    messageType?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    engagement?: number | null
    intent?: AIConversationCreateintentInput | string[]
    urgency?: string | null
    strategy?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type AIConversationUncheckedCreateWithoutProfileInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    messageType?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    engagement?: number | null
    intent?: AIConversationCreateintentInput | string[]
    urgency?: string | null
    strategy?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type AIConversationCreateOrConnectWithoutProfileInput = {
    where: AIConversationWhereUniqueInput
    create: XOR<AIConversationCreateWithoutProfileInput, AIConversationUncheckedCreateWithoutProfileInput>
  }

  export type AIConversationCreateManyProfileInputEnvelope = {
    data: AIConversationCreateManyProfileInput | AIConversationCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type AILeadDataCreateWithoutProfileInput = {
    id?: string
    leadScore?: number
    leadStatus?: $Enums.LeadStatus
    estimatedValue?: string | null
    salesStage?: $Enums.SalesStage
    nextAction?: string | null
    notes?: string | null
    assignedTo?: string | null
    followUpAt?: Date | string | null
    convertedAt?: Date | string | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AILeadDataUncheckedCreateWithoutProfileInput = {
    id?: string
    leadScore?: number
    leadStatus?: $Enums.LeadStatus
    estimatedValue?: string | null
    salesStage?: $Enums.SalesStage
    nextAction?: string | null
    notes?: string | null
    assignedTo?: string | null
    followUpAt?: Date | string | null
    convertedAt?: Date | string | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AILeadDataCreateOrConnectWithoutProfileInput = {
    where: AILeadDataWhereUniqueInput
    create: XOR<AILeadDataCreateWithoutProfileInput, AILeadDataUncheckedCreateWithoutProfileInput>
  }

  export type AIConversationUpsertWithWhereUniqueWithoutProfileInput = {
    where: AIConversationWhereUniqueInput
    update: XOR<AIConversationUpdateWithoutProfileInput, AIConversationUncheckedUpdateWithoutProfileInput>
    create: XOR<AIConversationCreateWithoutProfileInput, AIConversationUncheckedCreateWithoutProfileInput>
  }

  export type AIConversationUpdateWithWhereUniqueWithoutProfileInput = {
    where: AIConversationWhereUniqueInput
    data: XOR<AIConversationUpdateWithoutProfileInput, AIConversationUncheckedUpdateWithoutProfileInput>
  }

  export type AIConversationUpdateManyWithWhereWithoutProfileInput = {
    where: AIConversationScalarWhereInput
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyWithoutProfileInput>
  }

  export type AIConversationScalarWhereInput = {
    AND?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
    OR?: AIConversationScalarWhereInput[]
    NOT?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
    id?: StringFilter<"AIConversation"> | string
    sessionId?: StringFilter<"AIConversation"> | string
    profileId?: StringFilter<"AIConversation"> | string
    role?: StringFilter<"AIConversation"> | string
    content?: StringFilter<"AIConversation"> | string
    messageType?: StringNullableFilter<"AIConversation"> | string | null
    attachments?: JsonNullableFilter<"AIConversation">
    sentiment?: FloatNullableFilter<"AIConversation"> | number | null
    engagement?: FloatNullableFilter<"AIConversation"> | number | null
    intent?: StringNullableListFilter<"AIConversation">
    urgency?: StringNullableFilter<"AIConversation"> | string | null
    strategy?: StringNullableFilter<"AIConversation"> | string | null
    effectiveness?: FloatNullableFilter<"AIConversation"> | number | null
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
  }

  export type AILeadDataUpsertWithoutProfileInput = {
    update: XOR<AILeadDataUpdateWithoutProfileInput, AILeadDataUncheckedUpdateWithoutProfileInput>
    create: XOR<AILeadDataCreateWithoutProfileInput, AILeadDataUncheckedCreateWithoutProfileInput>
    where?: AILeadDataWhereInput
  }

  export type AILeadDataUpdateToOneWithWhereWithoutProfileInput = {
    where?: AILeadDataWhereInput
    data: XOR<AILeadDataUpdateWithoutProfileInput, AILeadDataUncheckedUpdateWithoutProfileInput>
  }

  export type AILeadDataUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadScore?: IntFieldUpdateOperationsInput | number
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    estimatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    salesStage?: EnumSalesStageFieldUpdateOperationsInput | $Enums.SalesStage
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    followUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILeadDataUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadScore?: IntFieldUpdateOperationsInput | number
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    estimatedValue?: NullableStringFieldUpdateOperationsInput | string | null
    salesStage?: EnumSalesStageFieldUpdateOperationsInput | $Enums.SalesStage
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    followUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIClientProfileCreateWithoutConversationsInput = {
    id?: string
    sessionId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    company?: string | null
    website?: string | null
    position?: string | null
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    communicationStyle?: string | null
    decisionSpeed?: string | null
    techLevel?: string | null
    priceSensitivity?: string | null
    avgResponseTime?: number | null
    messageLength?: string | null
    interestLevel?: string | null
    painPoints?: AIClientProfileCreatepainPointsInput | string[]
    budget?: string | null
    timeline?: string | null
    competitors?: AIClientProfileCreatecompetitorsInput | string[]
    conversationSummary?: string | null
    totalMessages?: number
    avgSentiment?: number | null
    avgEngagement?: number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    leadData?: AILeadDataCreateNestedOneWithoutProfileInput
  }

  export type AIClientProfileUncheckedCreateWithoutConversationsInput = {
    id?: string
    sessionId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    company?: string | null
    website?: string | null
    position?: string | null
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    communicationStyle?: string | null
    decisionSpeed?: string | null
    techLevel?: string | null
    priceSensitivity?: string | null
    avgResponseTime?: number | null
    messageLength?: string | null
    interestLevel?: string | null
    painPoints?: AIClientProfileCreatepainPointsInput | string[]
    budget?: string | null
    timeline?: string | null
    competitors?: AIClientProfileCreatecompetitorsInput | string[]
    conversationSummary?: string | null
    totalMessages?: number
    avgSentiment?: number | null
    avgEngagement?: number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    leadData?: AILeadDataUncheckedCreateNestedOneWithoutProfileInput
  }

  export type AIClientProfileCreateOrConnectWithoutConversationsInput = {
    where: AIClientProfileWhereUniqueInput
    create: XOR<AIClientProfileCreateWithoutConversationsInput, AIClientProfileUncheckedCreateWithoutConversationsInput>
  }

  export type AIClientProfileUpsertWithoutConversationsInput = {
    update: XOR<AIClientProfileUpdateWithoutConversationsInput, AIClientProfileUncheckedUpdateWithoutConversationsInput>
    create: XOR<AIClientProfileCreateWithoutConversationsInput, AIClientProfileUncheckedCreateWithoutConversationsInput>
    where?: AIClientProfileWhereInput
  }

  export type AIClientProfileUpdateToOneWithWhereWithoutConversationsInput = {
    where?: AIClientProfileWhereInput
    data: XOR<AIClientProfileUpdateWithoutConversationsInput, AIClientProfileUncheckedUpdateWithoutConversationsInput>
  }

  export type AIClientProfileUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadData?: AILeadDataUpdateOneWithoutProfileNestedInput
  }

  export type AIClientProfileUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadData?: AILeadDataUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type AIClientProfileCreateWithoutLeadDataInput = {
    id?: string
    sessionId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    company?: string | null
    website?: string | null
    position?: string | null
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    communicationStyle?: string | null
    decisionSpeed?: string | null
    techLevel?: string | null
    priceSensitivity?: string | null
    avgResponseTime?: number | null
    messageLength?: string | null
    interestLevel?: string | null
    painPoints?: AIClientProfileCreatepainPointsInput | string[]
    budget?: string | null
    timeline?: string | null
    competitors?: AIClientProfileCreatecompetitorsInput | string[]
    conversationSummary?: string | null
    totalMessages?: number
    avgSentiment?: number | null
    avgEngagement?: number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    conversations?: AIConversationCreateNestedManyWithoutProfileInput
  }

  export type AIClientProfileUncheckedCreateWithoutLeadDataInput = {
    id?: string
    sessionId: string
    name?: string | null
    email?: string | null
    phone?: string | null
    company?: string | null
    website?: string | null
    position?: string | null
    industry?: string | null
    companySize?: $Enums.CompanySize | null
    communicationStyle?: string | null
    decisionSpeed?: string | null
    techLevel?: string | null
    priceSensitivity?: string | null
    avgResponseTime?: number | null
    messageLength?: string | null
    interestLevel?: string | null
    painPoints?: AIClientProfileCreatepainPointsInput | string[]
    budget?: string | null
    timeline?: string | null
    competitors?: AIClientProfileCreatecompetitorsInput | string[]
    conversationSummary?: string | null
    totalMessages?: number
    avgSentiment?: number | null
    avgEngagement?: number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    conversations?: AIConversationUncheckedCreateNestedManyWithoutProfileInput
  }

  export type AIClientProfileCreateOrConnectWithoutLeadDataInput = {
    where: AIClientProfileWhereUniqueInput
    create: XOR<AIClientProfileCreateWithoutLeadDataInput, AIClientProfileUncheckedCreateWithoutLeadDataInput>
  }

  export type AIClientProfileUpsertWithoutLeadDataInput = {
    update: XOR<AIClientProfileUpdateWithoutLeadDataInput, AIClientProfileUncheckedUpdateWithoutLeadDataInput>
    create: XOR<AIClientProfileCreateWithoutLeadDataInput, AIClientProfileUncheckedCreateWithoutLeadDataInput>
    where?: AIClientProfileWhereInput
  }

  export type AIClientProfileUpdateToOneWithWhereWithoutLeadDataInput = {
    where?: AIClientProfileWhereInput
    data: XOR<AIClientProfileUpdateWithoutLeadDataInput, AIClientProfileUncheckedUpdateWithoutLeadDataInput>
  }

  export type AIClientProfileUpdateWithoutLeadDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUpdateManyWithoutProfileNestedInput
  }

  export type AIClientProfileUncheckedUpdateWithoutLeadDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableEnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize | null
    communicationStyle?: NullableStringFieldUpdateOperationsInput | string | null
    decisionSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    techLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priceSensitivity?: NullableStringFieldUpdateOperationsInput | string | null
    avgResponseTime?: NullableIntFieldUpdateOperationsInput | number | null
    messageLength?: NullableStringFieldUpdateOperationsInput | string | null
    interestLevel?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: AIClientProfileUpdatepainPointsInput | string[]
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: AIClientProfileUpdatecompetitorsInput | string[]
    conversationSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    avgSentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    strategyEffectiveness?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type CaseCreateManyCustomerInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type QuoteCreateManyCustomerInput = {
    id?: string
    quoteNumber: string
    version?: number
    caseId?: string | null
    projectId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyCustomerInput = {
    id?: string
    projectName: string
    siteAddress?: string | null
    savedSkus?: ProjectCreatesavedSkusInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxExemptDocumentCreateManyCustomerInput = {
    id?: string
    state: string
    documentUrl: string
    documentType?: string | null
    status?: $Enums.TaxExemptStatus
    expiresAt?: Date | string | null
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaseCreateManyAssignedToInput = {
    id?: string
    caseNumber: string
    type: $Enums.CaseType
    status?: $Enums.CaseStatus
    priority?: $Enums.CasePriority
    slaDueAt: Date | string
    slaBreached?: boolean
    customerId: string
    contactEmail: string
    companyName?: string | null
    subject: string
    customerMessage: string
    internalNotes?: string | null
    relatedSkus?: CaseCreaterelatedSkusInput | string[]
    relatedOrderIds?: CaseCreaterelatedOrderIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type CaseUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedCasesNestedInput
    attachments?: CaseAttachmentUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: CaseAttachmentUncheckedUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUncheckedUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: CaseUpdateOneWithoutQuotesNestedInput
    project?: ProjectUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUpdateManyWithoutProjectNestedInput
    specPackages?: SpecPackageUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutProjectNestedInput
    specPackages?: SpecPackageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    siteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    savedSkus?: ProjectUpdatesavedSkusInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxExemptDocumentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaxExemptStatusFieldUpdateOperationsInput | $Enums.TaxExemptStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxExemptDocumentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaxExemptStatusFieldUpdateOperationsInput | $Enums.TaxExemptStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxExemptDocumentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaxExemptStatusFieldUpdateOperationsInput | $Enums.TaxExemptStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    auditLog?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: UserUpdateOneRequiredWithoutCasesNestedInput
    attachments?: CaseAttachmentUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: CaseAttachmentUncheckedUpdateManyWithoutCaseNestedInput
    messages?: CaseMessageUncheckedUpdateManyWithoutCaseNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCaseTypeFieldUpdateOperationsInput | $Enums.CaseType
    status?: EnumCaseStatusFieldUpdateOperationsInput | $Enums.CaseStatus
    priority?: EnumCasePriorityFieldUpdateOperationsInput | $Enums.CasePriority
    slaDueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    customerMessage?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSkus?: CaseUpdaterelatedSkusInput | string[]
    relatedOrderIds?: CaseUpdaterelatedOrderIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaseAttachmentCreateManyCaseInput = {
    id?: string
    filename: string
    url: string
    mimeType?: string | null
    fileSize?: number | null
    uploadedBy: string
    createdAt?: Date | string
  }

  export type CaseMessageCreateManyCaseInput = {
    id?: string
    senderId: string
    senderName: string
    senderRole: $Enums.UserRole
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type QuoteCreateManyCaseInput = {
    id?: string
    quoteNumber: string
    version?: number
    customerId: string
    projectId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaseAttachmentUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseAttachmentUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseAttachmentUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseMessageUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseMessageUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseMessageUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutQuotesNestedInput
    project?: ProjectUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateManyProjectInput = {
    id?: string
    quoteNumber: string
    version?: number
    customerId: string
    caseId?: string | null
    status?: $Enums.QuoteStatus
    validUntil: Date | string
    items: JsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountPercent?: Decimal | DecimalJsLike | number | string | null
    shippingAmount?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingTerms?: string | null
    leadTimeTerms?: string | null
    paymentTerms?: string | null
    exceptions?: string | null
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    bcOrderId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecPackageCreateManyProjectInput = {
    id?: string
    name: string
    skus?: SpecPackageCreateskusInput | string[]
    zipUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type QuoteUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutQuotesNestedInput
    case?: CaseUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shippingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingTerms?: NullableStringFieldUpdateOperationsInput | string | null
    leadTimeTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    exceptions?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bcOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecPackageUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    skus?: SpecPackageUpdateskusInput | string[]
    zipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecPackageUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    skus?: SpecPackageUpdateskusInput | string[]
    zipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecPackageUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    skus?: SpecPackageUpdateskusInput | string[]
    zipUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerAttributionCreateManyPartnerInput = {
    id?: string
    bcOrderId: string
    orderTotal: Decimal | DecimalJsLike | number | string
    commission: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PartnerAttributionUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerAttributionUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerAttributionUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bcOrderId?: StringFieldUpdateOperationsInput | string
    orderTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateManyProfileInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    messageType?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    engagement?: number | null
    intent?: AIConversationCreateintentInput | string[]
    urgency?: string | null
    strategy?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type AIConversationUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    intent?: AIConversationUpdateintentInput | string[]
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    intent?: AIConversationUpdateintentInput | string[]
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    intent?: AIConversationUpdateintentInput | string[]
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}